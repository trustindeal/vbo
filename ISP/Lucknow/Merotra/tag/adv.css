<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merotra ‚Äî PON / Splitter Tree (Level Columns)</title>

  <!-- External CSS (use your adv.css as requested) -->
  <link rel="stylesheet" href="adv.css">

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <!-- Screenshot lib -->
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

  <style>
    /* only minimal overrides needed for tooltip z-index/placement (adv.css handles rest) */
    #chart { position: relative; }
    .tooltip { position: absolute; pointer-events: none; opacity: 0; transition: opacity .12s; z-index: 120; }
    /* dotted column guideline */
    .col-line { stroke-dasharray: 4 6; stroke: #cbd5e1; stroke-width: 1; }
  </style>
</head>
<body>

  <div class="header">
    <div>
      <div class="header-title">üåê Merotra Network Tree</div>
      <div class="header-sub">Window ‚Üí PON ‚Üí Levels (sheet-order) ‚Üí Splitters</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <button id="controlsBtn" class="btn btn-secondary">Filters</button>
      <button id="reloadBtn" class="btn">Reload</button>
    </div>
  </div>

  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <!-- POPUP (unchanged structure) -->
  <div id="popupModal" class="popup-backdrop">
    <div class="modal-content">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px">
        <div>
          <h2 id="popupTitle" style="margin:0;font-size:16px"></h2>
          <div id="popupPath" style="font-size:12px;color:#475569"></div>
        </div>
        <button id="popupClose" class="btn btn-secondary" style="height:30px">Close</button>
      </div>

      <div id="popupMeta" style="font-size:13px;color:#334155;margin-bottom:8px"></div>
      <div id="popupLinks" style="margin-bottom:8px"></div>

      <h3 style="margin:8px 0 6px;font-size:14px">Users</h3>
      <div class="user-table-container">
        <table id="popupUsersTable" class="user-table"></table>
      </div>

      <div class="download-btns">
        <button id="btnShot" class="download-btn btn-shot">üì∏ Screenshot</button>
        <button id="btnCsv" class="download-btn btn-csv">üìä CSV</button>
      </div>
    </div>
  </div>

  <!-- CONTROLS (unchanged) -->
  <div id="controlsModal" class="controls-backdrop">
    <div class="controls-modal">
      <h3 style="margin:0 0 8px">Filters</h3>

      <div style="margin-bottom:10px">
        <div class="filter-title">Windows</div>
        <div id="windowFilters" class="checkbox-grid"></div>
        <div style="text-align:center;margin-top:6px;font-size:12px;color:#64748b">
          <a href="#" onclick="selectAll('window');return false">Select All</a> |
          <a href="#" onclick="deselectAll('window');return false">Deselect All</a>
        </div>
      </div>

      <div style="margin-bottom:10px">
        <div class="filter-title">PONs</div>
        <div id="ponFilters" class="checkbox-grid pon-grid"></div>
        <div style="text-align:center;margin-top:6px;font-size:12px;color:#64748b">
          <a href="#" onclick="selectAll('pon');return false">Select All</a> |
          <a href="#" onclick="deselectAll('pon');return false">Deselect All</a>
        </div>
      </div>

      <div style="display:flex;gap:8px">
        <button id="applyFiltersBtn" class="btn" style="flex:1">Apply</button>
        <button id="controlsClose" class="btn btn-secondary" style="flex:1">Close</button>
      </div>
    </div>
  </div>

<script>
  // ---------------- CONFIG ----------------
  const BOARD_URL = "https://script.google.com/macros/s/AKfycbzItUueYIqcUuCn2cDaTTrWIF0LiilUxOXhhL-4b4D9aUlEo8Ov9pasR44d6JSM3h1t/exec?mode=board";

  // keep for popup lookups if needed later
  const statusMaps = {};

  // ---------------- STATE ----------------
  const tooltip = document.getElementById("tooltip");
  const popupModal = document.getElementById("popupModal");
  const controlsModal = document.getElementById("controlsModal");
  const popupTitleEl = document.getElementById("popupTitle");
  const popupPathEl  = document.getElementById("popupPath");
  const popupMetaEl  = document.getElementById("popupMeta");
  const popupLinksEl = document.getElementById("popupLinks");
  const popupUsersTbl = document.getElementById("popupUsersTable");

  let serverJson = null;
  let currentTreeData = null;
  let filters = { windows: [], pons: [] };
  let currentPopupRows = [];

  // ---------------- HELPERS ----------------
  function normalizeId(v){ return (v ?? "").toString().trim().replace(/\s+/g,'').toLowerCase(); }

  function parsePon(pon) {
    const m = (pon || "").match(/O(\d+)I(\d+)P(\d+)/i);
    if (!m) return { olt:9999, ip:9999, port:9999 };
    return { olt:+m[1], ip:+m[2], port:+m[3] };
  }

  // ---------------- UI bindings ----------------
  document.getElementById("reloadBtn").addEventListener("click", ()=> loadAll(true));
  document.getElementById("controlsBtn").addEventListener("click", ()=> { controlsModal.style.display='flex'; });
  document.getElementById("controlsClose").addEventListener("click", ()=> { controlsModal.style.display='none'; });
  document.getElementById("popupClose").addEventListener("click", ()=> { popupModal.style.display='none'; });
  document.getElementById("applyFiltersBtn").addEventListener("click", applyFiltersFromUI);
  document.getElementById("btnShot").addEventListener("click", downloadScreenshot);
  document.getElementById("btnCsv").addEventListener("click", downloadCSV);
  window.addEventListener("resize", ()=> { if (currentTreeData) drawTree(currentTreeData); });

  // initial
  loadAll(false);

  async function loadAll(showToast) {
    try {
      setLoading(true);
      const res = await fetch(BOARD_URL);
      if (!res.ok) throw new Error("Board API fetch failed: "+res.status);
      const json = await res.json();
      serverJson = json;

      setupFiltersFromJson();
      const filtered = filterJson(serverJson, filters);
      const treeData = buildHierarchyFromJson(filtered);
      currentTreeData = treeData;
      drawTree(treeData);

      if (json.summary && showToast) {
        console.info("Processed:", json.summary.processedRows, "Skipped:", json.summary.skippedRows);
      }
    } catch (err) {
      console.error(err);
      alert("Error loading board: " + (err.message || err));
    } finally {
      setLoading(false);
    }
  }

  function setLoading(flag){
    const btn = document.getElementById("reloadBtn");
    btn.textContent = flag ? "Loading..." : "Reload";
    btn.disabled = flag;
  }

  // ---------------- Filters from JSON ----------------
  function setupFiltersFromJson(){
    const winNames = (serverJson && Array.isArray(serverJson.windows)) ? serverJson.windows.map(w=>w.window) : [];
    const ponSet = new Set();
    (serverJson.windows || []).forEach(w=>{
      (w.pons || []).forEach(p=> ponSet.add(p.pon));
    });

    filters.windows = winNames.slice();
    filters.pons = Array.from(ponSet);

    const winDiv = document.getElementById("windowFilters");
    const ponDiv = document.getElementById("ponFilters");
    winDiv.innerHTML = ""; ponDiv.innerHTML = "";

    winNames.forEach(w => {
      const el = document.createElement("div"); el.className="checkbox-item";
      el.innerHTML = `<label><input type="checkbox" value="${w}" checked> <span>${w}</span></label>`;
      winDiv.appendChild(el);
    });

    Array.from(ponSet).sort((a,b)=>{
      const pa = parsePon(a), pb = parsePon(b);
      if (pa.olt !== pb.olt) return pa.olt - pb.olt;
      if (pa.ip !== pb.ip) return pa.ip - pb.ip;
      return pa.port - pb.port;
    }).forEach(p => {
      const el = document.createElement("div"); el.className="checkbox-item";
      el.innerHTML = `<label><input type="checkbox" value="${p}" checked> <span>${p}</span></label>`;
      ponDiv.appendChild(el);
    });
  }

  function selectAll(type){
    document.querySelectorAll(`#${type}Filters input[type="checkbox"]`).forEach(ch=>ch.checked=true);
  }
  function deselectAll(type){
    document.querySelectorAll(`#${type}Filters input[type="checkbox"]`).forEach(ch=>ch.checked=false);
  }

  function applyFiltersFromUI(){
    filters.windows = Array.from(document.querySelectorAll("#windowFilters input:checked")).map(i => i.value);
    filters.pons = Array.from(document.querySelectorAll("#ponFilters input:checked")).map(i => i.value);
    controlsModal.style.display='none';
    const filtered = filterJson(serverJson, filters);
    const treeData = buildHierarchyFromJson(filtered);
    currentTreeData = treeData;
    drawTree(treeData);
  }

  function filterJson(json, filters){
    if (!json || !Array.isArray(json.windows)) return { windows: [] };
    const out = { windows: [] };
    json.windows.forEach(w=>{
      if (!filters.windows.includes(w.window)) return;
      const pons = (w.pons || []).filter(p => filters.pons.includes(p.pon));
      if (pons.length) out.windows.push({ window: w.window, pons: pons });
    });
    return out;
  }

  // ---------------- Build hierarchy from JSON (straight mapping) ----------------
  // Input JSON shape (as you specified):
  // { windows: [ { window, pons: [ { pon, levels: [ { level, splitters: [ {recordId,type,users,total}, ... ] }, ... ] }, ... ] } ] }
  function buildHierarchyFromJson(json) {
    const root = { nodeType: "root", name: "üåê Merotra Network", children: [] };

    if (!json || !Array.isArray(json.windows)) return root;

    // windows in the same order as JSON
    json.windows.forEach(win => {
      const winNode = { nodeType: "window", name: "ü™ü " + win.window, rawWindow: win.window, children: [] };
      // sort pons by parsePon (keep natural order within same parse if needed)
      const pons = (win.pons || []).slice().sort((a,b)=>{
        const pa = parsePon(a.pon), pb = parsePon(b.pon);
        if (pa.olt !== pb.olt) return pa.olt - pb.olt;
        if (pa.ip !== pb.ip) return pa.ip - pb.ip;
        return pa.port - pb.port;
      });

      pons.forEach(p => {
        const ponNode = { nodeType:"pon", name:"üîå " + p.pon, rawPon: p.pon, window: win.window, children: [], total: 0 };
        // levels ‚Äî keep sheet order (levels array may have missing numbers; filter empties)
        const levels = (p.levels || []).filter(l => Array.isArray(l.splitters) && l.splitters.length > 0);

        // compute unique users for pon (union of all splitters)
        const ponUsersSet = new Set();
        levels.forEach(l => {
          l.splitters.forEach(s => {
            (s.users || []).forEach(u => ponUsersSet.add(String(u)));
          });
        });

        // map levels to nodes; keep level number
        levels.forEach(levelObj => {
          const lvlNum = (typeof levelObj.level === 'number') ? levelObj.level : Number(levelObj.level) || 0;
          const levelNode = { nodeType: "level", name: `Level ${lvlNum}`, level: lvlNum, children: [] };

          // splitters ‚Äî keep order exactly as given in JSON
          (levelObj.splitters || []).forEach(split => {
            const s = {
              nodeType: "splitter",
              name: `${split.type || ""}${ split.recordId ? ' ‚Äî ' + split.recordId : '' }`,
              recordId: split.recordId || "",
              type: split.type || "",
              users: (split.users || []).map(u => String(u)),
              total: split.total || ((split.users || []).length),
              level: lvlNum,
              pon: p.pon,
              window: win.window,
              children: []
            };
            // push splitter into level
            levelNode.children.push(s);
          });

          // only push level if it has splitters
          if (levelNode.children.length) ponNode.children.push(levelNode);
        });

        ponNode.total = ponUsersSet.size;
        winNode.children.push(ponNode);
      });

      root.children.push(winNode);
    });

    return root;
  }

  // ---------------- DRAW with D3 (columns forced per depth) ----------------
  function drawTree(data) {
    d3.select("#chart").select("svg").remove();

    const container = document.getElementById("chart");
    const width = container.clientWidth || Math.max(window.innerWidth-40,1000);
    const height = Math.max(window.innerHeight - 140, 520);

    // compute max depth (levels of tree). We want columns per depth:
    // depth mapping: root(0) -> window(1) -> pon(2) -> level(3) -> splitter(4)
    const maxDepth = (function findMaxDepth(n, d=0){
      if (!n || !n.children || !n.children.length) return d;
      return Math.max(...n.children.map(c=>findMaxDepth(c,d+1)));
    })(data, 0);

    // set column width equally based on maxDepth
    const columnWidth = Math.max(180, Math.floor((width - 160) / (Math.max(1, maxDepth)))); // leave margins

    // Use tree layout but nodeSize uses [rowSpacing, columnWidth]
    const rowSpacing = 80;
    const treeLayout = d3.tree().nodeSize([rowSpacing, columnWidth]);

    const root = d3.hierarchy(data, d => d.children || []);
    treeLayout(root);

    const svg = d3.select("#chart").append("svg").attr("width", width).attr("height", height);
    const zoom = d3.zoom().scaleExtent([0.35, 2.5]).on("zoom", (event) => g.attr("transform", event.transform));
    svg.call(zoom);

    // center origin a bit left
    const g = svg.append("g").attr("transform", "translate(80,40)");

    // draw vertical dotted column lines for each depth (skip depth 0 root line)
    const depths = new Set(root.descendants().map(d => d.depth));
    const minDepth = Math.min(...depths);
    const maxD = Math.max(...depths);
    for (let d = 1; d <= maxD; d++) {
      // find an x for this depth: choose average y of nodes at that depth
      const nodesAtDepth = root.descendants().filter(nd => nd.depth === d);
      if (!nodesAtDepth.length) continue;
      const avgY = d3.mean(nodesAtDepth, nd => nd.y);
      g.append("line")
        .attr("x1", avgY).attr("y1", -40)
        .attr("x2", avgY).attr("y2", height)
        .attr("class", "col-line");
    }

    // links (curved)
    g.selectAll(".link").data(root.links()).enter().append("path")
      .attr("class","link")
      .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x))
      .attr("fill","none").attr("stroke","#94a3b8").attr("stroke-width",1.6)
      .attr("stroke-linecap","round");

    // nodes
    const node = g.selectAll(".node").data(root.descendants()).enter().append("g")
      .attr("class","node")
      .attr("transform", d => `translate(${d.y},${d.x})`);

    // circles by nodeType
    node.append("circle")
      .attr("r", d => {
        if (d.data.nodeType === "root") return 20;
        if (d.data.nodeType === "window") return 18;
        if (d.data.nodeType === "pon") return 16;
        if (d.data.nodeType === "level") return 10;
        if (d.data.nodeType === "splitter") return 12;
        return 8;
      })
      .attr("fill", d => {
        if (d.data.nodeType === "root") return "#1e3a8a";
        if (d.data.nodeType === "window") return "#1d4ed8";
        if (d.data.nodeType === "pon") return "#0f766e";
        if (d.data.nodeType === "level") return "#6b7280";
        if (d.data.nodeType === "splitter") return (d.data.total && d.data.total>0) ? "#10b981" : "#6b7280";
        return "#94a3b8";
      })
      .attr("stroke","#fff").attr("stroke-width",2);

    // text labels
    node.append("text")
      .attr("dy","0.32em")
      .attr("x", d => d.children && d.depth>0 ? -18 : 18)
      .attr("text-anchor", d => d.children && d.depth>0 ? "end" : "start")
      .style("font-size", d => {
        if (d.data.nodeType === "root") return "14px";
        if (d.data.nodeType === "window") return "13px";
        if (d.data.nodeType === "pon") return "12px";
        if (d.data.nodeType === "splitter") return "11px";
        return "10px";
      })
      .style("font-weight", d => (d.data.nodeType === "root" || d.data.nodeType === "window" || d.data.nodeType === "pon") ? 700 : 600)
      .text(d => {
        if (d.data.nodeType === "pon") return `${d.data.name} (${d.data.total||0})`;
        if (d.data.nodeType === "splitter") {
          const label = d.data.recordId ? `${d.data.recordId} | ${d.data.type}` : `${d.data.type}`;
          return `${label} (${d.data.total|| (d.data.users ? d.data.users.length : 0)})`;
        }
        if (d.data.nodeType === "level") return d.data.name;
        return d.data.name;
      });

    // interactions: show tooltip on hover; click on splitters / level to see users if splitter
    node.on("mousemove", (event, d) => {
        handleMouseOver(event, d);
      })
      .on("mouseout", ()=> tooltip.style.opacity = 0)
      .on("click", (event, d) => {
        if (d.data.nodeType === "splitter") handleNodeClick(event, d);
      });

    // fit-to-view (scale/center)
    fitToView(svg, g, zoom);
  }

  function fitToView(svgRoot, g, zoom) {
    const chart = document.getElementById("chart");
    const bounds = g.node().getBBox();
    const fullWidth = chart.clientWidth;
    const fullHeight = chart.clientHeight;
    const widthScale = fullWidth / (bounds.width + 160 || 1);
    const heightScale = fullHeight / (bounds.height + 160 || 1);
    const scale = Math.min(1.6, Math.max(0.35, Math.min(widthScale, heightScale)));
    const tx = -(bounds.x)*scale + 40;
    const ty = -(bounds.y)*scale + 40;
    svgRoot.transition().duration(600).call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(scale));
  }

  // ---------------- TOOLTIP & POPUP ----------------
  function handleMouseOver(event, d) {
    const data = d.data;
    let html = `<strong>${data.name}</strong><br/>`;
    if (data.nodeType === "window") html += `Window`;
    else if (data.nodeType === "pon") html += `PON: ${data.rawPon || data.name}<br/>Total users: ${data.total || 0}`;
    else if (data.nodeType === "level") html += `Level ${data.level || ""}`;
    else if (data.nodeType === "splitter") {
      html += `Type: ${data.type || "-"}<br/>Record: ${data.recordId || "-"}<br/>Users: <strong>${data.total || (data.users ? data.users.length : 0)}</strong>`;
    }
    tooltip.innerHTML = html;
    tooltip.style.left = (event.pageX + 12) + "px";
    tooltip.style.top  = (event.pageY + 8) + "px";
    tooltip.style.opacity = 1;
  }

  function handleNodeClick(event, d) {
    const data = d.data;
    if (data.nodeType !== "splitter") return;

    const total = data.total || (data.users ? data.users.length : 0);
    popupTitleEl.textContent = `${data.type || "Splitter"} ‚Äî ${data.recordId || ""}`;
    popupPathEl.textContent = `${data.window || ""} ‚Üí ${data.pon || ""} ‚Üí Level ${data.level || ""}`;
    popupMetaEl.innerHTML = `<div><strong>Total users:</strong> ${total}</div><div><strong>Record ID:</strong> ${data.recordId || "-"}</div><div><strong>Type:</strong> ${data.type || "-"}</div>`;

    popupLinksEl.innerHTML = "";
    buildUserTable(data);
    popupModal.style.display = 'flex';
  }

  function buildUserTable(data) {
    const rawUsers = data.users || [];
    popupUsersTbl.innerHTML = `
      <thead>
        <tr><th style="width:36px">Sr</th><th>User ID</th></tr>
      </thead>
      <tbody></tbody>
    `;
    const tbody = popupUsersTbl.querySelector("tbody");
    currentPopupRows = [];

    rawUsers.forEach((uid, idx) => {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${idx+1}</td><td>${uid}</td>`;
      tbody.appendChild(tr);
      currentPopupRows.push({ sr: idx+1, id: uid });
    });
  }

  // ---------------- Downloads ----------------
  function downloadScreenshot(){
    const modalContent = document.querySelector("#popupModal .modal-content");
    if (!modalContent) return;
    html2canvas(modalContent).then(canvas=>{
      const link = document.createElement("a");
      const today = new Date().toISOString().slice(0,10);
      link.download = `merotra-users-${today}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    });
  }

  function downloadCSV(){
    if (!currentPopupRows.length) return;
    const header = ["Sr","User ID"];
    const lines = [header.join(",")];
    currentPopupRows.forEach(r=>{
      const row = [ r.sr, `"${(r.id||"").replace(/"/g,'""')}"` ];
      lines.push(row.join(","));
    });
    const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    const today = new Date().toISOString().slice(0,10);
    link.href = url; link.download = `merotra-users-${today}.csv`; link.click();
    URL.revokeObjectURL(url);
  }

</script>
</body>
</html>
