<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merotra — Fiber Network Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="adv.css">
  <style>
    :root{font-family:Inter,system-ui,Arial;-webkit-tap-highlight-color:transparent}
    *{box-sizing:border-box}
    body{margin:0;padding:0;background:linear-gradient(135deg,#0f172a,#1e293b);color:#e2e8f0;overflow:hidden;height:100vh}
    #chart{width:100%;height:calc(100vh - 72px);overflow:hidden;position:relative;background:transparent}

    /* Premium Dark Header */
    .header{
      background:linear-gradient(135deg,rgba(15,25,45,0.98),rgba(30,41,59,0.98));
      backdrop-filter:blur(16px);
      border-bottom:1px solid rgba(148,163,184,0.15);
      padding:14px 18px;
      display:flex;justify-content:space-between;align-items:center;
      position:sticky;top:0;z-index:50;
      box-shadow:0 10px 40px rgba(0,0,0,0.4);
    }
    .header-title{
      font-size:1.45rem;font-weight:900;color:transparent;
      background:linear-gradient(90deg,#60a5fa,#a78bfa,#ec4899);
      -webkit-background-clip:text;background-clip:text;
      letter-spacing:-0.8px;
      text-shadow:0 4px 20px rgba(96,165,250,0.3);
    }

    .toolbar{display:flex;gap:12px;align-items:center;flex-wrap:wrap}

    .btn{
      background:#334155;color:#e2e8f0;padding:10px 16px;border-radius:14px;
      border:none;font-weight:700;font-size:0.95rem;cursor:pointer;
      transition:all .28s cubic-bezier(0.4,0,0.2,1);
      box-shadow:0 6px 16px rgba(0,0,0,0.35);
    }
    .btn:hover{transform:translateY(-3px);box-shadow:0 12px 28px rgba(0,0,0,0.5)}
    .btn:active{transform:translateY(-1px)}

    #refreshBtn{background:#1e40af}
    #filterBtn{background:#7c3aed}
    #searchFold{
      background:#ec4899;color:white;padding:12px;border-radius:50%;
      width:48px;height:48px;display:flex;align-items:center;justify-content:center;
      font-size:1.5rem;box-shadow:0 8px 24px rgba(236,72,153,0.4);
    }

    /* Search Input - Bouncy Expand */
    #searchInput{
      width:260px;padding:12px 16px;border-radius:20px;background:#334155;
      border:2px solid transparent;color:white;font-size:1rem;
      transition:all .4s cubic-bezier(0.68,-0.55,0.265,1.55);
      transform:scaleX(0);opacity:0;transform-origin:right center;
    }
    #searchInput.expanded{
      transform:scaleX(1);opacity:1;border-color:#ec4899;
    }

    /* Filter Modal */
    #filterModal{
      position:fixed;inset:0;background:rgba(0,0,0,0.85);display:none;
      align-items:center;justify-content:center;z-index:100;backdrop-filter:blur(12px);
    }
    .filter-panel{
      background:#1e293b;border-radius:24px;padding:24px;width:92%;max-width:440px;
      box-shadow:0 30px 80px rgba(0,0,0,0.7);border:1px solid rgba(148,163,184,0.2);
      animation:popIn .45s cubic-bezier(0.2,0.8,0.4,1);
    }
    .filter-title{color:#60a5fa;font-size:1.4rem;font-weight:800;text-align:center;margin-bottom:20px}
    .filter-group{margin-bottom:18px}
    .filter-group label{color:#94a3b8;font-size:0.95rem;margin-bottom:8px;display:block}
    select{
      width:100%;padding:12px 14px;border-radius:14px;background:#334155;
      border:1px solid #475569;color:#e2e8f0;font-size:1rem;
    }
    select:focus{border-color:#a78bfa;outline:none;box-shadow:0 0 0 3px rgba(167,139,250,0.2)}
    .filter-actions{display:flex;gap:14px;margin-top:24px}
    .filter-actions button{flex:1;padding:12px;border-radius:14px;font-weight:700;font-size:1rem}
    #applyFilters{background:#10b981;color:white}
    #clearFilters{background:#ef4444;color:white}

    /* 3D Tree Styling */
    .hnode{filter:drop-shadow(0 10px 30px rgba(0,0,0,0.6))}
    .hnode circle{stroke:#fff;stroke-width:4;transform:scale(1.08)}
    .hnode text{filter:drop-shadow(0 3px 8px rgba(0,0,0,0.8));font-weight:800}
    .link{stroke-width:4;stroke-linecap:round;opacity:0;
          animation:drawLine 2s forwards ease-out;stroke-dasharray:1000;stroke-dashoffset:1000}
    .hwlink{stroke:#475569}
    .splitter{filter:drop-shadow(0 8px 24px rgba(0,0,0,0.7))}
    .splitter circle{stroke:#fff;stroke-width:4}
    .splitter text{fill:#e2e8f0;font-weight:800}

    /* Rotation Button */
    .rotate-btn{
      position:fixed;bottom:24px;right:24px;z-index:90;background:#7c3aed;color:white;
      width:64px;height:64px;border-radius:50%;display:flex;align-items:center;justify-content:center;
      font-size:2rem;box-shadow:0 12px 32px rgba(124,58,237,0.5);cursor:pointer;
      animation:float 5s ease-in-out infinite;
    }

    /* Animations */
    @keyframes drawLine{
      to{stroke-dashoffset:0;opacity:0.9}
    }
    @keyframes popIn{
      from{transform:scale(0.7) translateY(50px);opacity:0}
      to{transform:scale(1) translateY(0);opacity:1}
    }
    @keyframes float{
      0%,100%{transform:translateY(0) rotate(0deg)}
      50%{transform:translateY(-16px) rotate(5deg)}
    }

    /* Mobile */
    @media(max-width:768px){
      .header-title{font-size:1.2rem}
      .toolbar{gap:10px}
      .btn{padding:9px 14px;font-size:0.9rem}
      #searchInput{width:200px}
      .rotate-btn{width:56px;height:56px;font-size:1.8rem;bottom:18px;right:18px}
    }
  </style>
</head>
<body>

  <!-- Header -->
  <div class="header">
    <div>
      <div class="header-title">Auto populated fiber network</div>
    </div>
    <div class="toolbar">
      <button id="filterBtn" class="btn">Filters</button>
      <button id="searchFold" class="btn">Search</button>
      <input id="searchInput" placeholder="Search user / splitter..." />
      <button id="refreshBtn" class="btn">Refresh</button>
    </div>
  </div>

  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <!-- Rotation Control -->
  <div id="rotateBtn" class="rotate-btn" title="Rotate 90°">Rotate</div>

  <!-- Filter Modal -->
  <div id="filterModal">
    <div class="filter-panel">
      <div class="filter-title">Filters</div>
      <div class="filter-group">
        <label>Window</label>
        <select id="windowFilter"></select>
      </div>
      <div class="filter-group">
        <label>OLT</label>
        <select id="oltFilter"></select>
      </div>
      <div class="filter-group">
        <label>PON</label>
        <select id="ponFilter"></select>
      </div>
      <div class="filter-actions">
        <button id="applyFilters" class="btn">Apply</button>
        <button id="clearFilters" class="btn">Clear All</button>
      </div>
      <button style="margin-top:16px;width:100%;padding:12px;background:#475569;color:#e2e8f0;border:none;border-radius:14px;cursor:pointer;font-weight:600" 
              onclick="document.getElementById('filterModal').style.display='none'">Close</button>
    </div>
  </div>

  <!-- Popup Modal (unchanged) -->
  <div id="popupModal" class="popup-backdrop" style="display:none">
    <div class="modal-content">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px">
        <div>
          <h2 id="popupTitle" style="margin:0;font-size:16px"></h2>
          <div id="popupPath" style="font-size:12px;color:#94a3b8"></div>
        </div>
        <button id="popupClose" class="btn btn-secondary" style="height:30px">Close</button>
      </div>
      <div id="popupMeta" style="font-size:13px;color:#94a3b8;margin-bottom:8px"></div>
      <div style="max-height:60vh;overflow:auto">
        <table id="popupUsersTable" class="user-table"></table>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="btnShot" class="btn">Screenshot</button>
        <button id="btnCsv" class="btn btn-secondary">CSV</button>
      </div>
    </div>
  </div>

<script>
// DESIGN ONLY - NO LOGIC CHANGES
document.getElementById('filterBtn').onclick = () => {
  document.getElementById('filterModal').style.display = 'flex';
};

document.getElementById('applyFilters').onclick = () => {
  applyFiltersAndRender();
  document.getElementById('filterModal').style.display = 'none';
};

document.getElementById('clearFilters').onclick = () => {
  windowFilter.value = oltFilter.value = ponFilter.value = '';
  applyFiltersAndRender();
  document.getElementById('filterModal').style.display = 'none';
};

// Bouncy Search
document.getElementById('searchFold').onclick = () => {
  const input = document.getElementById('searchInput');
  input.classList.toggle('expanded');
  if(input.classList.contains('expanded')) {
    input.focus();
  } else {
    input.value = '';
    applyFiltersAndRender();
  }
};

// 90° Rotation (4 clicks = 360°)
let rotation = 0;
document.getElementById('rotateBtn').onclick = () => {
  rotation = (rotation + 90) % 360;
  const chart = document.getElementById('chart');
  chart.style.transform = `rotate(${rotation}deg)`;
  chart.style.transition = 'transform 0.6s cubic-bezier(0.34,1.56,0.64,1)';
};
  </script>

<script>
// YOUR FULL ORIGINAL SCRIPT (100% UNTOUCHED) - STARTS HERE
const BOARD_URL = "https://script.google.com/macros/s/AKfycbzItUueYIqcUuCn2cDaTTrWIF0LiilUxOXhhL-4b4D9aUlEo8Ov9pasR44d6JSM3h1t/exec?mode=board";
let rawJson = null;
let colorByOlt = new Map();
const tooltip = document.getElementById('tooltip');
const reloadBtn = document.getElementById('reloadBtn');
const popupModal = document.getElementById('popupModal');
const popupClose = document.getElementById('popupClose');
const popupTitle = document.getElementById('popupTitle');
const popupPath = document.getElementById('popupPath');
const popupMeta = document.getElementById('popupMeta');
const popupUsers = document.getElementById('popupUsersTable');
const windowFilter = document.getElementById('windowFilter');
const oltFilter = document.getElementById('oltFilter');
const ponFilter = document.getElementById('ponFilter');
const clearFilters = document.getElementById('clearFilters');
const searchFold = document.getElementById('searchFold');
const searchInput = document.getElementById('searchInput');
document.getElementById('btnShot').addEventListener('click', downloadScreenshot);
document.getElementById('btnCsv').addEventListener('click', downloadCSV);
popupClose.addEventListener('click', ()=> popupModal.style.display='none');
reloadBtn.addEventListener('click', ()=> loadAndRender(true));
windowFilter.addEventListener('change', applyFiltersAndRender);
oltFilter.addEventListener('change', applyFiltersAndRender);
ponFilter.addEventListener('change', applyFiltersAndRender);
clearFilters.addEventListener('click', ()=> {
  windowFilter.value=''; oltFilter.value=''; ponFilter.value='';
  applyFiltersAndRender();
});
searchFold.addEventListener('click', ()=> {
  if (searchInput.style.display === 'none') {
    searchInput.style.display='inline-block';
    searchInput.focus();
  } else {
    searchInput.style.display='none';
    searchInput.value='';
    applyFiltersAndRender();
  }
});
searchInput.addEventListener('input', ()=> applyFiltersAndRender());

function normalizeId(v){ return (v ?? "").toString().trim(); }
function getOltNumberFromPon(pon){
  const m = (pon || "").match(/O(\d+)/i);
  return m ? m[1] : "0";
}
function parsePonKey(pon){
  const m = (pon || "").match(/O(\d+)I(\d+)P(\d+)/i);
  if(!m) return {olt:9999, ip:9999, port:9999};
  return {olt:+m[1], ip:+m[2], port:+m[3]};
}
function ensureColorForOlt(olt){
  if(!colorByOlt.has(String(olt))){
    const idx = colorByOlt.size;
    const h = (idx * 50) % 360;
    colorByOlt.set(String(olt), `hsl(${h} 65% 45%)`);
  }
  return colorByOlt.get(String(olt));
}

async function loadAndRender(showToast=false){
  try {
    setLoading(true);
    const res = await fetch(BOARD_URL);
    if(!res.ok) throw new Error("HTTP "+res.status);
    const j = await res.json();
    rawJson = j;
    colorByOlt = new Map();
    buildFiltersFromJson(j);
    applyFiltersAndRender();
    if(showToast) console.info('Board loaded', j.summary || {});
  } catch(err){
    console.error(err);
    alert("Load error: " + err.message);
  } finally {
    setLoading(false);
  }
}
function setLoading(flag){
  reloadBtn.disabled = flag;
  reloadBtn.textContent = flag ? "Loading..." : "Refresh";
}
function buildFiltersFromJson(j){
  const winSet=new Set(), oltSet=new Set(), ponSet=new Set();
  (j.windows||[]).forEach(w=>{
    winSet.add(w.window||'');
    (w.pons||[]).forEach(p=>{
      ponSet.add(p.pon||'');
      oltSet.add(getOltNumberFromPon(p.pon||''));
    });
  });
  populateSelect(windowFilter, ['', ...Array.from(winSet).sort()], "(all)");
  populateSelect(oltFilter, ['', ...Array.from(oltSet).sort((a,b)=>+a-+b)], "(all)");
  populateSelect(ponFilter, ['', ...Array.from(ponSet).sort()], "(all)");
}
function populateSelect(sel, arr, label){
  const prev = sel.value||'';
  sel.innerHTML='';
  const o0=document.createElement('option'); o0.value=''; o0.textContent=label; sel.appendChild(o0);
  arr.filter(x=>x!=='').forEach(v=>{
    const o=document.createElement('option'); o.value=v; o.textContent=v; sel.appendChild(o);
  });
  if(prev) sel.value = prev;
}
function applyFiltersAndRender(){
  if(!rawJson) return;
  const filtered = applyClientFilters(rawJson);
  const root = transformToHierarchy(filtered);
  renderBalancedTree(root);
}
function applyClientFilters(j){
  const wsel=windowFilter.value;
  const oltsel=oltFilter.value;
  const psel=ponFilter.value;
  const term=(searchInput.value||'').trim().toLowerCase();
  const out={windows:[]};
  (j.windows||[]).forEach(win=>{
    if(wsel && win.window !== wsel) return;
    const newWin={window:win.window, pons:[]};
    (win.pons||[]).forEach(p=>{
      if(psel && p.pon !== psel) return;
      if(oltsel && getOltNumberFromPon(p.pon) !== oltsel) return;
      const newLv = (p.levels||[]).filter(l=>Array.isArray(l.splitters)&&l.splitters.length>0);
      if(newLv.length===0 && term){
        if(!deepSearchMatch(p, term)) return;
      }
      newWin.pons.push({...p, levels:newLv});
    });
    if(newWin.pons.length>0 || !wsel) out.windows.push(newWin);
  });
  return out;
}
function deepSearchMatch(p, term){
  if(!term) return false;
  for(const lvl of (p.levels||[])){
    for(const sp of (lvl.splitters||[])){
      for(const u of (sp.users||[])){
        if(String(u).toLowerCase().includes(term)) return true;
      }
    }
  }
  return false;
}
function transformToHierarchy(j){
  const root = { name:'Merotra Network', type:'network', children:[] };
  (j.windows || []).forEach(win => {
    const winNode = { name: win.window, type:'window', children:[] };
    const oltMap = {};
    (win.pons || []).forEach(p => {
      const meta = parsePonKey(p.pon);
      const levels = (p.levels||[])
        .map(l=>({
          level:l.level,
          splitters:(l.splitters||[]).map(sp=>({
            recordId:sp.recordId||'',
            type:sp.type||'',
            users:(sp.users||[]).map(x=>String(x)),
            total:sp.total || ((sp.users||[]).length || 0)
          }))
        }));
      const ponNode={ name: p.pon, type:'pon', meta, levels };
      const oltNum = String(meta.olt);
      if(!oltMap[oltNum]){
        oltMap[oltNum] = { name: "OLT-"+oltNum, type:'olt', meta:{olt:oltNum}, children:[] };
      }
      oltMap[oltNum].children.push(ponNode);
    });
    Object.values(oltMap).forEach(oltn=>{
      oltn.children.sort((a,b)=>{
        if(+a.meta.olt !== +b.meta.olt) return +a.meta.olt - +b.meta.olt;
        if(+a.meta.ip !== +b.meta.ip ) return +a.meta.ip - +b.meta.ip;
        return +a.meta.port - +b.meta.port;
      });
    });
    Object.values(oltMap).sort((a,b)=> (+a.meta.olt)-(+b.meta.olt)).forEach(olt=> winNode.children.push(olt));
    root.children.push(winNode);
  });
  return root;
}
function renderBalancedTree(rootData){
  d3.select('#chart').selectAll('*').remove();
  const chartEl = document.getElementById('chart');
  const width = chartEl.clientWidth || window.innerWidth;
  const height = chartEl.clientHeight || (window.innerHeight - 60);
  const treeRoot = d3.hierarchy(rootData);
  const leafCount = Math.max(1, countLeaves(rootData));
  const nodeGap = Math.max(36, Math.min(90, Math.floor(height / (leafCount + 3))));
  const treeLayout = d3.tree().nodeSize([nodeGap, 160]);
  treeLayout(treeRoot);
  const svg = d3.select("#chart").append("svg").attr("width","100%").attr("height","100%");
  const g = svg.append("g").attr("transform","translate(40,40)");

  g.selectAll(".hwlink")
    .data(treeRoot.links())
    .enter()
    .append("path")
    .attr("class","link hwlink")
    .attr("fill","none")
    .attr("stroke","#94a3b8")
    .attr("stroke-width",3)
    .attr("d", d => {
      const sx = d.source.y, sy = d.source.x, tx = d.target.y, ty = d.target.x;
      const midX = (sx + tx) / 2;
      return `M${sx},${sy} C ${midX},${sy} ${midX},${ty} ${tx},${ty}`;
    });

  const nodes = treeRoot.descendants();
  const nodeG = g.selectAll(".hnode")
    .data(nodes)
    .enter().append("g")
    .attr("class","hnode")
    .attr("transform", d=>`translate(${d.y},${d.x})`);

  nodeG.append("circle")
    .attr("r", d => ({network:24, window:20, olt:18, pon:16}[d.data.type] || 12))
    .attr("fill", d => {
      if(d.data.type==='network') return '#1e40af';
      if(d.data.type==='window') return '#3b82f6';
      if(d.data.type==='olt') return ensureColorForOlt(d.data.meta.olt);
      if(d.data.type==='pon') return '#0d9488';
      return '#64748b';
    })
    .attr("stroke","#fff").attr("stroke-width",3);

  nodeG.append("text")
    .attr("x", d=> d.data.type==='network'?0:20)
    .attr("y", 5)
    .attr("font-size","13px")
    .attr("font-weight","800")
    .attr("text-anchor", d=> d.data.type==='network'? "middle":"start")
    .attr("fill", "#e2e8f0")
    .text(d=>d.data.name);

  const ponNodes = treeRoot.descendants().filter(n => n.data && n.data.type === 'pon');
  const levelColWidth = 220;
  const ponColGap = 140;
  const minVGap = 48;
  const growthPerItem = 12;
  const allSplitterPositions = [];

  ponNodes.forEach(ponN => {
    const p = ponN.data;
    const baseX = ponN.y;
    const baseY = ponN.x;
    const levels = (p.levels || []);
    if(levels.length === 0) return;
    const maxCount = Math.max(...levels.map(l => (l.splitters || []).length, 1), 1);
    const vGap = Math.max(minVGap, minVGap + (maxCount - 1) * growthPerItem);
    const levelSplitters = levels.map(l => Array.isArray(l.splitters) ? l.splitters.slice() : []);
    const userSetOf = sp => new Set((sp.users || []).map(u => normalizeId(u)));
    const orderedLevels = [];
    if(levelSplitters.length >= 1) {
      orderedLevels.push(levelSplitters[0].map((s, i) => ({s, origIndex: i})));
      for(let li = 1; li < levelSplitters.length; li++){
        const parents = orderedLevels[li-1];
        const parentSets = parents.map(pObj => userSetOf(pObj.s));
        const children = levelSplitters[li].map((s, idx) => ({s, origIndex: idx}));
        const childWithKey = children.map(ch => {
          const chSet = userSetOf(ch.s);
          let foundParentIndex = null;
          for(let pi = 0; pi < parentSets.length; pi++){
            for(const u of chSet){
              if(parentSets[pi].has(u)){ foundParentIndex = pi; break; }
            }
            if(foundParentIndex !== null) break;
          }
          return { ch, key: (foundParentIndex === null ? 9999 : foundParentIndex) };
        });
        childWithKey.sort((a,b) => {
          if(a.key !== b.key) return a.key - b.key;
          return a.ch.origIndex - b.ch.origIndex;
        });
        orderedLevels.push(childWithKey.map(x => x.ch));
      }
    }
    orderedLevels.forEach((arr, li) => {
      const count = Math.max(1, arr.length);
      const totalH = (count - 1) * vGap;
      const startY = baseY - totalH / 2;
      const stagger = (li % 2 === 0) ? 0 : Math.min(14, Math.floor(vGap/5));
      arr.forEach((obj, si) => {
        const sx = baseX + ponColGap + li * levelColWidth + (li % 2 === 0 ? 0 : 8);
        const sy = startY + si * vGap + stagger;
        allSplitterPositions.push({
          pon: p.name,
          level: levels[li].level,
          idx: si,
          x: sx,
          y: sy,
          data: obj.s,
          color: ensureColorForOlt(p.meta.olt)
        });
      });
    });
  });

  const sg = g.append("g").attr("class","splitters-group");
  const splitterNodes = sg.selectAll(".splitter")
    .data(allSplitterPositions)
    .enter()
    .append("g")
    .attr("class","splitter")
    .attr("transform", d=>`translate(${d.x},${d.y})`)
    .style("cursor","pointer")
    .on("mousemove",(ev,d)=> showTooltip(ev, {name:d.data.type || d.data.recordId, total:d.data.total}))
    .on("mouseout", hideTooltip)
    .on("click", (ev,d)=> openPopup(d.data, d.pon, findWindowForPon(d.pon)));

  splitterNodes.each(function(d){
    const g2 = d3.select(this);
    g2.append("circle").attr("r", 14)
      .attr("fill", d.data.total && d.data.total>0 ? "#10b981" : "#6b7280")
      .attr("stroke","#fff").attr("stroke-width",3);
    g2.append("text").attr("x", 20).attr("y", 5)
      .attr("font-size",12).attr("fill","#e2e8f0")
      .text(`${d.data.type}${d.data.total ? ` (${d.data.total})` : ''}`)
      .style("font-weight",800)
      .each(function(){
        const t = d3.select(this);
        const txt = t.text();
        if (txt.length > 28) t.text(txt.slice(0,26) + '...');
      });
    if(d.data.recordId){
      g2.append("text").attr("x",0).attr("y",24)
        .attr("font-size",11).attr("text-anchor","middle").attr(" fluence","#94a3b8")
        .text(d.data.recordId);
    }
  });

  const ponNodesByName = {};
  treeRoot.descendants().filter(n => n.data && n.data.type === 'pon').forEach(n => { ponNodesByName[n.data.name] = n; });
  ponNodes.forEach(ponN => {
    const p = ponN.data;
    const pX = ponN.y, pY = ponN.x;
    const level0 = (p.levels && p.levels[0]) ? p.levels[0].level : null;
    if(level0 === null) return;
    const lvl1Positions = allSplitterPositions.filter(s => s.pon === p.name && s.level === level0);
    lvl1Positions.forEach(child => {
      g.append("path")
        .attr("d", pathBezier({x:pX,y:pY},{x:child.x,y:child.y}))
        .attr("stroke", ensureColorForOlt(p.meta.olt))
        .attr("stroke-width", 3)

        .attr("fill", "none")
        .attr("stroke-opacity", 0.95);
    });
  });

  ponNodes.forEach(ponN => {
    const p = ponN.data;
    const lv = p.levels || [];
    for(let li = 0; li < lv.length - 1; li++){
      const L1 = lv[li].level;
      const L2 = lv[li+1].level;
      const parents = allSplitterPositions.filter(s => s.pon === p.name && s.level === L1);
      const kids = allSplitterPositions.filter(s => s.pon === p.name && s.level === L2);
      const parentSets = parents.map(pr => new Set((pr.data.users || []).map(normalizeId)));
      kids.forEach(ch => {
        const chSet = new Set((ch.data.users || []).map(normalizeId));
        let linked = false;
        for(let pi=0; pi<parents.length; pi++){
          let hasCommon = false;
          for(const u of chSet){ if(parentSets[pi].has(u)){ hasCommon = true; break; } }
          if(hasCommon){
            const pr = parents[pi];
            g.append("path")
              .attr("d", pathBezier({x:pr.x,y:pr.y},{x:ch.x,y:ch.y}))
              .attr("stroke", ch.color)
              .attr("stroke-width", 3)
              .attr("fill", "none")
              .attr("stroke-opacity", 0.95);
            linked = true;
            break;
          }
        }
      });
    }
  });

  const zoom = d3.zoom().scaleExtent([0.25, 3]).on("zoom", ev => g.attr("transform", ev.transform));
  svg.call(zoom);

  try {
    const bb = g.node().getBBox();
    const sx = width/(bb.width + 120);
    const sy = height/(bb.height + 120);
    const s0 = Math.min(sx, sy, 1);
    const tx0 = -bb.x * s0 + 20;
    const ty0 = -bb.y * s0 + 20;
    svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(tx0,ty0).scale(s0));
  } catch(e) {}

  applySearchHighlight();
}

function pathBezier(src, dst){
  const sx = src.x, sy = src.y, tx = dst.x, ty = dst.y;
  const midX = sx + (tx - sx) * 0.5;
  return `M ${sx} ${sy} C ${midX} ${sy} ${midX} ${ty} ${tx} ${ty}`;
}
function countLeaves(node){
  if(!node || !node.children || node.children.length===0) return 1;
  return node.children.reduce((s,c)=> s + countLeaves(c), 0);
}
function findWindowForPon(pon){
  if(!rawJson) return '';
  for(const w of rawJson.windows||[]){
    for(const p of w.pons||[]){
      if(p.pon===pon) return w.window;
    }
  }
  return '';
}
function showTooltip(ev, d){
  tooltip.innerHTML = `<strong>${d.name || d.type || ''}</strong><br>Users: ${d.total || (d.users?d.users.length:0)}`;
  tooltip.style.left = (ev.pageX+12)+"px";
  tooltip.style.top = (ev.pageY+8)+"px";
  tooltip.style.opacity = 1;
}
function hideTooltip(){ tooltip.style.opacity = 0; }
function openPopup(sp, pon, win){
  popupModal.style.display = 'flex';
  popupTitle.textContent = `${sp.type || 'Splitter'} — Users`;
  popupPath.textContent = `${win||''} → ${pon||''} → ${sp.recordId||''}`;
  popupMeta.innerHTML = `<b>Total users:</b> ${sp.total || (sp.users?sp.users.length:0)}`;
  const users = Array.isArray(sp.users) ? sp.users : [];
  popupUsers.innerHTML =
    `<thead><tr><th>Sr</th><th>User</th></tr></thead><tbody>`+
    users.map((u,i)=>`<tr><td>${i+1}</td><td>${u}</td></tr>`).join('')+
    `</tbody>`;
}
function applySearchHighlight(){
  const term=(searchInput.value||'').trim().toLowerCase();
  const nodes = d3.selectAll("g.splitter");
  if(!term){
    nodes.selectAll("circle").attr("opacity",1).attr("stroke","#fff").attr("stroke-width",3);
    nodes.selectAll("text").attr("opacity",1).style("font-weight",800);
    return;
  }
  nodes.each(function(d){
    const users = d.data.users || [];
    const hit = users.some(u => String(u).toLowerCase().includes(term));
    const g = d3.select(this);
    if(hit){
      g.select("circle").attr("stroke","#ec4899").attr("stroke-width",5).attr("opacity",1);
      g.selectAll("text").attr("opacity",1).style("font-weight",900);
    } else {
      g.select("circle").attr("opacity",0.3);
      g.selectAll("text").attr("opacity",0.3);
    }
  });
}
function downloadCSV(){
  if(popupModal.style.display!=='flex') return;
  const rows=[...popupUsers.querySelectorAll("tr")];
  if(!rows.length) return;
  let csv='';
  rows.forEach(r=>{
    const cols=[...r.querySelectorAll("th,td")].map(c=>`"${(c.textContent||'').replace(/"/g,'""')}"`);
    csv += cols.join(",") + "\n";
  });
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'users.csv'; a.click(); URL.revokeObjectURL(url);
}
function downloadScreenshot(){
  const svg = document.querySelector("#chart svg");
  if(!svg) return alert("Nothing to save");
  const xml = (new XMLSerializer()).serializeToString(svg);
  const blob = new Blob([xml], {type:"image/svg+xml"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'merotra-tree.svg'; a.click(); URL.revokeObjectURL(url);
}

loadAndRender(false);
window.addEventListener('resize', ()=> rawJson && applyFiltersAndRender());
</script>
</body>
</html>
