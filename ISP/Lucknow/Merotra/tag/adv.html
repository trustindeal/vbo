<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merotra Network ‚Äî Hierarchical View</title>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- Your CSS -->
  <link rel="stylesheet" href="adv.css">

  <style>
    /* Extra small styling for the ROOT (rounded box) */
    .root-box {
      fill: #0ea5e9;
      stroke: white;
      stroke-width: 2;
      rx: 18;
      ry: 18;
    }
    .root-text {
      fill: white;
      font-size: 16px;
      font-weight: 700;
    }
  </style>
</head>
<body>

<div class="header">
  <div>
    <div class="header-title">üåê Merotra Network ‚Äî Column Layout</div>
    <div class="header-sub">Network ‚Üí Window ‚Üí OLT ‚Üí PON ‚Üí Levels</div>
  </div>
  <button id="reloadBtn" class="btn">Reload</button>
</div>

<div id="chart"></div>
<div id="tooltip" class="tooltip"></div>

<!-- Popup -->
<div id="popupModal" class="popup-backdrop">
  <div class="modal-content">
    <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px">
      <div>
        <h2 id="popupTitle" style="margin:0;font-size:16px"></h2>
        <div id="popupPath" style="font-size:12px;color:#475569"></div>
      </div>
      <button id="popupClose" class="btn btn-secondary" style="height:30px">Close</button>
    </div>
    <div id="popupMeta" style="font-size:13px;color:#334155;margin-bottom:8px"></div>
    <div style="max-height:400px;overflow:auto">
      <table id="popupUsersTable" class="user-table"></table>
    </div>

    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="btnShot" class="btn btn-shot">üì∏ Screenshot</button>
      <button id="btnCsv" class="btn btn-csv">üìä CSV</button>
    </div>
  </div>
</div>

<script>
/* =============== CONFIG =============== */
const BOARD_URL =
 "https://script.google.com/macros/s/AKfycbzItUueYIqcUuCn2cDaTTrWIF0LiilUxOXhhL-4b4D9aUlEo8Ov9pasR44d6JSM3h1t/exec?mode=board";

let rawJson = null;

/* UI */
document.getElementById("reloadBtn").onclick = () => loadAndRender(true);
document.getElementById("popupClose").onclick = () =>
  (document.getElementById("popupModal").style.display = "none");
document.getElementById("btnCsv").onclick = downloadCSV;
document.getElementById("btnShot").onclick = downloadScreenshot;

/* Helpers */
function randColor() {
  const h = Math.floor(Math.random()*360);
  return `hsl(${h} 65% 45%)`;
}
function normalizeId(v){ return (v ?? "").toString().trim(); }

/* Load JSON */
async function loadAndRender(showMsg = false) {
  try {
    const btn = document.getElementById("reloadBtn");
    btn.textContent = "Loading...";
    btn.disabled = true;

    const r = await fetch(BOARD_URL);
    rawJson = await r.json();

    render(rawJson);
    if(showMsg) console.log("Loaded.");
  } catch(err) {
    alert("Load failed: " + err);
  } finally {
    const btn = document.getElementById("reloadBtn");
    btn.textContent = "Reload";
    btn.disabled = false;
  }
}

/* ======== RENDER ======================================= */
function render(j) {
  const chart = document.getElementById("chart");
  chart.innerHTML = "";

  const svg = d3.select("#chart")
                .append("svg")
                .attr("width", "100%")
                .attr("height", "100%");

  const g = svg.append("g");

  const zoom = d3.zoom().scaleExtent([0.4, 2])
    .on("zoom", e => g.attr("transform", e.transform));

  svg.call(zoom);

  /* layout settings */
  const colW = 220;
  const nodeGapY = 60;
  const padX = 80;
  let curY = 80;

  /* ---- ROOT NODE ---- */
  const rootX = padX;
  const rootY = curY;

  g.append("rect")
    .attr("class","root-box")
    .attr("x", rootX - 70)
    .attr("y", rootY - 25)
    .attr("width", 200)
    .attr("height", 50);

  g.append("text")
    .attr("x", rootX + 30)
    .attr("y", rootY + 5)
    .attr("class","root-text")
    .text("Merotra Network");

  /* Window column = next column right */
  const winColX = rootX + colW;
  const oltColX = winColX + colW;
  const ponColX = oltColX + colW;

  /* Each window is a child of root */
  j.windows.forEach(win => {
    /* Window node */
    const wx = winColX;
    const wy = curY;

    g.append("circle")
      .attr("cx", wx)
      .attr("cy", wy)
      .attr("r", 18)
      .attr("fill", "#0ea5e9")
      .attr("stroke", "#fff")
      .attr("stroke-width", 2);

    g.append("text")
      .attr("x", wx + 26)
      .attr("y", wy + 4)
      .text(win.window)
      .attr("font-size", 13)
      .attr("fill", "#0f172a");

    /* Link root ‚Üí window */
    g.append("path")
      .attr("d",
        `M${rootX+100} ${rootY} C ${rootX+150} ${rootY}, ${wx-60} ${wy}, ${wx-20} ${wy}`)
      .attr("stroke", randColor())
      .attr("stroke-width", 2)
      .attr("fill", "none");

    /* For each PON, but now preceded with an OLT node */

    // Group PONs per OLT number
    const oltGroups = {}; // {olt: [pon,...]}
    win.pons.forEach(p=>{
      let oltNum = p.pon.slice(1,2); // EXTRACT OLT FROM "O4I5P4"
      if(!oltGroups[oltNum]) oltGroups[oltNum] = [];
      oltGroups[oltNum].push(p);
    });

    let winBlockHeight =
      Object.keys(oltGroups).reduce((sum,k)=> sum + (oltGroups[k].length * nodeGapY + 80), 0);

    let winStartY = wy - winBlockHeight/2;
    if(winStartY < curY) winStartY = curY; 

    Object.keys(oltGroups).forEach(oltNum => {
      const group = oltGroups[oltNum];

      /* OLT Node */
      const ox = oltColX;
      const oy = winStartY;

      g.append("circle")
        .attr("cx", ox)
        .attr("cy", oy)
        .attr("r", 16)
        .attr("fill", "#22c55e")
        .attr("stroke","#fff")
        .attr("stroke-width",2);

      g.append("text")
        .attr("x", ox + 22)
        .attr("y", oy + 4)
        .text("OLT-" + oltNum)
        .attr("font-size", 12)
        .attr("fill","#0f172a");

      /* Link window ‚Üí OLT */
      g.append("path")
        .attr("d",
          `M${wx+20} ${wy} C ${wx+70} ${wy}, ${ox-70} ${oy}, ${ox-20} ${oy}`)
        .attr("stroke", randColor())
        .attr("stroke-width", 2)
        .attr("fill","none");

      /* Render PON under this OLT */
      group.forEach(pon => {
        const px = ponColX;
        const py = winStartY;

        // Pon node
        g.append("circle")
          .attr("cx", px)
          .attr("cy", py)
          .attr("r", 14)
          .attr("fill","#0f766e")
          .attr("stroke","#fff")
          .attr("stroke-width",2);

        g.append("text")
          .attr("x", px + 22)
          .attr("y", py + 4)
          .text(pon.pon)
          .attr("font-size", 12)
          .attr("fill","#0f172a");

        /* Link OLT ‚Üí PON */
        g.append("path")
          .attr("d",
            `M${ox+20} ${oy} C ${ox+80} ${oy}, ${px-80} ${py}, ${px-20} ${py}`)
          .attr("stroke", randColor())
          .attr("stroke-width", 2)
          .attr("fill","none");

        /* Render levels horizontally (same as old layout) */
        drawLevels(g, px, py, pon);

        winStartY += nodeGapY + 40;
      }); // pon

      winStartY += 40;
    }); // olt groups

    curY += winBlockHeight + 160;
  });

  fitToView(svg.node(), g.node());
}

/* Draw splitter levels: SAME AS OLD WORKING VERSION */
function drawLevels(g, ponX, ponY, ponObj) {
  const colW = 220;
  const nodeGapY = 60;
  const r = 12;

  const levels = [...ponObj.levels].sort((a,b)=>a.level-b.level);
  const baseX = ponX + colW;  
  const baseY = ponY;

  let prevPositions = null;

  levels.forEach((lvl, idx)=>{
    const x = baseX + idx*colW;
    const sArr = lvl.splitters || [];

    const totalHeight = (sArr.length-1)*nodeGapY;
    let startY = baseY - totalHeight/2;

    const positions = [];

    sArr.forEach((s,i)=>{
      const y = startY + i*nodeGapY;
      positions.push({x,y,s});

      g.append("circle")
        .attr("cx",x).attr("cy",y)
        .attr("r",r)
        .attr("fill","#10b981")
        .attr("stroke","#fff")
        .attr("stroke-width",2)
        .style("cursor","pointer")
        .on("mousemove",ev=> showTooltip(ev,s))
        .on("mouseout",hideTooltip)
        .on("click",()=>openPopup(s, ponObj.pon, ""));
      
      g.append("text")
        .attr("x",x+r+8)
        .attr("y",y+4)
        .attr("font-size",11)
        .attr("fill","#0f172a")
        .text((s.type||"") + ` (${s.total})`);
    });

    if(idx===0){
      // connect PON ‚Üí Level1 (all)
      positions.forEach(p=>{
        g.append("path")
          .attr("d", linkPath({x:ponX,y:ponY}, {x:p.x,y:p.y}))
          .attr("stroke", randColor())
          .attr("stroke-width",2)
          .attr("fill","none");
      });
    } else {
      // connect to previous by "first common user"
      const parent = prevPositions;

      const parentSets = parent.map(p=> new Set((p.s.users||[]).map(normalizeId)));

      positions.forEach(child=>{
        const cSet = new Set((child.s.users||[]).map(normalizeId));
        for(let k=0;k<parent.length;k++){
          const pSet = parentSets[k];
          let common = false;
          for(const u of cSet){
            if(pSet.has(u)){ common = true; break; }
          }
          if(common){
            g.append("path")
              .attr("d", linkPath(
                {x:parent[k].x, y:parent[k].y},
                {x:child.x, y:child.y}
              ))
              .attr("stroke", randColor())
              .attr("stroke-width",2)
              .attr("fill","none");
            break;
          }
        }
      });
    }

    prevPositions = positions;
  });
}

/* link path */
function linkPath(a,b){
  const mx = a.x + (b.x-a.x)*0.5;
  return `M${a.x} ${a.y} C ${mx} ${a.y}, ${mx} ${b.y}, ${b.x} ${b.y}`;
}

/* Fit */
function fitToView(svgNode, gNode) {
  try {
    const b = gNode.getBBox();
    const W = svgNode.clientWidth;
    const H = svgNode.clientHeight;
    const scale = Math.min(1, Math.min(W/(b.width+200), H/(b.height+200)));
    const tx = -b.x*scale + 40;
    const ty = -b.y*scale + 40;
    d3.select(svgNode).call(
      d3.zoom().transform,
      d3.zoomIdentity.translate(tx,ty).scale(scale)
    );
  } catch(e){}
}

/* Tooltip / Popup (same as old) */
function showTooltip(ev,s){
  const t = document.getElementById("tooltip");
  t.style.left = ev.pageX+10+"px";
  t.style.top = ev.pageY+10+"px";
  t.style.opacity = 1;
  t.innerHTML =
    `<strong>${s.type}</strong><br>
     Record: ${s.recordId}<br>
     Users: ${s.total}`;
}
function hideTooltip(){
  document.getElementById("tooltip").style.opacity = 0;
}

function openPopup(s,pon){
  const m = document.getElementById("popupModal");
  document.getElementById("popupTitle").textContent =
    `${s.type} ‚Äî Users`;
  document.getElementById("popupPath").textContent = `${pon} ‚Üí ${s.recordId}`;
  const users = s.users || [];
  document.getElementById("popupMeta").innerHTML =
    `<strong>Total:</strong> ${users.length}`;
  const tbl = document.getElementById("popupUsersTable");
  tbl.innerHTML =
    `<thead><tr><th>Sr</th><th>User</th></tr></thead>`+
    `<tbody>`+
    users.map((u,i)=> `<tr><td>${i+1}</td><td>${u}</td></tr>`).join("")+
    `</tbody>`;
  m.style.display="flex";
}

function downloadCSV(){
  const tbl = document.getElementById("popupUsersTable");
  if(!tbl) return;
  let csv="";
  tbl.querySelectorAll("tr").forEach(r=>{
    const cols=[...r.children].map(c=> `"${c.textContent}"`);
    csv+=cols.join(",")+"\n";
  });
  const blob=new Blob([csv],{type:"text/csv"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download="splitter.csv";
  a.click();
}

function downloadScreenshot(){
  const svg=document.querySelector("#chart svg");
  const src=new XMLSerializer().serializeToString(svg);
  const blob=new Blob([src],{type:"image/svg+xml"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download="network.svg";
  a.click();
}

/* Init */
loadAndRender();
</script>

</body>
</html>
