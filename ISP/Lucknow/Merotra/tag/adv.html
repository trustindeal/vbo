<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merotra ‚Äî PON / Splitter Tree (Viewer)</title>

  <!-- d3 + tailwind + html2canvas -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#f8fafc; color:#0f172a; }
    .header { display:flex; justify-content:space-between; align-items:center; padding:12px 18px; background:#fff; box-shadow:0 1px 4px rgba(2,6,23,0.06); border-radius:6px; margin:12px; }
    .header-title { font-weight:700; font-size:16px; }
    .header-sub { font-size:12px; color:#475569; }
    .btn { background:#0f172a; color:#fff; padding:6px 10px; border-radius:6px; cursor:pointer; border:none; }
    .btn-secondary { background:#e6eef5; color:#0f172a; }
    #chart { height: calc(100vh - 220px); margin:12px; background:#fff; border-radius:8px; padding:10px; box-shadow:0 1px 4px rgba(2,6,23,0.06); overflow:hidden; }
    .tooltip { position:absolute; pointer-events:none; background:#111827; color:#fff; padding:8px 10px; border-radius:6px; font-size:12px; opacity:0; transition:opacity .08s; z-index:20; }
    .popup-backdrop { display:none; position:fixed; inset:0; background:rgba(2,6,23,0.4); align-items:center; justify-content:center; z-index:50; }
    .modal-content { background:#fff; border-radius:8px; padding:14px; width:min(820px,95%); max-height:80vh; overflow:auto; box-shadow:0 8px 30px rgba(2,6,23,0.15); }
    .user-table { width:100%; border-collapse:collapse; font-size:13px; }
    .user-table th, .user-table td { padding:6px 8px; border-bottom:1px solid #eef2f7; text-align:left; }
    .controls-backdrop { display:none; position:fixed; inset:0; background:rgba(2,6,23,0.4); align-items:center; justify-content:center; z-index:40; }
    .controls-modal { background:#fff; padding:16px; border-radius:8px; width:360px; box-shadow:0 8px 30px rgba(2,6,23,0.12); }
    .checkbox-grid { display:flex; flex-wrap:wrap; gap:8px; }
    .checkbox-item { font-size:13px; }
    .link-btn { display:inline-block; padding:4px 8px; background:#eef2ff; border-radius:6px; margin-right:6px; cursor:pointer; font-size:12px; }
  </style>
</head>
<body>

  <div class="header">
    <div>
      <div class="header-title">üåê Merotra Network Tree ‚Äî Viewer</div>
      <div class="header-sub">Visualizes tree exactly as server JSON provides. No client-side merging/processing.</div>
    </div>

    <div class="flex items-center gap-2">
      <button id="controlsBtn" class="btn btn-secondary">Filters</button>
      <button id="reloadBtn" class="btn">Reload</button>
    </div>
  </div>

  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <!-- POPUP -->
  <div id="popupModal" class="popup-backdrop">
    <div class="modal-content">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px;">
        <div>
          <h2 id="popupTitle" style="margin:0;font-weight:700;"></h2>
          <div id="popupPath" style="font-size:12px;color:#64748b;margin-top:6px;"></div>
        </div>
        <button id="popupClose" class="btn btn-secondary" style="height:32px;">Close</button>
      </div>

      <div id="popupMeta" style="font-size:13px;color:#334155;margin-bottom:8px;"></div>
      <div id="popupLinks" style="margin-bottom:8px;"></div>

      <h3 style="margin:8px 0;font-size:14px;">Users</h3>
      <div style="overflow:auto;max-height:42vh;">
        <table id="popupUsersTable" class="user-table"></table>
      </div>

      <div style="display:flex;gap:8px;margin-top:10px;">
        <button id="btnShot" class="btn">üì∏ Screenshot</button>
        <button id="btnCsv" class="btn btn-secondary">üìä CSV</button>
      </div>
    </div>
  </div>

  <!-- CONTROLS -->
  <div id="controlsModal" class="controls-backdrop">
    <div class="controls-modal">
      <h3 style="margin:0 0 8px 0;">Filters</h3>
      <div style="margin-bottom:10px;">
        <div style="font-weight:600;margin-bottom:6px;">Windows</div>
        <div id="windowFilters" class="checkbox-grid"></div>
      </div>

      <div style="margin-bottom:10px;">
        <div style="font-weight:600;margin-bottom:6px;">PONs</div>
        <div id="ponFilters" class="checkbox-grid"></div>
      </div>

      <button id="applyFiltersBtn" class="btn" style="width:100%;">Apply</button>
      <button id="controlsClose" class="btn btn-secondary" style="width:100%;margin-top:8px;">Close</button>
    </div>
  </div>

<script>
  // -------- CONFIG: set your published GAS board URL (mode=board) --------
  const BOARD_URL = "https://script.google.com/macros/s/AKfycbzItUueYIqcUuCn2cDaTTrWIF0LiilUxOXhhL-4b4D9aUlEo8Ov9pasR44d6JSM3h1t/exec?mode=board";

  // -------- UI refs --------
  const tooltip = document.getElementById('tooltip');
  const popupModal = document.getElementById('popupModal');
  const controlsModal = document.getElementById('controlsModal');
  const popupTitleEl = document.getElementById('popupTitle');
  const popupPathEl = document.getElementById('popupPath');
  const popupMetaEl = document.getElementById('popupMeta');
  const popupLinksEl = document.getElementById('popupLinks');
  const popupUsersTbl = document.getElementById('popupUsersTable');

  const reloadBtn = document.getElementById('reloadBtn');
  const controlsBtn = document.getElementById('controlsBtn');
  const controlsClose = document.getElementById('controlsClose');
  const applyFiltersBtn = document.getElementById('applyFiltersBtn');
  const windowFiltersDiv = document.getElementById('windowFilters');
  const ponFiltersDiv = document.getElementById('ponFilters');

  const btnShot = document.getElementById('btnShot');
  const btnCsv = document.getElementById('btnCsv');
  const popupClose = document.getElementById('popupClose');

  // -------- state --------
  let serverJson = null;
  let board = {}; // internal: board[pon][window][splitName] = info
  let filters = { windows: [], pons: [] };
  let currentTreeData = null;
  let currentPopupRows = [];

  // -------- helpers --------
  function safeGet(obj, path, fallback) {
    try { return path.split('.').reduce((o,k)=>o && o[k], obj) ?? fallback; } catch(e) { return fallback; }
  }
  function normalizeId(v){ return (v==null) ? "" : String(v).trim(); }

  // Transform server JSON ‚Üí board object exactly (NO processing)
  function transformServerToBoard(srv) {
    const b = {};
    if (!srv || !Array.isArray(srv.windows)) return b;

    srv.windows.forEach(win => {
      const winName = win.window;
      (win.pons || []).forEach(pon => {
        const ponName = pon.pon;
        if (!b[ponName]) b[ponName] = {};
        if (!b[ponName][winName]) b[ponName][winName] = {};
        (pon.splitters || []).forEach(split => {
          // Ensure users are array of objects { id } OR array of ids -> normalize to { id: <val> }
          const usersArr = (split.users || []).map(u => {
            if (typeof u === 'object' && u !== null) return { id: u.id ?? (u.user ?? "") };
            return { id: String(u) };
          });
          // Use split.name as key if available, else build one
          const key = split.name || `${split.splitterName || "split"} ‚Äî ${split.jcName || ""}`;
          b[ponName][winName][key] = {
            // keep everything server sent (no recompute)
            ...split,
            name: key,
            users: usersArr
          };
        });
      });
    });

    return b;
  }

  // Build a minimal tree object expected by d3 from `board` (no logic)
  // Structure: root -> window nodes -> pon nodes -> splitter nodes (may have children already)
  function buildTreeFromBoard(boardObj) {
    const root = { nodeType: 'root', name: 'üåê Merotra Network', children: [] };

    // Collect windows set so we can sort alphabetically
    const windowsSet = new Set();
    Object.entries(boardObj).forEach(([pon, winObj]) => {
      Object.keys(winObj || {}).forEach(w => windowsSet.add(w));
    });
    // Create window nodes in alphabetical order
    const winNames = Array.from(windowsSet).sort((a,b)=> a.localeCompare(b, undefined, {sensitivity:'base'}));
    const windowMap = {};
    winNames.forEach(w => {
      windowMap[w] = { nodeType: 'window', name: `ü™ü ${w}`, rawWindow: w, children: [] };
      root.children.push(windowMap[w]);
    });

    // Now iterate pons sorted (simple lexicographic with PON parser fallback)
    function parsePon(pon){ const m = String(pon||"").match(/O(\d+)I(\d+)P(\d+)/i); if(!m) return {olt:9999,ip:9999,port:9999}; return {olt:+m[1], ip:+m[2], port:+m[3]}; }
    const ponEntries = Object.entries(boardObj).sort((a,b)=>{
      const pa = parsePon(a[0]), pb = parsePon(b[0]);
      if (pa.olt !== pb.olt) return pa.olt - pb.olt;
      if (pa.ip !== pb.ip) return pa.ip - pb.ip;
      return pa.port - pb.port;
    });

    ponEntries.forEach(([ponName, winObj]) => {
      Object.entries(winObj || {}).forEach(([winName, splits]) => {
        const winNode = windowMap[winName];
        if (!winNode) return; // filtered out
        const ponNode = { nodeType: 'pon', name: `üîå ${ponName}`, rawPon: ponName, window: winName, children: [], total: null };
        // For each splitter (already may contain children array) create node object pass-through
        Object.entries(splits || {}).forEach(([splitName, info]) => {
          // info may already contain children recursively; keep as-is but normalize fields used for display
          const node = {
            nodeType: (info.nodeType || 'splitter'),
            name: info.name || splitName,
            splitterName: info.splitterName || info.rawSplitter || splitName,
            jcName: info.jcName || '',
            location: info.location || '',
            jcPic: info.jcPic || info.jcImage || '',
            polePic: info.polePic || info.poleImage || '',
            tag: info.tag || '',
            users: Array.isArray(info.users) ? info.users.slice() : [],
            total: (typeof info.total === 'number' ? info.total : (Array.isArray(info.users) ? info.users.length : null)),
            children: Array.isArray(info.children) ? info.children.map(c => c) : []
          };
          ponNode.children.push(node);
        });
        winNode.children.push(ponNode);
      });
    });

    return root;
  }

  // ---------- DRAW TREE (D3) ----------
  let svg, g, zoom;
  function drawTree(data) {
    // clear
    d3.select('#chart').selectAll('*').remove();

    const width = document.getElementById('chart').clientWidth || Math.max(window.innerWidth - 40, 900);
    const height = Math.max(window.innerHeight - 220, 420);

    const dx = 80;
    const dy = width > 900 ? 260 : 200;

    const tree = d3.tree().nodeSize([dx, dy]);
    const root = d3.hierarchy(data, d => d.children || []);
    tree(root);

    svg = d3.select('#chart').append('svg').attr('width', width).attr('height', height).style('overflow','visible');

    zoom = d3.zoom().scaleExtent([0.4, 3]).on('zoom', (ev) => g.attr('transform', ev.transform));
    svg.call(zoom);

    g = svg.append('g').attr('transform','translate(80,40)');

    // links
    g.selectAll('.link')
      .data(root.links())
      .enter()
      .append('path')
      .attr('class','link')
      .attr('d', d3.linkHorizontal().x(d => d.y).y(d => d.x))
      .attr('fill','none')
      .attr('stroke','#94a3b8')
      .attr('stroke-width',2);

    // nodes
    const node = g.selectAll('.node').data(root.descendants()).enter().append('g')
      .attr('class','node')
      .attr('transform', d => `translate(${d.y},${d.x})`)
      .style('cursor','pointer');

    // circles
    node.append('circle')
      .attr('r', d => {
        if (d.data.nodeType === 'root') return 24;
        if (d.data.nodeType === 'window') return 20;
        if (d.data.nodeType === 'pon') return 18;
        if (d.data.nodeType === 'untagged') return 10;
        return 14;
      })
      .attr('fill', d => {
        if (d.data.nodeType === 'root') return '#1e3a8a';
        if (d.data.nodeType === 'window') return '#1d4ed8';
        if (d.data.nodeType === 'pon') return '#0f766e';
        if (d.data.nodeType === 'untagged') return '#6b7280';
        // for splitter color, use presence of total/users
        const tot = d.data.total ?? (Array.isArray(d.data.users) ? d.data.users.length : 0);
        return tot > 0 ? '#10b981' : '#6b7280';
      })
      .attr('stroke','#fff').attr('stroke-width',2);

    // labels
    node.append('text')
      .attr('dy','0.32em')
      .attr('x', d => d.children && d.depth > 0 ? -20 : 20)
      .attr('text-anchor', d => d.children && d.depth > 0 ? 'end' : 'start')
      .style('font-size', d => {
        if (d.data.nodeType === 'root') return '14px';
        if (d.data.nodeType === 'window') return '13px';
        if (d.data.nodeType === 'pon') return '12px';
        return '11px';
      })
      .style('font-weight', d => (d.data.nodeType === 'root' || d.data.nodeType === 'window') ? 700 : 500)
      .text(d => {
        // prefer a stable label: use data.name if present, otherwise fallback to splitterName/raw
        return d.data.name || d.data.splitterName || (d.data.pon ? d.data.pon : '');
      });

    // interactions
    node.on('mousemove', (event, d) => {
      handleMouseOver(event, d);
    }).on('mouseout', () => {
      tooltip.style.opacity = 0;
    }).on('click', (event, d) => {
      handleNodeClick(event, d);
    });

    fitToView(svg, g, zoom);
  }

  function fitToView(svgRoot, g, zoom) {
    try {
      const chart = document.getElementById('chart');
      const bounds = g.node().getBBox();
      const fullWidth = chart.clientWidth;
      const fullHeight = chart.clientHeight;
      const widthScale = fullWidth / (bounds.width + 160);
      const heightScale = fullHeight / (bounds.height + 160);
      const scale = Math.min(2, Math.max(0.4, Math.min(widthScale, heightScale)));
      const tx = -bounds.x * scale + 40;
      const ty = -bounds.y * scale + 40;
      svgRoot.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(scale));
    } catch(e) { /* ignore fit errors */ }
  }

  // tooltip content - no server-side logic here, just show available metadata
  function handleMouseOver(event, d) {
    const data = d.data;
    let html = `<strong>${data.name || data.splitterName || ''}</strong><br/>`;
    if (data.nodeType === 'window') html += `Window`;
    else if (data.nodeType === 'pon') html += `PON: ${data.rawPon || ''}<br/>`;
    else {
      // splitter or untagged
      const total = (typeof data.total === 'number') ? data.total : (Array.isArray(data.users) ? data.users.length : '-');
      html += `Users: <strong>${total}</strong><br/>`;
      if (data.tag) html += `Tag: ${data.tag}<br/>`;
      if (data.jcName) html += `JC: ${data.jcName}<br/>`;
    }
    tooltip.innerHTML = html;
    tooltip.style.left = (event.pageX + 14) + 'px';
    tooltip.style.top  = (event.pageY + 8) + 'px';
    tooltip.style.opacity = 1;
  }

  // popup builds user table showing raw IDs (no external lookups)
  function handleNodeClick(event, d) {
    const data = d.data;
    // only show popup for splitter or untagged nodes
    if (!(data.nodeType === 'splitter' || data.nodeType === 'untagged' || (Array.isArray(data.users) && data.users.length))) return;

    const total = (typeof data.total === 'number') ? data.total : (Array.isArray(data.users) ? data.users.length : 0);

    popupTitleEl.textContent = (data.nodeType === 'untagged') ? `‚¨ú Untagged users (${total})` : `${data.splitterName || data.name || 'Splitter'} ‚Äî Users`;
    popupPathEl.textContent = `${data.window || ''} ‚Üí ${data.pon || data.rawPon || ''} ‚Üí ${data.splitterName || data.name || ''}`;

    popupMetaEl.innerHTML = `<div><strong>Total users:</strong> ${total}</div><div><strong>Tag:</strong> ${data.tag || '-'}</div>`;

    // links
    let linksHtml = '';
    if (data.location) linksHtml += `<span class="link-btn" onclick="openLink('${data.location}')">üìç Location</span>`;
    if (data.jcPic) linksHtml += `<span class="link-btn" onclick="openLink('${data.jcPic}')">üì∏ JC Pic</span>`;
    if (data.polePic) linksHtml += `<span class="link-btn" onclick="openLink('${data.polePic}')">ü™µ Pole Pic</span>`;
    popupLinksEl.innerHTML = linksHtml || '';

    buildUserTable(data);
    popupModal.style.display = 'flex';
  }

  function buildUserTable(data) {
    // data.users expected array of {id} or strings -> normalize to raw ids
    const rawUsers = (data.users || []).map(u => (typeof u === 'object' && u !== null) ? (u.id ?? String(u)) : String(u));
    currentPopupRows = rawUsers.map((id, idx) => ({ sr: idx+1, id }));

    // render table
    popupUsersTbl.innerHTML = `
      <thead>
        <tr><th style="width:36px">Sr</th><th>User ID</th></tr>
      </thead>
      <tbody></tbody>
    `;
    const tbody = popupUsersTbl.querySelector('tbody');
    currentPopupRows.forEach(r => {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${r.sr}</td><td>${r.id}</td>`;
      tbody.appendChild(tr);
    });
  }

  // open link helper
  function openLink(url) { if (url) window.open(url, '_blank'); }

  // downloads
  function downloadScreenshot() {
    const modalContent = document.querySelector("#popupModal .modal-content");
    if (!modalContent) return;
    html2canvas(modalContent).then(canvas => {
      const link = document.createElement('a');
      link.download = `merotra-users-${new Date().toISOString().slice(0,10)}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    });
  }

  function downloadCSV() {
    if (!currentPopupRows || !currentPopupRows.length) return;
    const header = ['Sr','User ID'];
    const lines = [header.join(',')];
    currentPopupRows.forEach(r => {
      lines.push([r.sr, `"${(r.id||'').replace(/"/g,'""')}"`].join(','));
    });
    const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `merotra-users-${new Date().toISOString().slice(0,10)}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  // -------- Filters UI setup (from board) --------
  function setupFiltersFromBoard() {
    const windowSet = new Set();
    const ponSet = new Set();
    Object.entries(board).forEach(([pon, winObj]) => {
      ponSet.add(pon);
      Object.keys(winObj || {}).forEach(w => windowSet.add(w));
    });

    // defaults = all selected
    filters.windows = Array.from(windowSet);
    filters.pons = Array.from(ponSet);

    windowFiltersDiv.innerHTML = '';
    ponFiltersDiv.innerHTML = '';

    Array.from(windowSet).sort().forEach(w => {
      const el = document.createElement('label');
      el.className = 'checkbox-item';
      el.innerHTML = `<input type="checkbox" value="${w}" checked /> <span>${w}</span>`;
      windowFiltersDiv.appendChild(el);
    });

    Array.from(ponSet).sort((a,b) => {
      // try PON parse sort similar to server
      const pa = a.match(/O(\d+)I(\d+)P(\d+)/i), pb = b.match(/O(\d+)I(\d+)P(\d+)/i);
      if (pa && pb) {
        const A = [+pa[1],+pa[2],+pa[3]], B = [+pb[1],+pb[2],+pb[3]];
        for (let i=0;i<3;i++) if (A[i] !== B[i]) return A[i]-B[i];
        return 0;
      }
      return a.localeCompare(b);
    }).forEach(p => {
      const el = document.createElement('label');
      el.className = 'checkbox-item';
      el.innerHTML = `<input type="checkbox" value="${p}" checked /> <span>${p}</span>`;
      ponFiltersDiv.appendChild(el);
    });
  }

  // apply filter settings
  function applyFiltersFromUI() {
    const winChecked = Array.from(windowFiltersDiv.querySelectorAll('input[type=checkbox]:checked')).map(i => i.value);
    const ponChecked = Array.from(ponFiltersDiv.querySelectorAll('input[type=checkbox]:checked')).map(i => i.value);
    filters.windows = winChecked;
    filters.pons = ponChecked;
    controlsModal.style.display = 'none';
    renderFromBoard();
  }

  // filter board according to selected filters (no processing)
  function filterBoard(boardObj, filtersObj) {
    const out = {};
    Object.entries(boardObj).forEach(([pon, winObj]) => {
      if (!filtersObj.pons.includes(pon)) return;
      const newWin = {};
      Object.entries(winObj || {}).forEach(([win, splits]) => {
        if (!filtersObj.windows.includes(win)) return;
        newWin[win] = splits;
      });
      if (Object.keys(newWin).length) out[pon] = newWin;
    });
    return out;
  }

  // Render process: transform -> build tree -> draw
  function renderFromBoard() {
    const filtered = filterBoard(board, filters);
    const treeData = buildTreeFromBoard(filtered);
    currentTreeData = treeData;
    drawTree(treeData);
  }

  // -------- Load from server --------
  async function loadAll() {
    try {
      reloadBtn.textContent = 'Loading...'; reloadBtn.disabled = true;
      const res = await fetch(BOARD_URL);
      if (!res.ok) throw new Error('Board API fetch failed: ' + res.status);
      serverJson = await res.json();
      board = transformServerToBoard(serverJson);
      setupFiltersFromBoard();
      renderFromBoard();
      // optional console summary
      console.info('Server summary:', serverJson.summary || {});
    } catch (err) {
      console.error(err);
      alert('Error loading board: ' + (err.message || err));
    } finally {
      reloadBtn.textContent = 'Reload'; reloadBtn.disabled = false;
    }
  }

  // -------- Listeners --------
  reloadBtn.addEventListener('click', loadAll);
  controlsBtn.addEventListener('click', () => controlsModal.style.display = 'flex');
  controlsClose.addEventListener('click', () => controlsModal.style.display = 'none');
  applyFiltersBtn.addEventListener('click', applyFiltersFromUI);
  popupClose.addEventListener('click', () => popupModal.style.display = 'none');
  btnShot.addEventListener('click', downloadScreenshot);
  btnCsv.addEventListener('click', downloadCSV);

  window.addEventListener('resize', () => { if (currentTreeData) drawTree(currentTreeData); });

  // initial load
  loadAll();
</script>

</body>
</html>
