<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merotra ‚Äî Fiber Network Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    :root{
      --bg: #0f172a;
      --card: #1e293b;
      --text: #e2e8f0;
      --text-muted: #94a3b8;
      --primary: #60a5fa;
      --accent: #a78bfa;
      --success: #10b981;
      --danger: #ef4444;
      --border: rgba(148,163,184,0.2);
      --shadow: rgba(0,0,0,0.6);
    }
    [data-theme="light"]{
      --bg: linear-gradient(135deg, #f8fafc, #e2e8f0);
      --card: #ffffff;
      --text: #0f172a;
      --text-muted: #64748b;
      --primary: #3b82f6;
      --accent: #8b5cf6;
      --border: rgba(0,0,0,0.1);
      --shadow: rgba(0,0,0,0.12);
    }

    *{box-sizing:border-box;margin:0;padding:0}
    body{
      font-family:'Inter',system-ui,sans-serif;
      background:var(--bg);
      color:var(--text);
      height:100vh;
      overflow:hidden;
      transition:all 0.4s ease;
    }
    #chart{width:100%;height:calc(100vh - 76px);overflow:hidden;position:relative}

    /* Header */
    .header{
      background:var(--card);
      backdrop-filter:blur(16px);
      border-bottom:1px solid var(--border);
      padding:16px 20px;
      display:flex;justify-content:space-between;align-items:center;
      position:sticky;top:0;z-index:50;
      box-shadow:0 10px 30px var(--shadow);
    }
    .header-title{
      font-size:1.5rem;font-weight:900;
      background:linear-gradient(90deg,var(--primary),var(--accent),#ec4899);
      -webkit-background-clip:text;background-clip:text;
      color:transparent;
      letter-spacing:-1px;
    }

    .toolbar{display:flex;gap:14px;align-items:center;flex-wrap:wrap}
    .btn{
      background:var(--card);color:var(--text);padding:11px 18px;
      border-radius:16px;border:none;font-weight:700;font-size:0.95rem;
      cursor:pointer;transition:all .3s ease;box-shadow:0 6px 20px var(--shadow);
    }
    .btn:hover{transform:translateY(-3px);box-shadow:0 12px 30px var(--shadow)}
    #themeToggle{background:transparent;border:2px solid var(--primary);padding:8px 12px}
    #filterBtn{background:var(--accent)}
    #searchFold{background:#ec4899;color:white;border-radius:50%;width:52px;height:52px;font-size:1.6rem}
    #refreshBtn{background:var(--primary)}

    /* Search */
    #searchInput{
      width:280px;padding:14px 18px;border-radius:20px;background:var(--card);
      border:2px solid transparent;color:var(--text);font-size:1rem;
      transition:all .45s cubic-bezier(0.68,-0.55,0.265,1.55);
      transform:scaleX(0);opacity:0;transform-origin:right;
    }
    #searchInput.expanded{transform:scaleX(1);opacity:1;border-color:#ec4899}

    /* Filter Modal */
    #filterModal{
      position:fixed;inset:0;background:rgba(0,0,0,0.85);display:none;
      align-items:center;justify-content:center;z-index:100;backdrop-filter:blur(12px);
    }
    .filter-panel{
      background:var(--card);border-radius:24px;padding:28px;width:92%;max-width:500px;
      max-height:90vh;overflow-y:auto;box-shadow:0 30px 80px var(--shadow);
      border:1px solid var(--border);
    }
    .filter-title{color:var(--primary);font-size:1.5rem;font-weight:800;text-align:center;margin-bottom:20px}
    .filter-section{margin-bottom:24px}
    .filter-section h3{color:var(--text);margin-bottom:12px;font-size:1.1rem}
    .checkbox-group{
      display:flex;flex-direction:column;gap:10px;max-height:300px;overflow-y:auto;
      padding:8px;border-radius:12px;background:rgba(0,0,0,0.05);
    }
    .checkbox-item{
      display:flex;align-items:center;gap:10px;padding:8px 12px;border-radius:10px;
      cursor:pointer;transition:background .2s;
    }
    .checkbox-item:hover{background:rgba(var(--primary),0.1)}
    .checkbox-item input[type="checkbox"]{
      width:18px;height:18px;accent-color:var(--primary);cursor:pointer;
    }
    .filter-actions{display:flex;gap:16px;margin-top:20px}
    .filter-actions button{flex:1;padding:14px;border-radius:16px;font-weight:700;font-size:1rem}

    /* Tooltip & Popup */
    .tooltip{position:absolute;pointer-events:none;background:var(--card);padding:8px 12px;border-radius:12px;box-shadow:0 8px 24px var(--shadow);opacity:0;transition:opacity 0.2s;font-size:0.9rem;z-index:100}
    .popup-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:60;backdrop-filter:blur(8px)}
    .modal-content{background:var(--card);border-radius:20px;padding:20px;max-width:520px;width:92%;max-height:85vh;overflow-y:auto;box-shadow:0 20px 50px var(--shadow);border:1px solid var(--border)}
    .user-table{width:100%;border-collapse:collapse;font-size:0.78rem}
    .user-table th,.user-table td{padding:6px 8px;border-bottom:1px solid var(--border);text-align:left}
    .user-table thead{background:var(--card);position:sticky;top:0}

    /* Tree Professional 3D */
    .hnode{filter:drop-shadow(0 10px 30px var(--shadow))}
    .hnode circle{stroke:#fff;stroke-width:4;transform:scale(1.1)}
    .hnode text{filter:drop-shadow(0 3px 8px var(--shadow));font-weight:800}
    .link{stroke-width:4;stroke-linecap:round;opacity:0;animation:drawLine 2.2s forwards ease-out;stroke-dasharray:1000;stroke-dashoffset:1000}
    .hwlink{stroke:var(--text-muted)}
    .splitter{filter:drop-shadow(0 8px 24px var(--shadow))}
    .splitter circle{stroke:#fff;stroke-width:4}
    .splitter text{fill:var(--text);font-weight:800}

    /* Controls */
    .rotate-btn, #themeToggle{
      position:fixed;bottom:24px;z-index:90;
      width:64px;height:64px;border-radius:50%;display:flex;align-items:center;justify-content:center;
      font-size:2rem;box-shadow:0 12px 32px var(--shadow);cursor:pointer;border:none;
    }
    .rotate-btn{right:24px;background:#7c3aed;color:white;animation:float 5s ease-in-out infinite}
    #themeToggle{right:100px;background:var(--card);color:var(--primary);border:3px solid var(--primary)}

    @keyframes drawLine{to{stroke-dashoffset:0;opacity:0.9}}
    @keyframes float{0%,100%{transform:translateY(0)}50%{transform:translateY(-12px)}}

    @media(max-width:768px){
      .header-title{font-size:1.25rem}
      #searchInput{width:200px}
      .rotate-btn,#themeToggle{width:56px;height:56px;font-size:1.8rem;bottom:18px}
      #themeToggle{right:84px}
      .btn{padding:10px 14px;font-size:0.9rem}
    }
  </style>
</head>
<body data-theme="dark">

  <div class="header">
    <div class="header-title">Auto populated fiber network</div>
    <div class="toolbar">
      <button id="filterBtn" class="btn">Filters</button>
      <button id="searchFold" class="btn">üîç</button>
      <input id="searchInput" placeholder="Search user / splitter..." />
      <button id="refreshBtn" class="btn">Refresh</button>
    </div>
  </div>

  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <div id="themeToggle" title="Toggle Theme">üåô</div>
  <div id="rotateBtn" class="rotate-btn" title="Rotate 90¬∞">‚Üª</div>

  <!-- Filter Modal -->
  <div id="filterModal">
    <div class="filter-panel">
      <div class="filter-title">Network Filters</div>
      <div class="filter-section">
        <h3>Windows</h3>
        <div class="checkbox-group" id="windowCheckboxes"></div>
      </div>
      <div class="filter-section">
        <h3>OLT</h3>
        <div class="checkbox-group" id="oltCheckboxes"></div>
      </div>
      <div class="filter-section">
        <h3>PON</h3>
        <div class="checkbox-group" id="ponCheckboxes"></div>
      </div>
      <div class="filter-actions">
        <button id="selectAll" class="btn" style="background:var(--success)">Select All</button>
        <button id="clearAll" class="btn" style="background:var(--danger)">Clear All</button>
        <button id="applyFilters" class="btn" style="background:var(--primary)">Apply</button>
      </div>
    </div>
  </div>

  <!-- Popup Modal -->
  <div id="popupModal" class="popup-backdrop" style="display:none">
    <div class="modal-content">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:12px">
        <div>
          <h2 id="popupTitle" style="margin:0;font-size:1.1rem;color:var(--text)"></h2>
          <div id="popupPath" style="font-size:0.85rem;color:var(--text-muted)"></div>
        </div>
        <button id="popupClose" class="btn" style="padding:8px 12px;font-size:0.9rem">Close</button>
      </div>
      <div id="popupMeta" style="font-size:0.9rem;color:var(--text-muted);margin-bottom:12px"></div>
      <div style="max-height:60vh;overflow:auto">
        <table id="popupUsersTable" class="user-table"></table>
      </div>
      <div style="display:flex;gap:12px;margin-top:12px">
        <button id="btnShot" class="btn" style="background:var(--success)">Screenshot</button>
        <button id="btnCsv" class="btn" style="background:var(--accent)">CSV</button>
      </div>
    </div>
  </div>

<script>
// Design Enhancements
document.getElementById('themeToggle').onclick = () => {
  const body = document.body;
  body.setAttribute('data-theme', body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark');
};

document.getElementById('searchFold').onclick = () => {
  const input = document.getElementById('searchInput');
  input.classList.toggle('expanded');
  if (input.classList.contains('expanded')) {
    input.focus();
  } else {
    input.value = '';
    applyFiltersAndRender();
  }
};

let rotation = 0;
document.getElementById('rotateBtn').onclick = () => {
  rotation = (rotation + 90) % 360;
  document.getElementById('chart').style.transform = `rotate(${rotation}deg)`;
  document.getElementById('chart').style.transition = 'transform 0.6s ease-in-out';
};

// Filter Logic
let allWindows = [], allOlts = [], allPons = [];
document.getElementById('filterBtn').onclick = () => {
  document.getElementById('filterModal').style.display = 'flex';
  if (rawJson) populateFilterCheckboxes();
};
document.getElementById('selectAll').onclick = () => document.querySelectorAll('#filterModal input[type="checkbox"]').forEach(cb => cb.checked = true);
document.getElementById('clearAll').onclick = () => document.querySelectorAll('#filterModal input[type="checkbox"]').forEach(cb => cb.checked = false);
document.getElementById('applyFilters').onclick = () => {
  applyFiltersAndRender();
  document.getElementById('filterModal').style.display = 'none';
};
function populateFilterCheckboxes() {
  const winSet = new Set(), oltSet = new Set(), ponSet = new Set();
  (rawJson.windows || []).forEach(w => {
    winSet.add(w.window || '');
    (w.pons || []).forEach(p => {
      ponSet.add(p.pon || '');
      oltSet.add(getOltNumberFromPon(p.pon || ''));
    });
  });
  allWindows = Array.from(winSet).sort();
  allOlts = Array.from(oltSet).sort((a, b) => +a - +b);
  allPons = Array.from(ponSet).sort();
  ['window', 'olt', 'pon'].forEach(type => {
    const items = type === 'window' ? allWindows : type === 'olt' ? allOlts : allPons;
    const container = document.getElementById(`${type}Checkboxes`);
    container.innerHTML = items.map(item => `
      <label class="checkbox-item">
        <input type="checkbox" value="${item}" checked>
        <span>${item}</span>
      </label>
    `).join('');
  });
}

document.getElementById('refreshBtn').onclick = () => loadAndRender(true);
document.getElementById('searchInput').addEventListener('input', () => applyFiltersAndRender());
document.getElementById('popupClose').onclick = () => document.getElementById('popupModal').style.display = 'none';
document.getElementById('btnShot').onclick = downloadScreenshot;
document.getElementById('btnCsv').onclick = downloadCSV;
document.getElementById('filterModal').onclick = (e) => { if (e.target.id === 'filterModal') e.target.style.display = 'none'; };

// Core Logic (Full Original + Adaptations)
const BOARD_URL = "https://script.google.com/macros/s/AKfycbzItUueYIqcUuCn2cDaTTrWIF0LiilUxOXhhL-4b4D9aUlEo8Ov9pasR44d6JSM3h1t/exec?mode=board";
let rawJson = null;
let colorByOlt = new Map();
const tooltip = document.getElementById('tooltip');
const searchInput = document.getElementById('searchInput');
const popupModal = document.getElementById('popupModal');
const popupTitle = document.getElementById('popupTitle');
const popupPath = document.getElementById('popupPath');
const popupMeta = document.getElementById('popupMeta');
const popupUsersTable = document.getElementById('popupUsersTable');

function normalizeId(v) { return (v ?? "").toString().trim(); }
function getOltNumberFromPon(pon) {
  const m = (pon || "").match(/O(\d+)/i);
  return m ? m[1] : "0";
}
function parsePonKey(pon) {
  const m = (pon || "").match(/O(\d+)I(\d+)P(\d+)/i);
  if (!m) return { olt: 9999, ip: 9999, port: 9999 };
  return { olt: +m[1], ip: +m[2], port: +m[3] };
}
function ensureColorForOlt(olt) {
  if (!colorByOlt.has(String(olt))) {
    const idx = colorByOlt.size;
    const h = (idx * 137.508) % 360;
    colorByOlt.set(String(olt), `hsl(${h}, 70%, 55%)`);
  }
  return colorByOlt.get(String(olt));
}

async function loadAndRender(showToast = false) {
  try {
    setLoading(true);
    const res = await fetch(BOARD_URL);
    if (!res.ok) throw new Error("HTTP " + res.status);
    const j = await res.json();
    rawJson = j;
    colorByOlt = new Map();
    populateFilterCheckboxes();
    applyFiltersAndRender();
    if (showToast) console.info('Board loaded', j.summary || {});
  } catch (err) {
    console.error(err);
    alert("Load error: " + err.message);
  } finally {
    setLoading(false);
  }
}
function setLoading(flag) {
  const btn = document.getElementById('refreshBtn');
  btn.disabled = flag;
  btn.textContent = flag ? "Loading..." : "Refresh";
}

function applyFiltersAndRender() {
  if (!rawJson) return;
  const filtered = applyClientFilters(rawJson);
  const root = transformToHierarchy(filtered);
  renderBalancedTree(root);
}

function applyClientFilters(j) {
  const selectedWindows = Array.from(document.querySelectorAll('#windowCheckboxes input:checked')).map(cb => cb.value);
  const selectedOlts = Array.from(document.querySelectorAll('#oltCheckboxes input:checked')).map(cb => cb.value);
  const selectedPons = Array.from(document.querySelectorAll('#ponCheckboxes input:checked')).map(cb => cb.value);
  const term = (searchInput.value || '').trim().toLowerCase();
  const out = { windows: [] };
  (j.windows || []).forEach(win => {
    if (selectedWindows.length && !selectedWindows.includes(win.window)) return;
    const newWin = { window: win.window, pons: [] };
    (win.pons || []).forEach(p => {
      if (selectedPons.length && !selectedPons.includes(p.pon)) return;
      if (selectedOlts.length && !selectedOlts.includes(getOltNumberFromPon(p.pon))) return;
      const newLv = (p.levels || []).filter(l => Array.isArray(l.splitters) && l.splitters.length > 0);
      if (newLv.length === 0 && term) {
        if (!deepSearchMatch(p, term)) return;
      }
      newWin.pons.push({ ...p, levels: newLv });
    });
    if (newWin.pons.length > 0 || !selectedWindows.length) out.windows.push(newWin);
  });
  return out;
}

function deepSearchMatch(p, term) {
  if (!term) return false;
  for (const lvl of (p.levels || [])) {
    for (const sp of (lvl.splitters || [])) {
      for (const u of (sp.users || [])) {
        if (String(u).toLowerCase().includes(term)) return true;
      }
    }
  }
  return false;
}

function transformToHierarchy(j) {
  const root = { name: 'Merotra Network', type: 'network', children: [] };
  (j.windows || []).forEach(win => {
    const winNode = { name: win.window, type: 'window', children: [] };
    const oltMap = {};
    (win.pons || []).forEach(p => {
      const meta = parsePonKey(p.pon);
      const levels = (p.levels || []).map(l => ({
        level: l.level,
        splitters: (l.splitters || []).map(sp => ({
          recordId: sp.recordId || '',
          type: sp.type || '',
          users: (sp.users || []).map(x => String(x)),
          total: sp.total || ((sp.users || []).length || 0)
        }))
      }));
      const ponNode = { name: p.pon, type: 'pon', meta, levels };
      const oltNum = String(meta.olt);
      if (!oltMap[oltNum]) {
        oltMap[oltNum] = { name: "OLT-" + oltNum, type: 'olt', meta: { olt: oltNum }, children: [] };
      }
      oltMap[oltNum].children.push(ponNode);
    });
    Object.values(oltMap).forEach(oltn => {
      oltn.children.sort((a, b) => {
        if (+a.meta.olt !== +b.meta.olt) return +a.meta.olt - +b.meta.olt;
        if (+a.meta.ip !== +b.meta.ip) return +a.meta.ip - +b.meta.ip;
        return +a.meta.port - +b.meta.port;
      });
    });
    Object.values(oltMap).sort((a, b) => (+a.meta.olt) - (+b.meta.olt)).forEach(olt => winNode.children.push(olt));
    root.children.push(winNode);
  });
  return root;
}

function renderBalancedTree(rootData) {
  d3.select('#chart').selectAll('*').remove();
  const chartEl = document.getElementById('chart');
  const width = chartEl.clientWidth || window.innerWidth;
  const height = chartEl.clientHeight || (window.innerHeight - 76);
  const treeRoot = d3.hierarchy(rootData);
  const leafCount = Math.max(1, countLeaves(rootData));
  const nodeGap = Math.max(40, Math.min(100, Math.floor(height / (leafCount + 3))));
  const treeLayout = d3.tree().nodeSize([nodeGap, 180]);
  treeLayout(treeRoot);
  const svg = d3.select("#chart").append("svg").attr("width", "100%").attr("height", "100%");
  const g = svg.append("g").attr("transform", "translate(60,40)");

  // Hierarchical links
  g.selectAll(".hwlink")
    .data(treeRoot.links())
    .enter()
    .append("path")
    .attr("class", "link hwlink")
    .attr("fill", "none")
    .attr("stroke", "var(--text-muted)")
    .attr("stroke-width", 4)
    .attr("d", d => {
      const sx = d.source.y, sy = d.source.x, tx = d.target.y, ty = d.target.x;
      const midX = (sx + tx) / 2;
      return `M${sx},${sy} C ${midX},${sy} ${midX},${ty} ${tx},${ty}`;
    });

  // Hierarchical nodes
  const nodes = treeRoot.descendants();
  const nodeG = g.selectAll(".hnode")
    .data(nodes)
    .enter().append("g")
    .attr("class", "hnode")
    .attr("transform", d => `translate(${d.y},${d.x})`);

  nodeG.append("circle")
    .attr("r", d => ({ network: 26, window: 22, olt: 19, pon: 17 }[d.data.type] || 14))
    .attr("fill", d => {
      if (d.data.type === 'network') return '#1e40af';
      if (d.data.type === 'window') return '#3b82f6';
      if (d.data.type === 'olt') return ensureColorForOlt(d.data.meta?.olt);
      if (d.data.type === 'pon') return '#0d9488';
      return '#64748b';
    })
    .attr("stroke", "#fff").attr("stroke-width", 4);

  nodeG.append("text")
    .attr("x", d => d.data.type === 'network' ? 0 : 24)
    .attr("y", 6)
    .attr("font-size", "14px")
    .attr("font-weight", "800")
    .attr("text-anchor", d => d.data.type === 'network' ? "middle" : "start")
    .attr("fill", "var(--text)")
    .text(d => d.data.name);

  // Splitter positions
  const ponNodes = treeRoot.descendants().filter(n => n.data && n.data.type === 'pon');
  const levelColWidth = 220;
  const ponColGap = 140;
  const minVGap = 48;
  const growthPerItem = 12;
  const allSplitterPositions = [];
  ponNodes.forEach(ponN => {
    const p = ponN.data;
    const baseX = ponN.y;
    const baseY = ponN.x;
    const levels = (p.levels || []);
    if (levels.length === 0) return;
    const maxCount = Math.max(...levels.map(l => (l.splitters || []).length, 1), 1);
    const vGap = Math.max(minVGap, minVGap + (maxCount - 1) * growthPerItem);
    const levelSplitters = levels.map(l => Array.isArray(l.splitters) ? l.splitters.slice() : []);
    const userSetOf = sp => new Set((sp.users || []).map(u => normalizeId(u)));
    const orderedLevels = [];
    if (levelSplitters.length >= 1) {
      orderedLevels.push(levelSplitters[0].map((s, i) => ({ s, origIndex: i })));
      for (let li = 1; li < levelSplitters.length; li++) {
        const parents = orderedLevels[li - 1];
        const parentSets = parents.map(pObj => userSetOf(pObj.s));
        const children = levelSplitters[li].map((s, idx) => ({ s, origIndex: idx }));
        const childWithKey = children.map(ch => {
          const chSet = userSetOf(ch.s);
          let foundParentIndex = null;
          for (let pi = 0; pi < parentSets.length; pi++) {
            for (const u of chSet) {
              if (parentSets[pi].has(u)) { foundParentIndex = pi; break; }
            }
            if (foundParentIndex !== null) break;
          }
          return { ch, key: (foundParentIndex === null ? 9999 : foundParentIndex) };
        });
        childWithKey.sort((a, b) => {
          if (a.key !== b.key) return a.key - b.key;
          return a.ch.origIndex - b.ch.origIndex;
        });
        orderedLevels.push(childWithKey.map(x => x.ch));
      }
    }
    orderedLevels.forEach((arr, li) => {
      const count = Math.max(1, arr.length);
      const totalH = (count - 1) * vGap;
      const startY = baseY - totalH / 2;
      const stagger = (li % 2 === 0) ? 0 : Math.min(14, Math.floor(vGap / 5));
      arr.forEach((obj, si) => {
        const sx = baseX + ponColGap + li * levelColWidth + (li % 2 === 0 ? 0 : 8);
        const sy = startY + si * vGap + stagger;
        allSplitterPositions.push({
          pon: p.name,
          level: levels[li].level,
          idx: si,
          x: sx,
          y: sy,
          data: obj.s,
          color: ensureColorForOlt(p.meta.olt)
        });
      });
    });
  });

  // Draw splitters
  const sg = g.append("g").attr("class", "splitters-group");
  const splitterNodes = sg.selectAll(".splitter")
    .data(allSplitterPositions)
    .enter()
    .append("g")
    .attr("class", "splitter")
    .attr("transform", d => `translate(${d.x},${d.y})`)
    .style("cursor", "pointer")
    .on("mousemove", (ev, d) => showTooltip(ev, { name: d.data.type || d.data.recordId, total: d.data.total }))
    .on("mouseout", hideTooltip)
    .on("click", (ev, d) => openPopup(d.data, d.pon, findWindowForPon(d.pon)));

  splitterNodes.each(function (d) {
    const g2 = d3.select(this);
    g2.append("circle").attr("r", 14)
      .attr("fill", d.data.total && d.data.total > 0 ? "var(--success)" : "var(--text-muted)")
      .attr("stroke", "#fff").attr("stroke-width", 4);
    g2.append("text").attr("x", 20).attr("y", 5)
      .attr("font-size", "12px").attr("fill", "var(--text)")
      .text(`${d.data.type}${d.data.total ? ` (${d.data.total})` : ''}`)
      .style("font-weight", "800")
      .each(function () {
        const t = d3.select(this);
        const txt = t.text();
        if (txt.length > 28) t.text(txt.slice(0, 26) + '‚Ä¶');
      });
    if (d.data.recordId) {
      g2.append("text").attr("x", 0).attr("y", 24)
        .attr("font-size", "11px").attr("text-anchor", "middle").attr("fill", "var(--text-muted)")
        .text(d.data.recordId);
    }
  });

  // PON to Level 1 links
  const ponNodesByName = {};
  treeRoot.descendants().filter(n => n.data && n.data.type === 'pon').forEach(n => { ponNodesByName[n.data.name] = n; });
  ponNodes.forEach(ponN => {
    const p = ponN.data;
    const pX = ponN.y, pY = ponN.x;
    const level0 = (p.levels && p.levels[0]) ? p.levels[0].level : null;
    if (level0 === null) return;
    const lvl1Positions = allSplitterPositions.filter(s => s.pon === p.name && s.level === level0);
    lvl1Positions.forEach(child => {
      g.append("path")
        .attr("class", "link")
        .attr("d", pathBezier({ x: pX, y: pY }, { x: child.x, y: child.y }))
        .attr("stroke", ensureColorForOlt(p.meta.olt))
        .attr("stroke-width", 4)
        .attr("fill", "none")
        .attr("stroke-opacity", 0.95);
    });
  });

  // Inter-level links
  ponNodes.forEach(ponN => {
    const p = ponN.data;
    const lv = p.levels || [];
    for (let li = 0; li < lv.length - 1; li++) {
      const L1 = lv[li].level;
      const L2 = lv[li + 1].level;
      const parents = allSplitterPositions.filter(s => s.pon === p.name && s.level === L1);
      const kids = allSplitterPositions.filter(s => s.pon === p.name && s.level === L2);
      const parentSets = parents.map(pr => new Set((pr.data.users || []).map(normalizeId)));
      kids.forEach(ch => {
        const chSet = new Set((ch.data.users || []).map(normalizeId));
        let linked = false;
        for (let pi = 0; pi < parents.length; pi++) {
          let hasCommon = false;
          for (const u of chSet) { if (parentSets[pi].has(u)) { hasCommon = true; break; } }
          if (hasCommon) {
            const pr = parents[pi];
            g.append("path")
              .attr("class", "link")
              .attr("d", pathBezier({ x: pr.x, y: pr.y }, { x: ch.x, y: ch.y }))
              .attr("stroke", ch.color)
              .attr("stroke-width", 4)
              .attr("fill", "none")
              .attr("stroke-opacity", 0.95);
            linked = true;
            break;
          }
        }
      });
    }
  });

  // Zoom & Fit
  const zoom = d3.zoom().scaleExtent([0.3, 4]).on("zoom", ev => g.attr("transform", ev.transform));
  svg.call(zoom);
  try {
    const bb = g.node().getBBox();
    const sx = width / (bb.width + 200);
    const sy = height / (bb.height + 200);
    const s0 = Math.min(sx, sy, 1);
    const tx0 = -bb.x * s0 + 30;
    const ty0 = -bb.y * s0 + 30;
    svg.transition().duration(800).call(zoom.transform, d3.zoomIdentity.translate(tx0, ty0).scale(s0));
  } catch (e) { /* ignore */ }
  applySearchHighlight();
}

function pathBezier(src, dst) {
  const sx = src.x, sy = src.y, tx = dst.x, ty = dst.y;
  const midX = sx + (tx - sx) * 0.5;
  return `M ${sx} ${sy} C ${midX} ${sy} ${midX} ${ty} ${tx} ${ty}`;
}

function countLeaves(node) {
  if (!node || !node.children || node.children.length === 0) return 1;
  return node.children.reduce((s, c) => s + countLeaves(c), 0);
}

function findWindowForPon(pon) {
  if (!rawJson) return '';
  for (const w of rawJson.windows || []) {
    for (const p of w.pons || []) {
      if (p.pon === pon) return w.window;
    }
  }
  return '';
}

function showTooltip(ev, d) {
  tooltip.innerHTML = `<strong>${d.name || d.type || ''}</strong><br>Users: ${d.total || (d.users ? d.users.length : 0)}`;
  tooltip.style.left = (ev.pageX + 12) + "px";
  tooltip.style.top = (ev.pageY + 8) + "px";
  tooltip.style.opacity = 1;
  tooltip.style.color = "var(--text)";
  tooltip.style.background = "var(--card)";
  tooltip.style.border = "1px solid var(--border)";
}

function hideTooltip() { tooltip.style.opacity = 0; }

function openPopup(sp, pon, win) {
  popupModal.style.display = 'flex';
  popupTitle.textContent = `${sp.type || 'Splitter'} ‚Äî Users`;
  popupPath.textContent = `${win || ''} ‚Üí ${pon || ''} ‚Üí ${sp.recordId || ''}`;
  popupMeta.innerHTML = `<b>Total users:</b> ${sp.total || (sp.users ? sp.users.length : 0)}`;
  const users = Array.isArray(sp.users) ? sp.users : [];
  popupUsersTable.innerHTML = `<thead><tr><th>Sr</th><th>User</th></tr></thead><tbody>` + users.map((u, i) => `<tr><td>${i + 1}</td><td>${u}</td></tr>`).join('') + `</tbody>`;
}

function applySearchHighlight() {
  const term = (searchInput.value || '').trim().toLowerCase();
  const nodes = d3.selectAll("g.splitter");
  if (!term) {
    nodes.selectAll("circle").attr("opacity", 1).attr("stroke", "#fff").attr("stroke-width", 4);
    nodes.selectAll("text").attr("opacity", 1).style("font-weight", "800");
    return;
  }
  nodes.each(function (d) {
    const users = d.data.users || [];
    const hit = users.some(u => String(u).toLowerCase().includes(term));
    const g = d3.select(this);
    if (hit) {
      g.select("circle").attr("stroke", "#ec4899").attr("stroke-width", 5).attr("opacity", 1);
      g.selectAll("text").attr("opacity", 1).style("font-weight", "900");
    } else {
      g.select("circle").attr("opacity", 0.3);
      g.selectAll("text").attr("opacity", 0.3);
    }
  });
}

function downloadCSV() {
  if (popupModal.style.display !== 'flex') return;
  const rows = [...popupUsersTable.querySelectorAll("tr")];
  if (!rows.length) return;
  let csv = '';
  rows.forEach(r => {
    const cols = [...r.querySelectorAll("th,td")].map(c => `"${(c.textContent || '').replace(/"/g, '""')}"`);
    csv += cols.join(",") + "\n";
  });
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'users.csv'; a.click(); URL.revokeObjectURL(url);
}

function downloadScreenshot() {
  const svg = document.querySelector("#chart svg");
  if (!svg) return alert("Nothing to save");
  const xml = new XMLSerializer().serializeToString(svg);
  const blob = new Blob([xml], { type: "image/svg+xml" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'merotra-tree.svg'; a.click(); URL.revokeObjectURL(url);
}

// Init
loadAndRender(false);
window.addEventListener('resize', () => rawJson && applyFiltersAndRender());
</script>
</body>
</html>
