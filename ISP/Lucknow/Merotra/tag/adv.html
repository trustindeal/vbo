<DOCUMENT filename="css.txt">
/* --------------------------------------------------------- */
/* MEROTRA ‚Äî PREMIUM FIBER NETWORK VISUALIZER (2025 PREMIUM)    */
/* Ultra-smooth animations | Glassmorphism | 3D Feel        */
/* --------------------------------------------------------- */

:root {
  --primary: #2563eb;
  --primary-dark: #1d4ed8;
  --success: #10b981;
  --warning: #f59e0b;
  --gray-50: #f9fafb;
  --gray-100: #f3f4f6;
  --gray-200: #e5e7eb;
  --gray-300: #d1d5db;
  --gray-500: #6b7280;
  --gray-600: #4b5563;
  --gray-700: #374151;
  --gray-800: #1f2937;
  --gray-900: #111827;
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.1);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.1);
  --shadow-lg: 0 10px 30px rgba(0,0,0,0.12);
  --shadow-xl: 0 20px 50px rgba(0,0,0,0.15);
  --radius: 14px;
  --transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
  --bounce: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}

*,
*::before,
*::after {
  box-sizing: border-box;
  transition: var(--transition);
}

body {
  font-family: 'Inter,system-ui,-apple-system,'Segoe UI',Roboto,sans-serif;
  margin: 0;
  padding: 0;
  height: 100vh;
  overflow: hidden;
  background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
  color: var(--gray-900);
  line-height: 1.5;
}

/* Main chart */
#chart {
  width: 100%;
  height: calc(100vh - 64px);
  position: relative;
  overflow: hidden;
  background: transparent;
}

#chart svg {
  width: 100%;
  height: 100%;
  display: block;
  will-change: transform;
  perspective: 1200px;
  transform-style: preserve-3d;
}

/* Header */
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 20px;
  background: rgba(255,255,255,0.96);
  backdrop-filter: blur(20px);
  box-shadow: var(--shadow-lg);
  border-bottom: 1px solid var(--gray-200);
  position: sticky;
  top: 0;
  z-index: 40;
}

.header-title {
  font-weight: 800;
  font-size: 1.35rem;
  color: var(--primary);
  letter-spacing: -0.5px;
}

.toolbar {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

/* Buttons */
.btn, .download-btn, .rotation-btn, .small-btn {
  padding: 9px 18px;
  border: none;
  border-radius: var(--radius);
  font-weight: 600;
  font-size: 0.875rem;
  cursor: pointer;
  box-shadow: var(--shadow-sm);
  transition: var(--bounce);
  position: relative;
  overflow: hidden;
}

.btn:hover, .download-btn:hover, .rotation-btn:hover {
  transform: translateY(-4px) scale(1.105);
  box-shadow: var(--shadow-xl);
}

.btn:active {
  transform: translateY(-1px);
}

.btn {
  background: var(--primary);
  color: white;
}

.btn-secondary {
  background: var(--gray-200);
  color: var(--gray-800);
}

.btn-secondary:hover {
  background: var(--gray-300);
}

.download-btn {
  padding: 10px 20px;
  border-radius: 50px;
}

.btn-shot { background: var(--success); }
.btn-shot:hover { background: #059669; }
.btn-csv { background: var(--warning); }
.btn-csv:hover { background: #d97706; }

.rotation-btn {
  background: var(--gray-100);
  color: var(--gray-700);
  padding: 8px 12px;
  font-size: 0.9rem;
  border-radius: 50%;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Search */
.search-folded {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: var(--primary);
  color: white;
  border: none;
  cursor: pointer;
  box-shadow: var(--shadow-md);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.4rem;
  transition: var(--bounce);
}

.search-folded:hover {
  transform: scale(1.15) rotate(20deg);
  box-shadow: var(--shadow-xl);
}

.search-input {
  padding: 10px 16px;
  border: 1px solid var(--gray-300);
  border-radius: var(--radius);
  width: 240px;
  font-size: 0.9rem;
  background: white;
  box-shadow: var(--shadow-sm);
  display: none;
}

.search-input:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 4px rgba(37,99,235,0.15);
  transform: scale(1.02);
}

@keyframes bouncyExpand {
  0%   { transform: scale(0) rotate(-180deg); opacity: 0; }
  60%  { transform: scale(1.18); opacity: 1; }
  100% { transform: scale(1); opacity: 1; }
}

.search-expanded {
  animation: bouncyExpand 0.6s var(--bounce);
}

/* Filters Popup */
.filters-toggle {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background: var(--success);
  color: white;
  border: none;
  cursor: pointer;
  box-shadow: var(--shadow-md);
  font-size: 1.4rem;
  transition: var(--bounce);
}

.filters-toggle:hover {
  transform: rotate(180deg) scale(1.1);
  box-shadow: var(--shadow-xl);
}

.filters-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  backdrop-filter: blur(16px);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

.filters-modal {
  background: white;
  border-radius: var(--radius);
  padding: 28px;
  width: 92%;
  max-width: 420px;
  max-height: 85vh;
  overflow: auto;
  box-shadow: var(--shadow-xl);
  transform: scale(0.9);
  opacity: 0;
  transition: all 0.5s var(--bounce);
}

.filters-backdrop[style*="flex"] .filters-modal {
  transform: scale(1);
  opacity: 1;
}

.filters-section h3 {
  margin: 20px 0 12px;
  font-size: 1rem;
  color: var(--gray-800);
}

.checkbox-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px;
  border-radius: 10px;
  cursor: pointer;
  transition: background 0.3s;
}

.checkbox-item:hover {
  background: var(--gray-100);
}

.checkbox-item input[type="checkbox"] {
  accent-color: var(--primary);
  width: 18px;
  height: 18px;
}

.filters-actions {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  margin-top: 24px;
  padding-top: 20px;
  border-top: 1px solid var(--gray-200);
}

/* Popup */
.popup-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  backdrop-filter: blur(20px);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 200;
}

.modal-content {
  background: rgba(255,255,255,0.98);
  border-radius: var(--radius);
  padding: 28px;
  width: 92%;
  max-width: 560px;
  max-height: 88vh;
  overflow: auto;
  box-shadow: var(--shadow-xl);
  border: 1px solid rgba(255,255,255,0.3);
  transform: scale(0.92);
  opacity: 0;
  transition: all 0.6s var(--bounce);
}

.popup-backdrop[style*="flex"] .modal-content {
  transform: scale(1);
  opacity: 1;
}

.user-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.875rem;
  margin: 16px 0;
}

.user-table th, .user-table td {
  padding: 12px 10px;
  text-align: left;
  border-bottom: 1px solid var(--gray-200);
}

.user-table th {
  background: var(--gray-50);
  font-weight: 600;
  position: sticky;
  top: 0;
}

/* Tree Elements - Ultra Smooth 3D */
.node-circle, .splitter circle {
  stroke: white;
  stroke-width: 4px;
  filter: drop-shadow(0 6px 20px rgba(0,0,0,0.15));
  transition: all 0.5s var(--bounce);
  opacity: 0;
  animation: nodeAppear 1s var(--bounce) forwards;
}

.node-circle:hover, .splitter circle:hover {
  transform: scale(1.25);
  filter: drop-shadow(0 15px 40px rgba(37,99,235,0.4));
}

@keyframes nodeAppear {
  to { opacity: 1; }
}

.node-text, .splitter text {
  font-weight: 600;
  fill: var(--gray-900);
  filter: drop-shadow(0 1px 3px rgba(0,0,0,0.2));
  opacity: 0;
  animation: nodeAppear 1s var(--bounce) 0.2s forwards;
}

.link, .hwlink {
  stroke-width: 3.5px;
  stroke-linecap: round;
  filter: drop-shadow(0 2px 8px rgba(0,0,0,0.1));
  stroke-dasharray: 1000;
  stroke-dashoffset: 1000;
  animation: drawLine 3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

@keyframes drawLine {
  to { stroke-dashoffset: 0; }
}

/* Tooltip */
.tooltip {
  position: absolute;
  background: rgba(0,0,0,0.85);
  color: white;
  padding: 10px 16px;
  border-radius: 12px;
  font-size: 0.875rem;
  pointer-events: none;
  opacity: 0;
  transform: translateY(10px);
  backdrop-filter: blur(10px);
  box-shadow: var(--shadow-lg);
  transition: all 0.4s var(--bounce);
  z-index: 999;
}

.tooltip:not([style*="opacity: 0"]) {
  opacity: 1;
  transform: translateY(0);
}

/* Rotation */
#chart svg {
  transition: transform 0.9s var(--bounce);
}

.rotation-90 { transform: rotate(90deg); }
.rotation-180 { transform: rotate(180deg); }
.rotation-270 { transform: rotate(270deg); }
.rotation-0 { transform: rotate(0deg); }

/* Mobile */
@media (max-width: 640px) {
  .header { padding: 10px 16px; flex-direction: column; gap: 12px; }
  .header-title { font-size: 1.2rem; text-align: center; }
  .toolbar { justify-content: center; gap: 8px; }
  .search-input { width: 180px; }
  .modal-content, .filters-modal { padding: 20px; }
  .btn { padding: 8px 14px; font-size: 0.8rem; }
}
</DOCUMENT>

<DOCUMENT filename="html.txt">
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merotra ‚Äî Auto Populated Fiber Network</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="css.txt">
  <style>
    :root { font-family: Inter,system-ui,Arial; }
    body { margin:0; padding:0; background:linear-gradient(135deg,#f0f9ff,#e0f2fe); color:#111827; }
    #chart { width:100%; height: calc(100vh - 64px); overflow:hidden; position:relative; }
    #chart svg { will-change: transform; }
  </style>
</head>
<body>

<div class="header">
  <div>
    <div class="header-title">Auto populated fiber network</div>
  </div>

  <div class="toolbar">
    <button id="filtersToggle" class="filters-toggle" title="Filters">‚öôÔ∏è</button>
    <button id="searchFold" class="search-folded">üîç</button>
    <input id="searchInput" class="search-input" placeholder="Search user id or part..." />

    <button id="rotateBtn" class="rotation-btn" title="Rotate">‚Üª</button>

    <button id="reloadBtn" class="btn">Refresh</button>
  </div>
</div>

<div id="chart"></div>
<div id="tooltip" class="tooltip"></div>

<!-- Filters Modal -->
<div id="filtersModal" class="filters-backdrop">
  <div class="filters-modal">
    <h2 style="margin:0 0 24px;font-size:1.3rem;color:var(--gray-900)">Filters</h2>
    <div class="filters-section"><h3>Windows</h3><div id="windowCheckboxes"></div></div>
    <div class="filters-section"><h3>OLTs</h3><div id="oltCheckboxes"></div></div>
    <div class="filters-section"><h3>PONs</h3><div id="ponCheckboxes"></div></div>
    <div class="filters-actions">
      <button id="selectAll" class="btn btn-secondary">Select All</button>
      <button id="deselectAll" class="btn btn-secondary">Deselect All</button>
      <button id="applyFilters" class="btn">Apply</button>
      <button id="clearFiltersPopup" class="btn btn-secondary">Clear</button>
    </div>
  </div>
</div>

<!-- User Popup -->
<div id="popupModal" class="popup-backdrop" style="display:none">
  <div class="modal-content">
    <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:16px">
      <div>
        <h2 id="popupTitle" style="margin:0;font-size:1.25rem;font-weight:600"></h2>
        <div id="popupPath" style="font-size:0.875rem;color:var(--gray-600);margin-top:6px"></div>
      </div>
      <button id="popupClose" class="btn btn-secondary" style="padding:8px 16px">Close</button>
    </div>
    <div id="popupMeta" style="padding:12px;background:var(--gray-50);border-radius:10px;margin:16px 0;font-weight:600"></div>
    <div style="max-height:50vh;overflow:auto">
      <table id="popupUsersTable" class="user-table">
        <thead><tr><th>Sr</th><th>User ID</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
    <div style="display:flex;gap:12px;margin-top:20px">
      <button id="btnShot" class="download-btn btn-shot">Screenshot</button>
      <button id="btnCsv" class="download-btn btn-csv">CSV</button>
    </div>
  </div>
</div>

<script>
/* ==========================================
   CONFIG & GLOBALS (unchanged behaviour)
   ========================================== */
const BOARD_URL =
 "https://script.google.com/macros/s/AKfycbzItUueYIqcUuCn2cDaTTrWIF0LiilUxOXhhL-4b4D9aUlEo8Ov9pasR44d6JSM3h1t/exec?mode=board";

let rawJson = null;
let colorByOlt = new Map();
let currentRotation = 0;

const tooltip = document.getElementById('tooltip');
const reloadBtn = document.getElementById('reloadBtn');
const popupModal = document.getElementById('popupModal');
const popupClose = document.getElementById('popupClose');
const popupTitle = document.getElementById('popupTitle');
const popupPath  = document.getElementById('popupPath');
const popupMeta  = document.getElementById('popupMeta');
const popupUsersTable = document.getElementById('popupUsersTable');

const searchFold = document.getElementById('searchFold');
const searchInput = document.getElementById('searchInput');

const filtersModal = document.getElementById('filtersModal');
const filtersToggle = document.getElementById('filtersToggle');
const windowCheckboxes = document.getElementById('windowCheckboxes');
const oltCheckboxes = document.getElementById('oltCheckboxes');
const ponCheckboxes = document.getElementById('ponCheckboxes');
const selectAll = document.getElementById('selectAll');
const deselectAll = document.getElementById('deselectAll');
const applyFilters = document.getElementById('applyFilters');
const clearFiltersPopup = document.getElementById('clearFiltersPopup');

const rotateBtn = document.getElementById('rotateBtn');

let filterState = { windows: new Set(), olts: new Set(), pons: new Set() };

document.getElementById('btnShot').addEventListener('click', downloadScreenshot);
document.getElementById('btnCsv').addEventListener('click', downloadCSV);
popupClose.addEventListener('click', ()=> popupModal.style.display='none');

reloadBtn.addEventListener('click', ()=> loadAndRender(true));

rotateBtn.addEventListener('click', () => rotateChart(90));

// Filters popup events
filtersToggle.addEventListener('click', () => {
  filtersModal.style.display = 'flex';
  buildFilterCheckboxes();
});
filtersModal.addEventListener('click', (e) => {
  if (e.target === filtersModal) filtersModal.style.display = 'none';
});
selectAll.addEventListener('click', () => selectAllCheckboxes(true));
deselectAll.addEventListener('click', () => selectAllCheckboxes(false));
applyFilters.addEventListener('click', () => {
  updateFilterStateFromCheckboxes();
  filtersModal.style.display = 'none';
  applyFiltersAndRender();
});
clearFiltersPopup.addEventListener('click', () => {
  filterState = { windows: new Set(), olts: new Set(), pons: new Set() };
  selectAllCheckboxes(false);
  applyFiltersAndRender();
  filtersModal.style.display = 'none';
});

// Search
searchFold.addEventListener('click', ()=> {
  if (searchInput.style.display === 'none') {
    searchInput.style.display='inline-block';
    searchInput.classList.add('search-expanded');
    searchInput.focus();
    setTimeout(() => searchInput.classList.remove('search-expanded'), 600);
  } else {
    searchInput.style.display='none';
    searchInput.value='';
    applyFiltersAndRender();
  }
});
searchInput.addEventListener('input', ()=> applyFiltersAndRender());

function rotateChart(deg) {
  const chart = document.getElementById('chart');
  const svg = chart.querySelector('svg');
  if (svg) {
    currentRotation = (currentRotation + deg) % 360;
    svg.className = `rotated rotation-${currentRotation}`;
    // Re-render to adjust layout if needed
    if (rawJson) applyFiltersAndRender();
  }
}

/* ==========================================
   Helpers (unchanged)
   ========================================== */
function normalizeId(v){ return (v ?? "").toString().trim(); }
function getOltNumberFromPon(pon){
  const m = (pon || "").match(/O(\d+)/i);
  return m ? m[1] : "0";
}
function parsePonKey(pon){
  const m = (pon || "").match(/O(\d+)I(\d+)P(\d+)/i);
  if(!m) return {olt:9999, ip:9999, port:9999};
  return {olt:+m[1], ip:+m[2], port:+m[3]};
}
function ensureColorForOlt(olt){
  if(!colorByOlt.has(String(olt))){
    const idx = colorByOlt.size;
    const h = (idx * 50) % 360;
    colorByOlt.set(String(olt), `hsl(${h} 65% 45%)`);
  }
  return colorByOlt.get(String(olt));
}

/* Filter helpers */
function buildFilterCheckboxes() {
  if (!rawJson) return;
  const winSet = new Set(), oltSet = new Set(), ponSet = new Set();
  (rawJson.windows||[]).forEach(w=>{
    winSet.add(w.window||'');
    (w.pons||[]).forEach(p=>{
      ponSet.add(p.pon||'');
      oltSet.add(getOltNumberFromPon(p.pon||''));
    });
  });
  
  windowCheckboxes.innerHTML = Array.from(winSet).sort().map(v => 
    `<label class="checkbox-item"><input type="checkbox" value="${v}" ${filterState.windows.has(v)?'checked':''}> ${v}</label>`
  ).join('');
  
  oltCheckboxes.innerHTML = Array.from(oltSet).sort((a,b)=>+a-+b).map(v => 
    `<label class="checkbox-item"><input type="checkbox" value="${v}" ${filterState.olts.has(v)?'checked':''}> OLT-${v}</label>`
  ).join('');
  
  ponCheckboxes.innerHTML = Array.from(ponSet).sort().map(v => 
    `<label class="checkbox-item"><input type="checkbox" value="${v}" ${filterState.pons.has(v)?'checked':''}> ${v}</label>`
  ).join('');
}

function selectAllCheckboxes(select) {
  [...windowCheckboxes.querySelectorAll('input'), ...oltCheckboxes.querySelectorAll('input'), ...ponCheckboxes.querySelectorAll('input')]
    .forEach(cb => { cb.checked = select; });
  updateFilterStateFromCheckboxes();
}

function updateFilterStateFromCheckboxes() {
  filterState.windows = new Set([...windowCheckboxes.querySelectorAll('input:checked')].map(cb => cb.value));
  filterState.olts = new Set([...oltCheckboxes.querySelectorAll('input:checked')].map(cb => cb.value));
  filterState.pons = new Set([...ponCheckboxes.querySelectorAll('input:checked')].map(cb => cb.value));
}

/* ==========================================
   Load / Filter / Transform (modified for checkbox filters)
   ========================================== */
async function loadAndRender(showToast=false){
  try {
    setLoading(true);
    const res = await fetch(BOARD_URL);
    if(!res.ok) throw new Error("HTTP "+res.status);

    const j = await res.json();
    rawJson = j;

    colorByOlt = new Map();
    buildFilterCheckboxes();

    applyFiltersAndRender();

    if(showToast) console.info('Board loaded', j.summary || {});
  } catch(err){
    console.error(err);
    alert("Load error: " + err.message);
  } finally {
    setLoading(false);
  }
}
function setLoading(flag){
  reloadBtn.disabled = flag;
  reloadBtn.textContent = flag ? "Loading..." : "Refresh";
}

function applyFiltersAndRender(){
  if(!rawJson) return;
  const filtered = applyClientFilters(rawJson);
  const root = transformToHierarchy(filtered);
  renderBalancedTree(root);
}

function applyClientFilters(j){
  const term=(searchInput.value||'').trim().toLowerCase();

  const out={windows:[]};
  (j.windows||[]).forEach(win=>{
    if(filterState.windows.size > 0 && !filterState.windows.has(win.window)) return;
    const newWin={window:win.window, pons:[]};
    (win.pons||[]).forEach(p=>{
      if(filterState.pons.size > 0 && !filterState.pons.has(p.pon)) return;
      if(filterState.olts.size > 0 && !filterState.olts.has(getOltNumberFromPon(p.pon))) return;
      const newLv = (p.levels||[]).filter(l=>Array.isArray(l.splitters)&&l.splitters.length>0);
      if(newLv.length===0 && term){
        if(!deepSearchMatch(p, term)) return;
      }
      newWin.pons.push({...p, levels:newLv});
    });
    if(newWin.pons.length>0 || filterState.windows.size === 0) out.windows.push(newWin);
  });
  return out;
}
function deepSearchMatch(p, term){
  if(!term) return false;
  for(const lvl of (p.levels||[])){
    for(const sp of (lvl.splitters||[])){
      for(const u of (sp.users||[])){
        if(String(u).toLowerCase().includes(term)) return true;
      }
    }
  }
  return false;
}

/* ==========================================
   transformToHierarchy() - produce tree up to PON
   (unchanged semantics)
   ========================================== */
function transformToHierarchy(j){
  const root = { name:'Merotra Network', type:'network', children:[] };

  (j.windows || []).forEach(win => {
    const winNode = { name: win.window, type:'window', children:[] };
    const oltMap = {};
    (win.pons || []).forEach(p => {
      const meta = parsePonKey(p.pon);
      const levels = (p.levels||[])
        .map(l=>({
          level:l.level,
          splitters:(l.splitters||[]).map(sp=>({
            recordId:sp.recordId||'',
            type:sp.type||'',
            users:(sp.users||[]).map(x=>String(x)),
            total:sp.total || ((sp.users||[]).length || 0)
          }))
        }));
      const ponNode={ name: p.pon, type:'pon', meta, levels };
      const oltNum = String(meta.olt);
      if(!oltMap[oltNum]){
        oltMap[oltNum] = { name: "OLT-"+oltNum, type:'olt', meta:{olt:oltNum}, children:[] };
      }
      oltMap[oltNum].children.push(ponNode);
    });

    // sort PONs inside each OLT by (OLT,IP,Port)
    Object.values(oltMap).forEach(oltn=>{
      oltn.children.sort((a,b)=>{
        if(+a.meta.olt !== +b.meta.olt) return +a.meta.olt - +b.meta.olt;
        if(+a.meta.ip  !== +b.meta.ip ) return +a.meta.ip  - +b.meta.ip;
        return +a.meta.port - +b.meta.port;
      });
    });

    Object.values(oltMap).sort((a,b)=> (+a.meta.olt)-(+b.meta.olt)).forEach(olt=> winNode.children.push(olt));
    root.children.push(winNode);
  });
  return root;
}

/* ==========================================
   RENDER (balanced placement + crossing minimization + animations + 3D)
   ========================================== */
function renderBalancedTree(rootData){
  // clear
  d3.select('#chart').selectAll('*').remove();

  const chartEl = document.getElementById('chart');
  const width = chartEl.clientWidth || window.innerWidth;
  const height = chartEl.clientHeight || (window.innerHeight - 60);

  // create d3.hierarchy for network->window->olt->pon
  const treeRoot = d3.hierarchy(rootData);

  // choose vertical node gap based on leaf count (keeps things dense but not overlapped)
  const leafCount = Math.max(1, countLeaves(rootData));
  const nodeGap = Math.max(36, Math.min(90, Math.floor(height / (leafCount + 3))));

  const treeLayout = d3.tree().nodeSize([nodeGap, 160]); // [x(vertical), y(horizontal)]
  treeLayout(treeRoot);

  // create svg and group
  const svg = d3.select("#chart").append("svg").attr("width","100%").attr("height","100%").attr("class", `rotated rotation-${currentRotation}`);
  const g = svg.append("g").attr("transform","translate(40,40)");

  // tree links (network->window->olt->pon) with animation
  g.selectAll(".hwlink")
    .data(treeRoot.links())
    .enter()
    .append("path")
    .attr("class","link hwlink")
    .attr("fill","none")
    .attr("stroke","#94a3b8")
    .attr("stroke-width",3)
    .attr("d", d => {
      // smooth horizontal bezier between source (y,x) and target
      const sx = d.source.y, sy = d.source.x, tx = d.target.y, ty = d.target.x;
      const midX = (sx + tx) / 2;
      return `M${sx},${sy} C ${midX},${sy} ${midX},${ty} ${tx},${ty}`;
    });

  // draw hierarchical nodes (network/window/olt/pon)
  const nodes = treeRoot.descendants();
  const nodeG = g.selectAll(".hnode")
    .data(nodes)
    .enter().append("g")
    .attr("class","hnode")
    .attr("transform", d=>`translate(${d.y},${d.x})`);

  nodeG.append("circle")
    .attr("class", "node-circle")
    .attr("r", d => ({network:22, window:18, olt:16, pon:14}[d.data.type] || 10))
    .attr("fill", d => {
      if(d.data.type==='network') return '#1e3a8a';
      if(d.data.type==='window') return '#1d4ed8';
      if(d.data.type==='olt') return ensureColorForOlt(d.data.meta.olt);
      if(d.data.type==='pon') return '#0f766e';
      return '#6b7280';
    })
    .attr("stroke","#fff").attr("stroke-width",3);

  nodeG.append("text")
    .attr("class", "node-text")
    .attr("x", d=> d.data.type==='network'?0:18)
    .attr("y", 4)
    .attr("font-size","12px")
    .attr("font-weight","600")
    .attr("text-anchor", d=> d.data.type==='network'? "middle":"start")
    .text(d=>d.data.name);

  // Stagger node entrance
  nodeG.attr("opacity", 0)
    .transition()
    .delay((d, i) => i * 12)
    .duration(900)
    .attr("opacity", 1);

  // find PON nodes for constructing their level columns
  const ponNodes = treeRoot.descendants().filter(n => n.data && n.data.type === 'pon');

  // layout parameters for columns (tweakable)
  const levelColWidth = 220;   // horizontal gap per level
  const ponColGap = 140;       // gap between pon column and first level
  const minVGap = 44;          // minimum vertical gap between splitters
  const growthPerItem = 12;    // how much vertical gap increases with more items

  // We'll compute splitter positions per PON using a balanced algorithm:
  // 1) Compute max splitters across levels for this PON -> determines base vGap.
  // 2) For each level, re-order splitters to align with parent-level indices (greedy matching).
  // 3) Place splitters centered on the PON's vertical position with computed vGap.
  const allSplitterPositions = []; // collect {pon, level, idx, x, y, data, color}

  ponNodes.forEach(ponN => {
    const p = ponN.data;
    const baseX = ponN.y;
    const baseY = ponN.x;
    const levels = (p.levels || []);

    if(levels.length === 0) return;

    // compute max number of splitters across levels for this PON
    const maxCount = Math.max(...levels.map(l => (l.splitters || []).length, 1), 1);

    // dynamic vGap ‚Äî larger when any level is large
    const vGap = Math.max(minVGap, minVGap + (maxCount - 1) * growthPerItem);

    // Preprocess: keep the original sheet order for level0; for subsequent levels we will reorder to minimize crossings.
    // Build parent index mapping for greedy ordering:
    // For level 0 we simply take sheet order.
    const levelSplitters = levels.map(l => Array.isArray(l.splitters) ? l.splitters.slice() : []);

    // helper to compute user sets
    const userSetOf = sp => new Set((sp.users || []).map(u => normalizeId(u)));

    // We'll compute ordering for each level (starting from level 0)
    const orderedLevels = [];
    if(levelSplitters.length >= 1) {
      // level 0: sheet order
      orderedLevels.push(levelSplitters[0].map((s, i) => ({s, origIndex: i})));
      // subsequent levels:
      for(let li = 1; li < levelSplitters.length; li++){
        const parents = orderedLevels[li-1];
        const parentSets = parents.map(pObj => userSetOf(pObj.s));
        const children = levelSplitters[li].map((s, idx) => ({s, origIndex: idx}));

        // For each child, find best parent (first parent with any overlap), and use parent's index as key
        // If multiple parents, use first match. If no parent, give them a large key to push later.
        const childWithKey = children.map(ch => {
          const chSet = userSetOf(ch.s);
          let foundParentIndex = null;
          for(let pi = 0; pi < parentSets.length; pi++){
            // fast intersection check
            for(const u of chSet){
              if(parentSets[pi].has(u)){ foundParentIndex = pi; break; }
            }
            if(foundParentIndex !== null) break;
          }
          return { ch, key: (foundParentIndex === null ? 9999 : foundParentIndex) };
        });

        // sort by key, but preserve sheet order within same key
        childWithKey.sort((a,b) => {
          if(a.key !== b.key) return a.key - b.key;
          return a.ch.origIndex - b.ch.origIndex;
        });
        orderedLevels.push(childWithKey.map(x => x.ch));
      }
    }

    // Now we have orderedLevels: list per level of splitter objects in an order that tries to minimize crossing.
    // Place them vertically centered on baseY with vGap spacing. We use an extra small vertical offset per level index (stagger)
    // to reduce overlap of connecting curves.
    orderedLevels.forEach((arr, li) => {
      const count = Math.max(1, arr.length);
      const totalH = (count - 1) * vGap;
      const startY = baseY - totalH / 2;
      // small stagger offset for alternate levels (reduces curve overlap)
      const stagger = (li % 2 === 0) ? 0 : Math.min(12, Math.floor(vGap/6));

      arr.forEach((obj, si) => {
        const sx = baseX + ponColGap + li * levelColWidth + (li % 2 === 0 ? 0 : 6); // tiny horizontal nudge for odd levels
        const sy = startY + si * vGap + stagger;
        allSplitterPositions.push({
          pon: p.name,
          level: levels[li].level,
          idx: si,
          x: sx,
          y: sy,
          data: obj.s,
          color: ensureColorForOlt(p.meta.olt)
        });
      });
    });
  });

  // draw splitters
  const sg = g.append("g").attr("class","splitters-group");

  const splitterNodes = sg.selectAll(".splitter")
    .data(allSplitterPositions)
    .enter()
    .append("g")
    .attr("class","splitter")
    .attr("transform", d=>`translate(${d.x},${d.y})`)
    .style("cursor","pointer")
    .on("mousemove",(ev,d)=> showTooltip(ev, {name:d.data.type || d.data.recordId, total:d.data.total}))
    .on("mouseout", hideTooltip)
    .on("click", (ev,d)=> openPopup(d.data, d.pon, findWindowForPon(d.pon)));

  splitterNodes.each(function(d){
    const g2 = d3.select(this);
    g2.append("circle").attr("r", 12)
      .attr("fill", d.data.total && d.data.total>0 ? "#10b981" : "#6b7280")
      .attr("stroke","#fff").attr("stroke-width",3);

    g2.append("text").attr("x", 18).attr("y", 4)
      .attr("font-size",11).attr("fill","#0f172a")
      .text(`${d.data.type}${d.data.total ? ` (${d.data.total})` : ''}`)
      .style("font-weight",600)
      .each(function(){ // ellipsis if too long
        const t = d3.select(this);
        const txt = t.text();
        if (txt.length > 28) t.text(txt.slice(0,26) + '‚Ä¶');
      });

    if(d.data.recordId){
      g2.append("text").attr("x",0).attr("y",22)
        .attr("font-size",10).attr("text-anchor","middle").attr("fill","#64748b")
        .text(d.data.recordId);
    }
  });

  // Stagger splitter entrance
  splitterNodes.attr("opacity", 0)
    .transition()
    .delay((d, i) => i * 15)
    .duration(800)
    .attr("opacity", 1);

  // LINKS SECTION (with animations)
  // 1) PON -> level1 (always)
  const ponNodesByName = {};
  treeRoot.descendants().filter(n => n.data && n.data.type === 'pon').forEach(n => { ponNodesByName[n.data.name] = n; });

  ponNodes.forEach(ponN => {
    const p = ponN.data;
    const pX = ponN.y, pY = ponN.x;
    const level0 = (p.levels && p.levels[0]) ? p.levels[0].level : null;
    if(level0 === null) return;

    const lvl1Positions = allSplitterPositions.filter(s => s.pon === p.name && s.level === level0);
    lvl1Positions.forEach((child, i) => {
      g.append("path")
        .attr("class", "link")
        .attr("d", pathBezier({x:pX,y:pY},{x:child.x,y:child.y}))
        .attr("stroke", ensureColorForOlt(p.meta.olt))
        .attr("stroke-width", 3)
        .attr("fill", "none")
        .attr("stroke-opacity", 0.95);
    });
  });

  // 2) levelN -> levelN+1: connect each child splitter to first previous-level splitter that shares any user
  ponNodes.forEach(ponN => {
    const p = ponN.data;
    const lv = p.levels || [];
    for(let li = 0; li < lv.length - 1; li++){
      const L1 = lv[li].level;
      const L2 = lv[li+1].level;
      const parents = allSplitterPositions.filter(s => s.pon === p.name && s.level === L1);
      const kids = allSplitterPositions.filter(s => s.pon === p.name && s.level === L2);

      const parentSets = parents.map(pr => new Set((pr.data.users || []).map(normalizeId)));

      kids.forEach((ch, i) => {
        const chSet = new Set((ch.data.users || []).map(normalizeId));
        let linked = false;
        for(let pi=0; pi<parents.length; pi++){
          // check intersection
          let hasCommon = false;
          for(const u of chSet){ if(parentSets[pi].has(u)){ hasCommon = true; break; } }
          if(hasCommon){
            const pr = parents[pi];
            g.append("path")
              .attr("class", "link")
              .attr("d", pathBezier({x:pr.x,y:pr.y},{x:ch.x,y:ch.y}))
              .attr("stroke", ch.color)
              .attr("stroke-width", 3)
              .attr("fill", "none")
              .attr("stroke-opacity", 0.95);
            linked = true;
            break;
          }
        }
        // if not linked, no path (per rule)
      });
    }
  });

  // Stagger links
  g.selectAll(".link, .hwlink")
    .attr("stroke-dashoffset", 1000)
    .transition()
    .delay((d, i) => i * 8)
    .duration(3000)
    .attr("stroke-dashoffset", 0);

  // ZOOM ‚Äì ultra smooth with momentum feel
  const zoom = d3.zoom()
    .scaleExtent([0.2, 4])
    .on("zoom", (ev) => {
      g.attr("transform", ev.transform);
    })
    .filter(event => {
      // allow pinch-zoom on mobile & wheel
      return !event.ctrlKey || event.type === 'wheel';
    });

  svg.call(zoom);

  // fit to view nicely
  try {
    const bb = g.node().getBBox();
    const sx = width/(bb.width + 120);
    const sy = height/(bb.height + 120);
    const s0 = Math.min(sx, sy, 1);
    const tx0 = -bb.x * s0 + 20;
    const ty0 = -bb.y * s0 + 20;
    svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(tx0,ty0).scale(s0));
  } catch(e) { /* ignore */ }

  // apply search highlight after everything drawn
  applySearchHighlight();
}

/* path helpers */
function pathBezier(src, dst){
  const sx = src.x, sy = src.y, tx = dst.x, ty = dst.y;
  const midX = sx + (tx - sx) * 0.5;
  // gentle S-curve; reduces intersections better
  return `M ${sx} ${sy} C ${midX} ${sy} ${midX} ${ty} ${tx} ${ty}`;
}
function countLeaves(node){
  if(!node || !node.children || node.children.length===0) return 1;
  return node.children.reduce((s,c)=> s + countLeaves(c), 0);
}
function findWindowForPon(pon){
  if(!rawJson) return '';
  for(const w of rawJson.windows||[]){
    for(const p of w.pons||[]){
      if(p.pon===pon) return w.window;
    }
  }
  return '';
}

/* ==========================================
   Tooltip / Popup (unchanged)
   ========================================== */
function showTooltip(ev, d){
  tooltip.innerHTML = `<strong>${d.name || d.type || ''}</strong><br>Users: ${d.total || (d.users?d.users.length:0)}`;
  tooltip.style.left = (ev.pageX+12)+"px";
  tooltip.style.top  = (ev.pageY+8)+"px";
  tooltip.style.opacity = 1;
}
function hideTooltip(){ tooltip.style.opacity = 0; }

function openPopup(sp, pon, win){
  popupModal.style.display = 'flex';
  popupTitle.textContent = `${sp.type || 'Splitter'} ‚Äî Users`;
  popupPath.textContent = `${win||''} ‚Üí ${pon||''} ‚Üí ${sp.recordId||''}`;
  popupMeta.innerHTML = `<b>Total users:</b> ${sp.total || (sp.users?sp.users.length:0)}`;
  const users = Array.isArray(sp.users) ? sp.users : [];
  const tbody = popupUsersTable.querySelector('tbody');
  tbody.innerHTML = users.map((u,i)=>`<tr><td>${i+1}</td><td>${u}</td></tr>`).join('');
}

/* ==========================================
   Search & Highlight (unchanged)
   ========================================== */
function applySearchHighlight(){
  const term=(searchInput.value||'').trim().toLowerCase();
  const nodes = d3.selectAll("g.splitter");

  if(!term){
    nodes.selectAll("circle").attr("opacity",1).attr("stroke","#fff").attr("stroke-width",3);
    nodes.selectAll("text").attr("opacity",1).style("font-weight",600);
    return;
  }

  nodes.each(function(d){
    const users = d.data.users || [];
    const hit = users.some(u => String(u).toLowerCase().includes(term));
    const g = d3.select(this);
    if(hit){
      g.select("circle").attr("stroke","#ffb020").attr("stroke-width",4).attr("opacity",1);
      g.selectAll("text").attr("opacity",1).style("font-weight",700);
    } else {
      g.select("circle").attr("opacity",0.25);
      g.selectAll("text").attr("opacity",0.3);
    }
  });
}

/* ==========================================
   Downloads (unchanged)
   ========================================== */
function downloadCSV(){
  if(popupModal.style.display!=='flex') return;
  const rows=[...popupUsersTable.querySelectorAll("tr")];
  if(!rows.length) return;
  let csv='';
  rows.forEach(r=>{
    const cols=[...r.querySelectorAll("th,td")].map(c=>`"${(c.textContent||'').replace(/"/g,'""')}"`);
    csv += cols.join(",") + "\n";
  });
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'users.csv'; a.click(); URL.revokeObjectURL(url);
}
function downloadScreenshot(){
  const svg = document.querySelector("#chart svg");
  if(!svg) return alert("Nothing to save");
  const xml = (new XMLSerializer()).serializeToString(svg);
  const blob = new Blob([xml], {type:"image/svg+xml"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'merotra-tree.svg'; a.click(); URL.revokeObjectURL(url);
}

/* INIT */
loadAndRender(false);
window.addEventListener('resize', ()=> rawJson && applyFiltersAndRender());

</script>
</body>
</html>
</DOCUMENT>
