<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merotra ‚Äî PON / Splitter Table (Level Columns)</title>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- Your adv.css (you asked to use it) -->
  <link rel="stylesheet" href="adv.css">

  <!-- minimal fallback to ensure the SVG area shows if adv.css missing -->
  <style>
    :root{font-family:Inter,system-ui,Arial}
    body{margin:0;padding:0;background:linear-gradient(135deg,#f0f9ff,#e0f2fe);color:#111827;height:100vh;overflow:hidden}
    .header{display:flex;justify-content:space-between;align-items:center;padding:10px 16px;background:rgba(255,255,255,0.95);box-shadow:0 4px 20px rgba(0,0,0,0.06);position:sticky;top:0;z-index:30}
    .header-title{font-weight:800;font-size:1.1rem}
    #chart{width:100%;height:calc(100vh - 60px);overflow:hidden}
    .tooltip{position:absolute;pointer-events:none;background:rgba(15,23,42,0.9);color:#fff;padding:8px 10px;border-radius:8px;font-size:12px;opacity:0;transition:opacity .12s;z-index:60}
    .btn{background:#2563eb;color:#fff;padding:6px 12px;border-radius:999px;border:none;cursor:pointer}
  </style>
</head>
<body>

  <div class="header">
    <div>
      <div class="header-title">üåê Merotra Network ‚Äî Column Levels</div>
      <div style="font-size:12px;color:#6b7280">Window ‚Üí PON ‚Üí Level1 ‚Üí Level2 ‚Üí ... (columns)</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <button id="reloadBtn" class="btn">Reload</button>
    </div>
  </div>

  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <!-- Popup (kept minimal and compatible with your existing UI) -->
  <div id="popupModal" class="popup-backdrop" style="display:none">
    <div class="modal-content">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px">
        <div>
          <h2 id="popupTitle" style="margin:0;font-size:16px"></h2>
          <div id="popupPath" style="font-size:12px;color:#475569"></div>
        </div>
        <button id="popupClose" class="btn btn-secondary" style="height:30px">Close</button>
      </div>
      <div id="popupMeta" style="font-size:13px;color:#334155;margin-bottom:8px"></div>
      <div style="max-height:400px;overflow:auto">
        <table id="popupUsersTable" class="user-table"></table>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="btnShot" class="btn">üì∏ Screenshot</button>
        <button id="btnCsv" class="btn btn-secondary">üìä CSV</button>
      </div>
    </div>
  </div>

<script>
/* =============== CONFIG =============== */
const BOARD_URL = "https://script.google.com/macros/s/AKfycbzItUueYIqcUuCn2cDaTTrWIF0LiilUxOXhhL-4b4D9aUlEo8Ov9pasR44d6JSM3h1t/exec?mode=board";

/* =============== STATE =============== */
const tooltip = document.getElementById('tooltip');
let rawJson = null;

/* UI bindings */
document.getElementById('reloadBtn').addEventListener('click', ()=> loadAndRender(true));
document.getElementById('popupClose').addEventListener('click', ()=> document.getElementById('popupModal').style.display='none');
document.getElementById('btnCsv').addEventListener('click', downloadCSV);
document.getElementById('btnShot').addEventListener('click', downloadScreenshot);

/* =============== Helpers =============== */
function randColor() {
  // pastel-ish random
  const h = Math.floor(Math.random()*360);
  const s = 60 + Math.floor(Math.random()*20);
  const l = 45 + Math.floor(Math.random()*10);
  return `hsl(${h} ${s}% ${l}%)`;
}
function normalizeId(v){ return (v ?? "").toString().trim(); }

/* =============== Load & Render =============== */
async function loadAndRender(showToast=false) {
  try {
    setLoading(true);
    const res = await fetch(BOARD_URL);
    if(!res.ok) throw new Error('Failed fetch: ' + res.status);
    const j = await res.json();
    rawJson = j; // keep
    renderFromJson(j);
    if (showToast) console.info('Loaded board');
  } catch (err) {
    console.error(err);
    alert('Load failed: ' + (err.message || err));
  } finally {
    setLoading(false);
  }
}
function setLoading(flag){
  const btn = document.getElementById('reloadBtn');
  btn.textContent = flag ? 'Loading...' : 'Reload';
  btn.disabled = flag;
}

/* =============== Render logic (columns layout) =============== */
function renderFromJson(serverJson) {
  const chart = document.getElementById('chart');
  chart.innerHTML = ''; // clear

  if (!serverJson || !Array.isArray(serverJson.windows) || serverJson.windows.length === 0) {
    chart.innerHTML = '<div style="padding:20px;color:#6b7280">No data</div>';
    return;
  }

  // SVG + zoom/pan
  const svg = d3.select('#chart').append('svg').attr('width','100%').attr('height','100%').style('background','transparent');
  const g = svg.append('g');

  const zoom = d3.zoom().scaleExtent([0.4, 2]).on('zoom', (evt) => g.attr('transform', evt.transform));
  svg.call(zoom);

  // Layout parameters (Comfort spacing)
  const colWidth = 240;         // horizontal gap between columns
  const ponColWidth = 160;
  const nodeRadius = 12;        // circles
  const nodeVgap = 56;          // vertical gap between nodes (Comfort)
  const sectionGap = 48;        // gap between windows
  const leftPad = 20;
  const topPad = 20;

  // For each window: compute layout blocks vertically stacked
  let currentY = topPad;

  serverJson.windows.forEach(win => {
    const winName = win.window || 'Window';
    const pons = Array.isArray(win.pons) ? win.pons : [];

    // header label for window
    g.append('text')
      .attr('x', leftPad)
      .attr('y', currentY + 10)
      .text(winName)
      .attr('font-weight','700')
      .attr('font-size',14)
      .attr('fill','#0f172a');

    currentY += 28; // small header height

    // compute the vertical block for each PON. We'll stack PON blocks one below another.
    pons.forEach((ponObj, ponIndex) => {
      const ponName = ponObj.pon || 'PON';
      const levels = Array.isArray(ponObj.levels) ? ponObj.levels : [];

      // sort levels by level numeric ascending
      levels.sort((a,b)=> (a.level||0) - (b.level||0));

      // compute number of columns: 1 (Window col) + 1 (PON col) + levels.length
      const columns = 2 + levels.length;
      // For vertical sizing: get max number of splitters in any column for this PON
      const levelCounts = levels.map(l => (l.splitters && l.splitters.length) || 0);
      // PON column has 1 node
      const maxNodes = Math.max(1, ...levelCounts);

      // block height
      const blockHeight = Math.max( (maxNodes * nodeVgap) + 40, 90);

      // compute x positions for columns
      const baseX = leftPad;
      const winColX = baseX;
      const ponColX = winColX + colWidth; // PON sits at colWidth from window
      const levelStartX = ponColX + ponColWidth; // subsequent levels start here
      // level i column x = levelStartX + (i-1)*colWidth

      const blockY = currentY;
      const centerY = blockY + blockHeight/2;

      // DRAW Window node (as text only, not circle) leftmost
      g.append('text')
        .attr('x', winColX)
        .attr('y', centerY)
        .text(winName)
        .attr('font-size',12)
        .attr('fill','#0f172a');

      // DRAW PON node as circle + label
      const ponNodeX = ponColX;
      const ponNodeY = centerY;
      g.append('circle')
        .attr('cx', ponNodeX)
        .attr('cy', ponNodeY)
        .attr('r', nodeRadius+4)
        .attr('fill','#0f766e')
        .attr('stroke','#fff')
        .attr('stroke-width',2);

      g.append('text')
        .attr('x', ponNodeX + nodeRadius + 8)
        .attr('y', ponNodeY + 4)
        .text(ponName + (ponObj.totalUsers ? ` (${ponObj.totalUsers})` : ''))
        .attr('font-size',12)
        .attr('fill','#0f172a');

      // For each level, compute vertical placement of splitters (order = sheet order: as provided)
      const levelNodesPositions = []; // array per level: [{splitter, x,y}]
      levels.forEach((lvl, li) => {
        const splitters = Array.isArray(lvl.splitters) ? lvl.splitters : [];
        const colX = levelStartX + li * colWidth;
        // vertical start such that splitters centered in block
        const count = Math.max(1, splitters.length);
        const totalHeight = (count - 1) * nodeVgap;
        let startY = centerY - (totalHeight / 2);

        const positions = [];
        for (let si=0; si<splitters.length; si++){
          const s = splitters[si];
          const x = colX;
          const y = startY + si * nodeVgap;
          positions.push({ s, x, y });
        }
        levelNodesPositions.push(positions);
      });

      // DRAW splitters (as circles + label) column by column
      levelNodesPositions.forEach((posArr, li) => {
        posArr.forEach(p => {
          const s = p.s;
          // circle
          g.append('circle')
            .attr('cx', p.x)
            .attr('cy', p.y)
            .attr('r', nodeRadius)
            .attr('fill', '#10b981')
            .attr('stroke','#fff')
            .attr('stroke-width',2)
            .style('cursor','pointer')
            .on('mousemove', (event) => showTooltip(event, s, p.x, p.y))
            .on('mouseout', ()=> hideTooltip())
            .on('click', ()=> openPopup(s, ponName, winName));

          // label to the right
          const label = (s.type ? `${s.type}` : '') + (s.total ? ` (${s.total})` : '');
          g.append('text')
            .attr('x', p.x + nodeRadius + 8)
            .attr('y', p.y + 4)
            .text(label)
            .attr('font-size',11)
            .attr('fill','#0f172a');

          // small thin recordId label under
          if (s.recordId) {
            g.append('text')
              .attr('x', p.x)
              .attr('y', p.y + nodeRadius + 14)
              .text(s.recordId)
              .attr('font-size',10)
              .attr('fill','#64748b')
              .attr('text-anchor','middle');
          }
        });
      });

      // DRAW LINKS:
      // 1) PON -> Level1: always connect PON to all level1 splitters (even if they have zero users)
      if (levelNodesPositions.length >= 1) {
        const lvl1 = levelNodesPositions[0];
        lvl1.forEach(child => {
          const path = linkPath({x:ponNodeX, y:ponNodeY}, {x:child.x, y:child.y});
          g.append('path')
            .attr('d', path)
            .attr('fill','none')
            .attr('stroke', randColor())
            .attr('stroke-width', 2)
            .attr('stroke-opacity', 0.9)
            .attr('class','link');
        });
      }

      // 2) levelN -> levelN+1: connect a child to the FIRST parent in previous level that shares users
      for (let li = 0; li < levelNodesPositions.length - 1; li++) {
        const parents = levelNodesPositions[li];
        const children = levelNodesPositions[li+1];

        // precompute parent users sets
        const parentSets = parents.map(p => {
          const arr = Array.isArray(p.s.users) ? p.s.users.map(normalizeId) : [];
          return new Set(arr);
        });

        children.forEach(child => {
          const childSet = new Set((Array.isArray(child.s.users) ? child.s.users.map(normalizeId) : []));
          let linked = false;
          for (let pi = 0; pi < parents.length; pi++) {
            const parentSet = parentSets[pi];
            // check intersection
            let common = false;
            for (const u of childSet) {
              if (parentSet.has(u)) { common = true; break; }
            }
            if (common) {
              // connect parent (parents[pi]) -> child
              const pnode = parents[pi];
              const path = linkPath({x:pnode.x, y:pnode.y}, {x:child.x, y:child.y});
              g.append('path')
                .attr('d', path)
                .attr('fill','none')
                .attr('stroke', randColor())
                .attr('stroke-width', 2)
                .attr('stroke-opacity', 0.9)
                .attr('class','link');
              linked = true;
              break; // only to first matching parent
            }
          }
          // if no parent matched: do NOT draw link (per your rule)
        });
      }

      // advance Y for next PON block
      currentY += blockHeight + 12; // small gap between pon blocks
    }); // pons loop

    // after all pons in a window, add some space
    currentY += sectionGap;
  }); // windows loop

  // enable pan/zoom to fit initial view
  fitToView(svg.node(), g.node());
}

/* helper to produce a smooth horizontal-ish path between two points */
function linkPath(src, dst) {
  const midX = src.x + (dst.x - src.x) * 0.5;
  // make slight vertical curvature
  return `M ${src.x} ${src.y} C ${midX} ${src.y} ${midX} ${dst.y} ${dst.x} ${dst.y}`;
}

/* fit to view ‚Äî scale/translate to show all */
function fitToView(svgNode, gNode) {
  try {
    const bbox = gNode.getBBox();
    const svgW = svgNode.clientWidth || (window.innerWidth);
    const svgH = svgNode.clientHeight || (window.innerHeight - 60);
    if (!isFinite(bbox.width) || bbox.width === 0) return;
    const scale = Math.min(1.0, Math.min(svgW / (bbox.width + 100), svgH / (bbox.height + 120)));
    const tx = -bbox.x * scale + 20;
    const ty = -bbox.y * scale + 20;
    d3.select(svgNode).transition().duration(500).call(
      d3.zoom().transform,
      d3.zoomIdentity.translate(tx, ty).scale(scale)
    );
  } catch (e) {
    // ignore
  }
}

/* =============== Tooltip & Popup =============== */
function showTooltip(event, splitterObj, x, y) {
  const t = tooltip;
  t.style.left = (event.pageX + 12) + 'px';
  t.style.top = (event.pageY + 8) + 'px';
  const users = Array.isArray(splitterObj.users) ? splitterObj.users.length : 0;
  t.innerHTML = `<strong>${splitterObj.type || splitterObj.recordId || 'Splitter'}</strong><br/>Record: ${splitterObj.recordId||'-'}<br/>Users: <strong>${users}</strong>`;
  t.style.opacity = 1;
}
function hideTooltip() { tooltip.style.opacity = 0; }

function openPopup(splitterObj, ponName, winName) {
  const modal = document.getElementById('popupModal');
  document.getElementById('popupTitle').textContent = `${splitterObj.type || 'Splitter'} ‚Äî Users`;
  document.getElementById('popupPath').textContent = `${winName} ‚Üí ${ponName} ‚Üí ${splitterObj.recordId || ''}`;
  document.getElementById('popupMeta').innerHTML = `<div><strong>Total users:</strong> ${splitterObj.total || (splitterObj.users ? splitterObj.users.length : 0)}</div>`;
  // build users table
  const tbl = document.getElementById('popupUsersTable');
  const users = Array.isArray(splitterObj.users) ? splitterObj.users : [];
  tbl.innerHTML = `<thead><tr><th>Sr</th><th>User ID</th></tr></thead><tbody>${users.map((u,i)=>`<tr><td>${i+1}</td><td>${u}</td></tr>`).join('')}</tbody>`;
  modal.style.display = 'flex';
}

/* =============== Downloads =============== */
function downloadCSV(){
  const modal = document.getElementById('popupModal');
  if (modal.style.display === 'none' || modal.style.display === '') return;
  const tbl = document.getElementById('popupUsersTable');
  if (!tbl) return;
  const rows = Array.from(tbl.querySelectorAll('tr'));
  if (!rows.length) return;
  let csv = '';
  rows.forEach((r, idx) => {
    const cols = Array.from(r.querySelectorAll('th,td')).map(c => `"${(c.textContent||'').replace(/"/g,'""')}"`);
    csv += cols.join(',') + '\n';
  });
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'splitter-users.csv'; a.click();
  URL.revokeObjectURL(url);
}

function downloadScreenshot(){
  // simple screenshot of #chart using SVG serialization
  const svg = document.querySelector('#chart svg');
  if (!svg) return alert('No chart to screenshot');
  const serializer = new XMLSerializer();
  const source = serializer.serializeToString(svg);
  const svgBlob = new Blob([source], {type: 'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(svgBlob);
  const a = document.createElement('a');
  a.href = url; a.download = 'merotra-tree.svg'; a.click();
  URL.revokeObjectURL(url);
}

/* =============== INIT =============== */
loadAndRender(false);
window.addEventListener('resize', ()=> { if (rawJson) renderFromJson(rawJson); });

</script>
</body>
</html>
