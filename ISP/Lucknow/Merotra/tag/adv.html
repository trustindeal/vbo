<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merotra ‚Äî PON / Splitter Tree</title>

  <!-- D3 & Tailwind -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Screenshot lib -->
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{font-family:Inter,system-ui,Arial}
    body{margin:0;padding:12px;background:#f8fafc;color:#0f172a}
    .header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
    .header-title{font-weight:700;font-size:18px}
    .header-sub{font-size:12px;color:#475569}
    .btn{background:#0f172a;color:white;padding:6px 10px;border-radius:6px;border:none;cursor:pointer}
    .btn-secondary{background:#94a3b8}
    #chart{width:100%;height:74vh;border-radius:8px;background:#fff;padding:8px;box-shadow:0 6px 20px rgba(2,6,23,0.06)}
    .tooltip{position:absolute;pointer-events:none;background:#111827;color:#fff;padding:6px 8px;border-radius:6px;font-size:12px;opacity:0;transition:opacity .12s}
    /* popup */
    .popup-backdrop{display:none;position:fixed;inset:0;background:rgba(2,6,23,0.5);align-items:center;justify-content:center;padding:18px}
    .modal-content{background:#fff;padding:14px;border-radius:8px;max-width:760px;width:100%;box-shadow:0 8px 30px rgba(2,6,23,0.12)}
    .user-table{width:100%;border-collapse:collapse;font-size:13px}
    .user-table th,.user-table td{border-bottom:1px solid #e6edf3;padding:6px;text-align:left}
    .controls-backdrop{display:none;position:fixed;inset:0;background:rgba(2,6,23,0.35);align-items:center;justify-content:center;padding:18px}
    .controls-modal{background:#fff;padding:12px;border-radius:8px;width:360px;box-shadow:0 8px 30px rgba(2,6,23,0.12)}
    .checkbox-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:6px;max-height:220px;overflow:auto;padding:6px}
    .checkbox-item{font-size:13px}
    .link-btn{margin-right:8px;display:inline-block;padding:6px;border-radius:6px;background:#eef2ff;color:#1e3a8a;cursor:pointer;font-size:12px}
  </style>
</head>
<body>

  <div class="header">
    <div>
      <div class="header-title">üåê Merotra Network Tree</div>
      <div class="header-sub">Window ‚Üí PON ‚Üí Splitters ‚Üí Users (+ Untagged)</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <button id="controlsBtn" class="btn btn-secondary">Filters</button>
      <button id="reloadBtn" class="btn">Reload</button>
    </div>
  </div>

  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <!-- POPUP -->
  <div id="popupModal" class="popup-backdrop">
    <div class="modal-content">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px">
        <div>
          <h2 id="popupTitle" style="margin:0;font-size:16px"></h2>
          <div id="popupPath" style="font-size:12px;color:#475569"></div>
        </div>
        <button id="popupClose" class="btn btn-secondary" style="height:30px">Close</button>
      </div>

      <div id="popupMeta" style="font-size:13px;color:#334155;margin-bottom:8px"></div>
      <div id="popupLinks" style="margin-bottom:8px"></div>

      <h3 style="margin:8px 0 6px;font-size:14px">Users</h3>
      <div style="max-height:300px;overflow:auto">
        <table id="popupUsersTable" class="user-table"></table>
      </div>

      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="btnShot" class="btn">üì∏ Screenshot</button>
        <button id="btnCsv" class="btn btn-secondary">üìä CSV</button>
      </div>
    </div>
  </div>

  <!-- CONTROLS -->
  <div id="controlsModal" class="controls-backdrop">
    <div class="controls-modal">
      <h3 style="margin:0 0 8px">Filters</h3>

      <div style="margin-bottom:10px">
        <div style="font-weight:600;font-size:13px">Windows</div>
        <div id="windowFilters" class="checkbox-grid"></div>
        <div style="text-align:center;margin-top:6px;font-size:12px;color:#64748b">
          <a href="#" onclick="selectAll('window');return false">Select All</a> |
          <a href="#" onclick="deselectAll('window');return false">Deselect All</a>
        </div>
      </div>

      <div style="margin-bottom:10px">
        <div style="font-weight:600;font-size:13px">PONs</div>
        <div id="ponFilters" class="checkbox-grid"></div>
        <div style="text-align:center;margin-top:6px;font-size:12px;color:#64748b">
          <a href="#" onclick="selectAll('pon');return false">Select All</a> |
          <a href="#" onclick="deselectAll('pon');return false">Deselect All</a>
        </div>
      </div>

      <div style="display:flex;gap:8px">
        <button id="applyFiltersBtn" class="btn" style="flex:1">Apply</button>
        <button id="controlsClose" class="btn btn-secondary" style="flex:1">Close</button>
      </div>
    </div>
  </div>

<script>
  // -------------- CONFIG --------------
  const BOARD_URL = "https://script.google.com/macros/s/AKfycbzItUueYIqcUuCn2cDaTTrWIF0LiilUxOXhhL-4b4D9aUlEo8Ov9pasR44d6JSM3h1t/exec?mode=board";

  // statusMaps kept (empty) ‚Äî we removed TheMaster lookups
  const statusMaps = {}; // keep for popup usage, can be filled later if needed

  // -------------- STATE --------------
  const tooltip = document.getElementById("tooltip");
  const popupModal = document.getElementById("popupModal");
  const controlsModal = document.getElementById("controlsModal");
  const popupTitleEl = document.getElementById("popupTitle");
  const popupPathEl  = document.getElementById("popupPath");
  const popupMetaEl  = document.getElementById("popupMeta");
  const popupLinksEl = document.getElementById("popupLinks");
  const popupUsersTbl = document.getElementById("popupUsersTable");

  let rawBoard = {};    // board shaped object used by buildHierarchy
  let serverSummary = null;
  let currentTreeData = null;

  let filters = { windows: [], pons: [] };
  let currentPopupRows = [];

  // -------------- HELPERS --------------
  function normalizeId(v){ return (v ?? "").toString().trim().replace(/\s+/g,'').toLowerCase(); }

  // Transform server JSON to board: { pon: { window: { splitName: { users:[{id:...}], tag, location, jcPic, polePic }}}}
  function transformServerToBoard(serverJson) {
    const board = {};
    if (!serverJson || !Array.isArray(serverJson.windows)) return board;
    serverJson.windows.forEach(win => {
      const winName = win.window;
      (win.pons || []).forEach(pon => {
        const ponName = pon.pon;
        if (!board[ponName]) board[ponName] = {};
        if (!board[ponName][winName]) board[ponName][winName] = {};
        (pon.splitters || []).forEach(split => {
          const usersObjArray = (split.users || []).map(u => {
            if (typeof u === "object" && u !== null) return { id: u.id ?? "" };
            return { id: String(u) };
          });
          board[ponName][winName][split.name] = {
            users: usersObjArray,
            tag: split.tag || "",
            location: split.location || "",
            jcPic: split.jcPic || "",
            polePic: split.polePic || ""
          };
        });
      });
    });
    return board;
  }

  // -------------- INIT / UI bindings --------------
  document.getElementById("reloadBtn").addEventListener("click", ()=> loadAll(true));
  document.getElementById("controlsBtn").addEventListener("click", ()=> { controlsModal.style.display='flex'; });
  document.getElementById("controlsClose").addEventListener("click", ()=> { controlsModal.style.display='none'; });
  document.getElementById("popupClose").addEventListener("click", ()=> { popupModal.style.display='none'; });
  document.getElementById("applyFiltersBtn").addEventListener("click", applyFiltersFromUI);
  document.getElementById("btnShot").addEventListener("click", downloadScreenshot);
  document.getElementById("btnCsv").addEventListener("click", downloadCSV);

  window.addEventListener("resize", ()=> { if (currentTreeData) drawTree(currentTreeData); });

  // page load
  loadAll(false);

  async function loadAll(showToast) {
    try {
      setLoading(true);
      const res = await fetch(BOARD_URL);
      if (!res.ok) throw new Error("Board API fetch failed: "+res.status);
      const serverJson = await res.json();
      serverSummary = serverJson.summary || null;

      rawBoard = transformServerToBoard(serverJson);

      setupFiltersFromBoard();
      const filtered = filterBoard(rawBoard, filters);
      const treeData = buildHierarchy(filtered);
      currentTreeData = treeData;
      drawTree(treeData);

      if (serverSummary && showToast) {
        console.info("Processed:", serverSummary.processedRows, "Skipped:", serverSummary.skippedRows);
      }
    } catch (err) {
      console.error(err);
      alert("Error loading board: " + (err.message || err));
    } finally {
      setLoading(false);
    }
  }

  function setLoading(flag){
    const btn = document.getElementById("reloadBtn");
    btn.textContent = flag ? "Loading..." : "Reload";
    btn.disabled = flag;
  }

  // -------------- FILTERS --------------
  function setupFiltersFromBoard(){
    const windowSet = new Set();
    const ponSet = new Set();

    Object.entries(rawBoard).forEach(([pon, winObj]) => {
      ponSet.add(pon);
      Object.keys(winObj || {}).forEach(w => windowSet.add(w));
    });

    filters.windows = Array.from(windowSet);
    filters.pons = Array.from(ponSet);

    const winDiv = document.getElementById("windowFilters");
    const ponDiv = document.getElementById("ponFilters");
    winDiv.innerHTML = ""; ponDiv.innerHTML = "";

    Array.from(windowSet).sort().forEach(w => {
      const el = document.createElement("div"); el.className="checkbox-item";
      el.innerHTML = `<label><input type="checkbox" value="${w}" checked> <span>${w}</span></label>`;
      winDiv.appendChild(el);
    });

    Array.from(ponSet).sort().forEach(p => {
      const el = document.createElement("div"); el.className="checkbox-item";
      el.innerHTML = `<label><input type="checkbox" value="${p}" checked> <span>${p}</span></label>`;
      ponDiv.appendChild(el);
    });
  }

  function selectAll(type){
    document.querySelectorAll(`#${type}Filters input[type="checkbox"]`).forEach(ch=>ch.checked=true);
  }
  function deselectAll(type){
    document.querySelectorAll(`#${type}Filters input[type="checkbox"]`).forEach(ch=>ch.checked=false);
  }

  function applyFiltersFromUI(){
    filters.windows = Array.from(document.querySelectorAll("#windowFilters input:checked")).map(i => i.value);
    filters.pons = Array.from(document.querySelectorAll("#ponFilters input:checked")).map(i => i.value);
    controlsModal.style.display='none';
    const filtered = filterBoard(rawBoard, filters);
    const treeData = buildHierarchy(filtered);
    currentTreeData = treeData;
    drawTree(treeData);
  }

  function filterBoard(board, filters){
    const out = {};
    Object.entries(board).forEach(([pon, winObj]) => {
      if (!filters.pons.includes(pon)) return;
      const newWin = {};
      Object.entries(winObj || {}).forEach(([win, splits]) => {
        if (!filters.windows.includes(win)) return;
        newWin[win] = splits;
      });
      if (Object.keys(newWin).length) out[pon] = newWin;
    });
    return out;
  }

  // -------------- parsePon (sorting) --------------
  function parsePon(pon) {
    const m = (pon || "").match(/O(\d+)I(\d+)P(\d+)/i);
    if (!m) return { olt:9999, ip:9999, port:9999 };
    return { olt:+m[1], ip:+m[2], port:+m[3] };
  }

  // -------------- BUILD HIERARCHY (for D3) --------------
  // Input board shape: { pon: { window: { splitName: { users:[{id:...}], tag, location, jcPic, polePic }}}}
  // improved buildHierarchy ‚Äî preserves all splitters and attaches sensibly
function buildHierarchy(board) {
  const root = { nodeType: "root", name: "üåê Merotra Network", children: [] };
  const windowMap = {};

  // sort PONs
  const sortedPons = Object.entries(board).sort(([a],[b])=>{
    const A = parsePon(a), B = parsePon(b);
    if (A.olt !== B.olt) return A.olt - B.olt;
    if (A.ip !== B.ip) return A.ip - B.ip;
    return A.port - B.port;
  });

  sortedPons.forEach(([pon, winObj])=>{
    Object.entries(winObj || {}).forEach(([winName, splitters])=>{
      if (!windowMap[winName]) {
        windowMap[winName] = { nodeType:"window", name: "ü™ü " + winName, rawWindow: winName, children: [] };
        root.children.push(windowMap[winName]);
      }
      const winNode = windowMap[winName];

      const ponNode = { nodeType:"pon", name:"üîå " + pon, rawPon: pon, window: winName, children: [], total:0 };

      // build list of splitters (KEEP even if users empty so structure shows)
      const entries = Object.entries(splitters || {}).map(([splitName, info])=>{
        const userIds = (info.users || []).map(u => (typeof u === 'object' && u !== null) ? (u.id ?? "") : String(u)).filter(Boolean);
        return {
          splitName,
          info,
          userIds,
          usersSet: new Set(userIds),
          userCount: userIds.length
        };
      });

      if (entries.length === 0) {
        winNode.children.push(ponNode);
        return;
      }

      // sort by userCount desc so largest becomes primary candidate
      entries.sort((a,b)=> b.userCount - a.userCount);

      // convert to working nodes
      const nodes = entries.map(e => ({
        nodeType: "splitter",
        name: e.splitName,
        rawSplitter: e.splitName,
        splitterName: e.splitName,
        pon,
        window: winName,
        users: Array.from(e.usersSet),
        usersSet: new Set(e.usersSet),
        total: e.userCount,
        tag: e.info.tag || "",
        location: e.info.location || "",
        jcPic: e.info.jcPic || "",
        polePic: e.info.polePic || "",
        children: []
      }));

      const roots = [];

      // helper: intersection size
      function intersectSize(aSet, bSet) {
        let c = 0;
        for (const x of aSet) if (bSet.has(x)) c++;
        return c;
      }

      // place each node: try subset first, then best-overlap parent, else make new root
      for (let i=0; i<nodes.length; i++){
        const node = nodes[i];

        // try to attach as subset to any existing root (prefer earliest root where subset holds)
        let attached = false;
        for (const r of roots) {
          if (isSubset(node.usersSet, r.usersSet)) {
            r.children.push(node);
            // merge: add any users missing in parent so parent counts remain >= children
            for (const u of node.usersSet) r.usersSet.add(u);
            attached = true;
            break;
          }
        }
        if (attached) continue;

        // if not subset: find root with maximum overlap ( >0 )
        let bestParent = null;
        let bestOverlap = 0;
        for (const r of roots) {
          const ov = intersectSize(node.usersSet, r.usersSet);
          if (ov > bestOverlap) { bestOverlap = ov; bestParent = r; }
        }
        if (bestParent && bestOverlap > 0) {
          // attach to bestParent (not always roots[0])
          bestParent.children.push(node);
          // ensure parent absorbs child's non-overlapping users (rule 4)
          for (const u of node.usersSet) if (!bestParent.usersSet.has(u)) bestParent.usersSet.add(u);
          attached = true;
        }

        if (!attached) {
          // new sibling root under PON
          roots.push(node);
        }
      }

      // After placement, ensure all parents' sets include children users (propagate up)
      function propagateUp(n) {
        n.children.forEach(ch => {
          propagateUp(ch);
          for (const u of ch.users) n.usersSet.add(u);
        });
      }
      roots.forEach(r => propagateUp(r));

      // Add UNTAGGED nodes where a parent has some users not covered by children
      function addUntagged(node) {
        if (!node.children || node.children.length === 0) return;
        // compute covered
        const covered = new Set();
        node.children.forEach(c => {
          addUntagged(c);
          (c.users || []).forEach(u => covered.add(u));
        });
        const own = (node.users || []).filter(u => !covered.has(u));
        if (own.length > 0) {
          node.children.push({
            nodeType: "untagged",
            name: `Other / Untagged (${own.length})`,
            users: own,
            total: own.length,
            children: []
          });
        }
      }
      roots.forEach(r => addUntagged(r));

      // cleanup: convert usersSet -> users & totals
      function cleanup(node) {
        if (node.usersSet) {
          node.users = Array.from(node.usersSet);
          node.total = node.users.length;
          delete node.usersSet;
        } else {
          node.total = node.total ?? (Array.isArray(node.users) ? node.users.length : 0);
        }
        node.children.forEach(cleanup);
      }
      roots.forEach(cleanup);

      // pon total = unique union of all roots users
      const union = new Set();
      roots.forEach(r => {
        (r.users || []).forEach(u => union.add(u));
      });

      ponNode.total = union.size;
      ponNode.children = roots;
      winNode.children.push(ponNode);
    });
  });

  return root;
}

  // -------------- DRAW TREE (D3) --------------
  function drawTree(data) {
    d3.select("#chart").select("svg").remove();
    const width = document.getElementById("chart").clientWidth || Math.max(window.innerWidth-40,800);
    const height = Math.max(window.innerHeight - 220, 420);

    const dx = 80;
    const dy = width > 900 ? 260 : 200;
    const treeLayout = d3.tree().nodeSize([dx, dy]);
    const root = d3.hierarchy(data, d => d.children || []);
    treeLayout(root);

    const svgRoot = d3.select("#chart").append("svg").attr("width", width).attr("height", height);
    const zoom = d3.zoom().scaleExtent([0.4, 3]).on("zoom", (event) => g.attr("transform", event.transform));
    svgRoot.call(zoom);

    const g = svgRoot.append("g").attr("transform", "translate(80,60)");

    // links
    g.selectAll(".link").data(root.links()).enter().append("path")
      .attr("class","link")
      .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x))
      .attr("fill","none").attr("stroke","#94a3b8").attr("stroke-width",2);

    // nodes
    const node = g.selectAll(".node").data(root.descendants()).enter().append("g")
      .attr("class","node").attr("transform", d => `translate(${d.y},${d.x})`);

    // circles by type
    node.filter(d => d.data.nodeType === "root")
      .append("circle").attr("r",24).attr("fill","#1e3a8a").attr("stroke","#fff").attr("stroke-width",3);

    node.filter(d => d.data.nodeType === "window")
      .append("circle").attr("r",20).attr("fill","#1d4ed8").attr("stroke","#fff").attr("stroke-width",3);

    node.filter(d => d.data.nodeType === "pon")
      .append("circle").attr("r",18).attr("fill","#0f766e").attr("stroke","#fff").attr("stroke-width",3);

    node.filter(d => (d.data.nodeType === "splitter" || d.data.nodeType === "untagged"))
      .append("circle").attr("r", d => d.data.nodeType === "splitter" ? 14 : 10)
      .attr("fill", d => d.data.nodeType === "untagged" ? "#6b7280" : (d.data.total > 0 ? "#10b981" : "#6b7280"))
      .attr("stroke","#fff").attr("stroke-width",2);

    // text
    node.append("text")
      .attr("dy","0.32em")
      .attr("x", d => d.children && d.depth>0 ? -20 : 20)
      .attr("text-anchor", d => d.children && d.depth>0 ? "end" : "start")
      .style("font-size", d => d.data.nodeType === "root" ? "14px" : (d.data.nodeType === "window" ? "13px" : (d.data.nodeType === "pon" ? "12px" : "11px")))
      .style("font-weight", d => (d.data.nodeType === "root" || d.data.nodeType === "window") ? 700 : 500)
      .text(d => {
        // show count for pon and splitters
        if (d.data.nodeType === "pon") return `${d.data.name} (${d.data.total || 0})`;
        if (d.data.nodeType === "splitter") return `${d.data.name} (${d.data.total || (d.data.users ? d.data.users.length : 0)})`;
        if (d.data.nodeType === "untagged") return d.data.name;
        return d.data.name;
      });

    // interactions
    node.on("mousemove", handleMouseOver)
        .on("mouseout", ()=> tooltip.style.opacity = 0)
        .on("click", handleNodeClick);

    // fit to view
    fitToView(svgRoot, g, zoom);
  }

  function fitToView(svgRoot, g, zoom) {
    const chart = document.getElementById("chart");
    const bounds = g.node().getBBox();
    const fullWidth = chart.clientWidth;
    const fullHeight = chart.clientHeight;
    const widthScale = fullWidth / (bounds.width + 160);
    const heightScale = fullHeight / (bounds.height + 160);
    const scale = Math.min(2, Math.max(0.4, Math.min(widthScale, heightScale)));
    const tx = -(bounds.x)*scale + 40;
    const ty = -(bounds.y)*scale + 40;
    svgRoot.transition().duration(600).call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(scale));
  }

  // -------------- TOOLTIP & POPUP --------------
  function handleMouseOver(event, d) {
    const data = d.data;
    let html = `<strong>${data.name}</strong><br/>`;
    if (data.nodeType === "window") html += `Window`;
    else if (data.nodeType === "pon") html += `PON: ${data.rawPon}<br/>Total users: ${data.total || 0}`;
    else if (data.nodeType === "splitter" || data.nodeType === "untagged") {
      html += `Window: ${data.window}<br/>PON: ${data.pon || data.rawPon || ""}<br/>Users: <strong>${data.total || (data.users ? data.users.length : 0)}</strong>`;
      if (data.tag) html += `<br/>Tag: ${data.tag}`;
    }
    tooltip.innerHTML = html;
    tooltip.style.left = (event.pageX + 12) + "px";
    tooltip.style.top  = (event.pageY + 8) + "px";
    tooltip.style.opacity = 1;
  }

  function handleNodeClick(event, d) {
    const data = d.data;
    if (!(data.nodeType === "splitter" || data.nodeType === "untagged")) return;

    const total = data.total || (data.users ? data.users.length : 0);
    popupTitleEl.textContent = data.nodeType === "untagged" ? `‚¨ú Untagged users (${total})` : `${data.name} ‚Äî Users`;
    popupPathEl.textContent = `${data.window || ""} ‚Üí ${data.pon || data.rawPon || ""} ‚Üí ${data.name}`;
    popupMetaEl.innerHTML = `<div><strong>Total users:</strong> ${total}</div><div><strong>Tag:</strong> ${data.tag || "-"}</div>`;

    let linksHtml = "";
    if (data.location) linksHtml += `<span class="link-btn" onclick="openLink('${data.location}')">üìç Location</span>`;
    if (data.jcPic) linksHtml += `<span class="link-btn" onclick="openLink('${data.jcPic}')">üì∏ JC Pic</span>`;
    if (data.polePic) linksHtml += `<span class="link-btn" onclick="openLink('${data.polePic}')">ü™µ Pole Pic</span>`;
    popupLinksEl.innerHTML = linksHtml || "";

    buildUserTable(data);
    popupModal.style.display = 'flex';
  }

  function buildUserTable(data) {
    const rawUsers = data.users || [];
    const users = rawUsers.map(u => (typeof u === 'object' && u !== null) ? (u.id ?? "") : String(u));
    popupUsersTbl.innerHTML = `
      <thead>
        <tr><th style="width:36px">Sr</th><th>User ID</th><th>Name</th><th>Number</th><th>Location</th><th>Status</th></tr>
      </thead>
      <tbody></tbody>
    `;
    const tbody = popupUsersTbl.querySelector("tbody");
    currentPopupRows = [];

    users.forEach((rawId, idx) => {
      const normId = normalizeId(rawId);
      const dbRow = statusMaps[normId] || {}; // empty unless you populate statusMaps later
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${idx+1}</td><td>${rawId}</td><td>${dbRow.name||""}</td><td>${dbRow.number||""}</td><td>${dbRow.location||""}</td><td>${dbRow.status||""}</td>`;
      tbody.appendChild(tr);
      currentPopupRows.push({ sr: idx+1, id: rawId, name: dbRow.name||"", number: dbRow.number||"", location: dbRow.location||"", status: dbRow.status||"" });
    });
  }

  function openLink(url){ if (url) window.open(url, "_blank"); }

  // -------------- DOWNLOADS --------------
  function downloadScreenshot(){
    const modalContent = document.querySelector("#popupModal .modal-content");
    if (!modalContent) return;
    html2canvas(modalContent).then(canvas=>{
      const link = document.createElement("a");
      const today = new Date().toISOString().slice(0,10);
      link.download = `merotra-users-${today}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    });
  }

  function downloadCSV(){
    if (!currentPopupRows.length) return;
    const header = ["Sr","User ID","Name","Number","Location","Status"];
    const lines = [header.join(",")];
    currentPopupRows.forEach(r=>{
      const row = [
        r.sr,
        `"${r.id}"`,
        `"${(r.name||"").replace(/"/g,'""')}"`,
        `"${(r.number||"").replace(/"/g,'""')}"`,
        `"${(r.location||"").replace(/"/g,'""')}"`,
        `"${(r.status||"").replace(/"/g,'""')}"`
      ];
      lines.push(row.join(","));
    });
    const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    const today = new Date().toISOString().slice(0,10);
    link.href = url; link.download = `merotra-users-${today}.csv`; link.click();
    URL.revokeObjectURL(url);
  }

</script>
</body>
</html>
