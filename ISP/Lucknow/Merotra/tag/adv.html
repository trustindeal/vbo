<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üåê Merotra ‚Äî PON / Splitter Tree</title>

  <!-- D3 & Tailwind -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Screenshot lib -->
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

  <!-- Fonts + CSS -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="adv.css">
</head>
<body>

  <!-- HEADER -->
  <div class="header">
    <div>
      <div class="header-title">
        <span>üåê Merotra Network Tree</span>
      </div>
      <div class="header-sub">Window ‚Üí PON ‚Üí Splitters ‚Üí Users (+ Untagged branch)</div>
    </div>
    <div class="flex items-center gap-2">
      <button id="controlsBtn" class="btn btn-secondary">Filters</button>
      <button id="reloadBtn" class="btn">Reload</button>
    </div>
  </div>

  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <!-- POPUP: Splitter / Untagged -->
  <div id="popupModal" class="popup-backdrop">
    <div class="modal-content">
      <div class="flex justify-between items-start mb-2">
        <div>
          <h2 id="popupTitle" class="text-lg font-bold mb-1"></h2>
          <div id="popupPath" class="text-xs text-gray-500"></div>
        </div>
        <button id="popupClose" class="btn btn-secondary text-xs px-2 py-1">Close</button>
      </div>

      <div class="text-xs text-gray-600 mb-2 space-y-1" id="popupMeta">
        <!-- Filled by JS -->
      </div>

      <div class="mb-2 text-xs" id="popupLinks">
        <!-- location / JC / pole -->
      </div>

      <h3 class="text-sm font-semibold mt-3 mb-1">Users</h3>
      <div class="user-table-container">
        <table id="popupUsersTable" class="user-table">
          <!-- Filled by JS -->
        </table>
      </div>

      <div class="download-btns">
        <button id="btnShot" class="download-btn btn-shot">üì∏ Screenshot</button>
        <button id="btnCsv" class="download-btn btn-csv">üìä CSV</button>
      </div>
    </div>
  </div>

  <!-- CONTROLS MODAL -->
  <div id="controlsModal" class="controls-backdrop">
    <div class="controls-modal">
      <h2 class="text-base font-bold mb-3">Filters & View</h2>

      <div class="mb-3">
        <div class="filter-title">Windows</div>
        <div id="windowFilters" class="checkbox-grid"></div>
        <div class="mt-1 text-center">
          <span class="select-all" onclick="selectAll('window')">Select All</span> |
          <span class="select-all" onclick="deselectAll('window')">Deselect All</span>
        </div>
      </div>

      <div class="mb-3">
        <div class="filter-title">PONs</div>
        <div id="ponFilters" class="checkbox-grid pon-grid"></div>
        <div class="mt-1 text-center">
          <span class="select-all" onclick="selectAll('pon')">Select All</span> |
          <span class="select-all" onclick="deselectAll('pon')">Deselect All</span>
        </div>
      </div>

      <button id="applyFiltersBtn" class="btn w-full mt-1">Apply Filters</button>
      <button id="controlsClose" class="btn btn-secondary w-full mt-2">Close</button>
    </div>
  </div>

  <script>
    // -------------------- CONFIG --------------------

    // Same API_BASE (board/data) jo aap pehle use kar rahe the
    const API_BASE = "https://script.googleusercontent.com/macros/echo?user_content_key=AehSKLgWoNwxGB6cZdAHMQqMmh9R-uY6NTk56cJT4JE1BQNi4u_VU4-hjmrbr1SjmTu7SY_lFxNiNETKTS5sRHKD8Hrr4Uh1GYAGlmrDRjyfoTGetW786IOjsnIqah5_cVjZEPkbGsnQjKY7GGHpErfeZpXItjvb71iz-b-cH5L7ISw_DqTfJBdn8ieDC99pCWOyZv9mzZkpzmxeJVOfxWLnwvj9QMktqCF3PG6871DG6eAotb-vcbTj5XnAw-YLofKgoccAohOSpCB_gn-XWlI1EwQDtLoohgONwIdSu50jkShz1nQ9Cx4&lib=MM9jfESS3VUQ4bogWcHsjBa_bifldmWHw";

    const BOARD_URL = API_BASE + "&mode=board";

    // TheMaster DB URLs (token = abcd1234)
    const MASTER_API_MEROTRA = "https://script.google.com/macros/s/AKfycbwEjBWnBLw5S45MdR0yq4Kvuuy5uFC_8a8u0syGpW9Kyq2deGY-MdquN69uF6V51qj3Pw/exec?token=abcd1234";
    const MASTER_API_SUNNY   = "https://script.google.com/macros/s/AKfycbymVJ8_kU4T0WEK5eSQftItoh_sHtmmutjTeuVQDhnMpPdk3dUBxDu5XiuA6tqZ64ZY/exec?token=abcd1234";

    // TheMaster headers
    const USER_ID_FIELD      = "Users";       // Col N
    const USER_NAME_FIELD    = "Name";        // Col O
    const USER_NUMBER_FIELD  = "Number";      // Col P
    const USER_LOCATION_FIELD= "Location";    // Col Q
    const USER_STATUS_FIELD  = "User status"; // Col AF

    // --------------- GLOBAL STATE ----------------

    const tooltip       = document.getElementById("tooltip");
    const popupModal    = document.getElementById("popupModal");
    const controlsModal = document.getElementById("controlsModal");
    const popupTitleEl  = document.getElementById("popupTitle");
    const popupPathEl   = document.getElementById("popupPath");
    const popupMetaEl   = document.getElementById("popupMeta");
    const popupLinksEl  = document.getElementById("popupLinks");
    const popupUsersTbl = document.getElementById("popupUsersTable");

    let rawBoard = {};
    let svg, g, treeLayout, root;
    let currentTreeData = null;

    let filters = { windows: [], pons: [] };

    // window name => normalizedID => { id, name, number, location, status }
    const statusMaps = {
      Merotra: {},
      Sunny: {}
    };

    // popup csv data
    let currentPopupRows = [];

    // --------------- HELPERS ----------------

    function normalizeId(v){
      return (v ?? "").toString().trim().replace(/\s+/g,"").toLowerCase();
    }
    // --------------- INIT ----------------

    document.getElementById("reloadBtn").addEventListener("click", () => {
      loadAll(true);
    });
    document.getElementById("controlsBtn").addEventListener("click", () => {
      controlsModal.style.display = "flex";
    });
    document.getElementById("controlsClose").addEventListener("click", () => {
      controlsModal.style.display = "none";
    });
    document.getElementById("popupClose").addEventListener("click", () => {
      popupModal.style.display = "none";
    });
    document.getElementById("applyFiltersBtn").addEventListener("click", applyFiltersFromUI);

    document.getElementById("btnShot").addEventListener("click", downloadScreenshot);
    document.getElementById("btnCsv").addEventListener("click", downloadCSV);

    window.addEventListener("resize", () => {
      if (currentTreeData) drawTree(currentTreeData);
    });

    // page load
    loadAll(false);

    async function loadAll(){
      try {
        setLoading(true);

        const bRes = await fetch(BOARD_URL);
        rawBoard = await bRes.json();

        await Promise.all([
          loadStatusesForWindow("Merotra", MASTER_API_MEROTRA),
          loadStatusesForWindow("Sunny", MASTER_API_SUNNY)
        ]);

        setupFiltersFromBoard();

        const filtered = filterBoard(rawBoard, filters);
        const treeData = buildHierarchy(filtered);
        currentTreeData = treeData;
        drawTree(treeData);
      } catch(e){
        console.error(e);
        alert("Error loading data: " + e);
      } finally {
        setLoading(false);
      }
    }

    function setLoading(flag){
      const btn = document.getElementById("reloadBtn");
      btn.textContent = flag ? "Loading..." : "Reload";
      btn.disabled = flag;
    }

    // --------------- STATUS MAP (TheMaster) ----------------

    async function loadStatusesForWindow(windowName, apiUrl){
      if (!apiUrl) return;
      try {
        const res = await fetch(apiUrl);
        const json = await res.json();
        if (!json || !Array.isArray(json.rows)) return;

        const m = {};
        json.rows.forEach(row => {
          const rawId = row[USER_ID_FIELD];
          const norm  = normalizeId(rawId);
          if (!norm) return;
          m[norm] = {
            id: rawId != null ? rawId.toString().trim() : "",
            name: row[USER_NAME_FIELD] ?? "",
            number: row[USER_NUMBER_FIELD] ?? "",
            location: row[USER_LOCATION_FIELD] ?? "",
            status: row[USER_STATUS_FIELD] ?? ""
          };
        });
        statusMaps[windowName] = m;
      } catch(e){
        console.error("Status load failed for", windowName, e);
      }
    }

    // --------------- FILTERS ----------------

    function setupFiltersFromBoard(){
      const windowSet = new Set();
      const ponSet = new Set();

      Object.entries(rawBoard).forEach(([pon, winObj]) => {
        ponSet.add(pon);
        Object.keys(winObj || {}).forEach(w => windowSet.add(w));
      });

      filters.windows = Array.from(windowSet);
      filters.pons    = Array.from(ponSet);

      const winDiv = document.getElementById("windowFilters");
      const ponDiv = document.getElementById("ponFilters");
      winDiv.innerHTML = "";
      ponDiv.innerHTML = "";

      Array.from(windowSet).sort().forEach(w => {
        const el = document.createElement("div");
        el.className = "checkbox-item";
        el.innerHTML = `
          <label>
            <input type="checkbox" value="${w}" checked>
            <span>${w}</span>
          </label>`;
        winDiv.appendChild(el);
      });

      Array.from(ponSet).sort().forEach(p => {
        const el = document.createElement("div");
        el.className = "checkbox-item";
        el.innerHTML = `
          <label>
            <input type="checkbox" value="${p}" checked>
            <span>${p}</span>
          </label>`;
        ponDiv.appendChild(el);
      });
    }

    function selectAll(type){
      document.querySelectorAll(`#${type}Filters input[type="checkbox"]`)
        .forEach(ch => ch.checked = true);
    }

    function deselectAll(type){
      document.querySelectorAll(`#${type}Filters input[type="checkbox"]`)
        .forEach(ch => ch.checked = false);
    }

    function applyFiltersFromUI(){
      filters.windows = Array.from(document.querySelectorAll("#windowFilters input:checked")).map(i => i.value);
      filters.pons    = Array.from(document.querySelectorAll("#ponFilters input:checked")).map(i => i.value);

      controlsModal.style.display = "none";

      const filtered = filterBoard(rawBoard, filters);
      const treeData = buildHierarchy(filtered);
      currentTreeData = treeData;
      drawTree(treeData);
    }

    function filterBoard(board, filters){
      const out = {};
      Object.entries(board).forEach(([pon, winObj]) => {
        if (!filters.pons.includes(pon)) return;
        const newWin = {};
        Object.entries(winObj || {}).forEach(([win, splits]) => {
          if (!filters.windows.includes(win)) return;
          newWin[win] = splits;
        });
        if (Object.keys(newWin).length) out[pon] = newWin;
      });
      return out;
    }

    // ----------------- PON PARSER FOR SORTING -----------------
    function parsePon(pon) {
      const m = pon.match(/O(\d+)I(\d+)P(\d+)/i);
      if (!m) return { olt: 9999, ip: 9999, port: 9999 };
      return {
        olt: parseInt(m[1],10),
        ip:  parseInt(m[2],10),
        port:parseInt(m[3],10)
      };
    }

    // --------------- TREE BUILDING ----------------
    // --------------- TREE BUILDING ----------------


function buildHierarchy(board){
  const root = {
    nodeType: "root",
    name: "üåê Merotra Network",
    children: []
  };

  const windowMap = {};

  // ----------- SORT PONs -----------
  const sortedPons = Object.entries(board).sort(([a], [b]) => {
    const A = parsePon(a);
    const B = parsePon(b);
    if (A.olt !== B.olt) return A.olt - B.olt;
    if (A.ip  !== B.ip)  return A.ip  - B.ip;
    return A.port - B.port;
  });

  // ---------- MAIN LOOP ----------
  sortedPons.forEach(([pon, winObj]) => {
    Object.entries(winObj || {}).forEach(([winName, splitterObj]) => {

      if (!windowMap[winName]) {
        windowMap[winName] = {
          nodeType: "window",
          name: "ü™ü " + winName,
          rawWindow: winName,
          children: []
        };
        root.children.push(windowMap[winName]);
      }

      const winNode = windowMap[winName];

      const ponNode = {
        nodeType: "pon",
        name: "üîå " + pon,
        rawPon: pon,
        window: winName,
        children: [],
        total: 0
      };

      // -------- COLLECT + RETAG FILTER --------
      const grouped = {};

      Object.entries(splitterObj || {}).forEach(([splitName, info]) => {
        if (!grouped[splitName]) grouped[splitName] = [];
        grouped[splitName].push(info);
      });

      const finalSplitters = [];

      Object.entries(grouped).forEach(([splitName, rows]) => {
        const retags = rows.filter(r => String(r.tag || "").startsWith("Retag"));

        if (retags.length > 0) {
          // pick last row inside Retag
          let allRows = [];

          retags.forEach(r => {
            const m = r.tag.match(/rows\s*[:=]\s*([0-9,\s]+)/i);
            if (m) {
              m[1].split(",").forEach(n => {
                const rn = parseInt(n.trim(), 10);
                if (!isNaN(rn)) allRows.push(rn);
              });
            }
          });

          const last = Math.max(...allRows);
          const chosen = rows.find(r => r.row === last);
          if (chosen) finalSplitters.push({ splitName, info: chosen });
          return;
        }

        // Fresh case ‚Üí all rows are fresh (usually single)
        rows.forEach(r => finalSplitters.push({ splitName, info: r }));
      });

      // -------- BUILD ENTRY OBJECTS --------
      const entries = [];

      finalSplitters.forEach(({ splitName, info }) => {
        const users = Array.isArray(info.users) ? info.users : [];
        const userIds = [...new Set(users.map(u => String(u.id).trim()))];
        const userSet = new Set(userIds);

        entries.push({
          splitterName: splitName,
          info,
          users: userIds.map(id => ({id})),
          userIds,
          userSet,
          userCount: userSet.size   // REAL UNIQUE COUNT
        });

        ponNode.total += userSet.size;
      });

      if (entries.length === 0) {
        winNode.children.push(ponNode);
        return;
      }

      // --- FIX #1: SORT USING REAL UNIQUE USERS ---
      entries.sort((a,b) => b.userCount - a.userCount);

      const nodeEntries = entries.map(e => ({
        entry: e,
        node: makeSplitterNodeFixed(e, pon, winName)
      }));

      const primary = nodeEntries[0].node;
      ponNode.children.push(primary);

      // --- CHILD RELATION LOGIC (unchanged) ---
      for (let i = 1; i < nodeEntries.length; i++) {

        const childObj = nodeEntries[i];
        const childSet = childObj.entry.userSet;

        let matchedParent = null;
        let overlapFound = false;

        for (let j = 0; j < i; j++) {
          const parentObj = nodeEntries[j];
          const parentSet = parentObj.entry.userSet;

          const overlap = [...childSet].filter(x => parentSet.has(x));

          if (overlap.length > 0) {
            overlapFound = true;

            if (isSubset(childSet, parentSet)) {
              matchedParent = parentObj.node;

              break;
            }
          }
        }

        if (!matchedParent && !overlapFound)
          ponNode.children.push(childObj.node);
        else if (!matchedParent && overlapFound)
          primary.children.push(childObj.node);
        else
          matchedParent.children.push(childObj.node);
      }

      winNode.children.push(ponNode);
    });
  });

  return root;
}

// -------- FIXED NODE BUILDER (accurate count) --------
function makeSplitterNodeFixed(entry, pon, windowName){
  const total = entry.userCount;
  const emoji = emojiForSplitter(entry.splitterName);

  return {
    nodeType: "splitter",
    name: `${emoji} ${entry.splitterName} (${total})`,
    rawSplitter: entry.splitterName,
    pon,
    window: windowName,
    users: entry.users,
    userIds: entry.userIds,
    total,
    tag: entry.info.tag || "",
    location: entry.info.location || "",
    jcPic: entry.info.jcPic || "",
    polePic: entry.info.polePic || "",
    children: []
  };
}


    // --------- HELPER NODE BUILDER ----------
    function makeSplitterNode(entry, pon, windowName){
      const info = entry.info;
      const users = entry.users;
      const total = info.total ?? users.length ?? 0;

      const emoji = emojiForSplitter(entry.splitterName);
      const label = `${emoji} ${entry.splitterName} (${total})`;

      return {
        nodeType: "splitter",
        name: label,
        rawSplitter: entry.splitterName,
        pon,
        window: windowName,
        users,
        userIds: entry.userIds,
        total,
        tag: info.tag || "",
        location: info.location || "",
        jcPic: info.jcPic || "",
        polePic: info.polePic || "",
        children: []
      };
    }

    function emojiForSplitter(s){
      const t = (s || "").toLowerCase();
      if (t.includes("link")) return "üîó";
      if (t.includes("16"))  return "üî∫";
      if (t.includes("8"))   return "üîµ";
      if (t.includes("4"))   return "üü•";
      if (t.includes("2"))   return "üü©";
      return "‚¨ú";
    }

    function isSubset(aSet, bSet){
      for (let x of aSet) if (!bSet.has(x)) return false;
      return true;
    }

        // --------------- DRAW TREE ----------------

    function drawTree(data){
      d3.select("#chart").select("svg").remove();

      const width = document.getElementById("chart").clientWidth;
      const height = document.getElementById("chart").clientHeight;

      const dx = 80;
      const dy = width > 900 ? 260 : 200;

      treeLayout = d3.tree().nodeSize([dx, dy]);
      root = d3.hierarchy(data, d => d.children || []);
      treeLayout(root);

      const svgRoot = d3.select("#chart").append("svg")
        .attr("width", width)
        .attr("height", height);

      const zoom = d3.zoom().scaleExtent([0.4, 3])
        .on("zoom", (event) => g.attr("transform", event.transform));

      svgRoot.call(zoom);

      g = svgRoot.append("g").attr("transform", "translate(80,60)");

      const links = root.links();
      const nodes = root.descendants();

      g.selectAll(".link")
        .data(links)
        .enter()
        .append("path")
        .attr("class","link")
        .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x))
        .attr("fill","none")
        .attr("stroke","#94a3b8")
        .attr("stroke-width",2);

      const node = g.selectAll(".node")
        .data(nodes)
        .enter()
        .append("g")
        .attr("class","node")
        .attr("transform", d => `translate(${d.y},${d.x})`);

      // root
      node.filter(d => d.data.nodeType === "root")
        .append("circle")
        .attr("r",24)
        .attr("fill","#1e3a8a")
        .attr("stroke","#fff")
        .attr("stroke-width",3);

      // window
      node.filter(d => d.data.nodeType === "window")
        .append("circle")
        .attr("r",20)
        .attr("fill","#1d4ed8")
        .attr("stroke","#fff")
        .attr("stroke-width",3);

      // PON
      node.filter(d => d.data.nodeType === "pon")
        .append("circle")
        .attr("r",18)
        .attr("fill","#0f766e")
        .attr("stroke","#fff")
        .attr("stroke-width",3);

      // splitter + untagged
      node.filter(d => d.data.nodeType === "splitter" || d.data.nodeType === "untagged")
        .append("circle")
        .attr("r", d => d.data.nodeType === "splitter" ? 14 : 10)
        .attr("fill", d => d.data.nodeType === "untagged" ? "#6b7280" : colorForSplitter(d.data))
        .attr("stroke","#fff")
        .attr("stroke-width",2)
        .classed("blink-red", d => d.data.tag && d.data.tag.includes("üî¥‚ùå"));

      // TEXT
      node.append("text")
        .attr("dy","0.32em")
        .attr("x", d => d.children && d.depth > 0 ? -20 : 20)
        .attr("text-anchor", d => d.children && d.depth > 0 ? "end" : "start")
        .style("font-size", d => {
          if (d.data.nodeType === "root") return "14px";
          if (d.data.nodeType === "window") return "13px";
          if (d.data.nodeType === "pon") return "12px";
          return "11px";
        })
        .style("font-weight", d =>
          d.data.nodeType === "root" || d.data.nodeType === "window" ? 700 : 500
        )
        .text(d => d.data.name);

      // HOVER + CLICK bindings
      node
        .on("mousemove", handleMouseOver)
        .on("mouseout", () => tooltip.style.opacity = 0)
        .on("click", handleNodeClick);

      fitToView(svgRoot, g, zoom);
    }

    function colorForSplitter(data){
      const total = data.total || 0;
      if (total === 0) return "#6b7280";
      return "#10b981";
    }

    function fitToView(svgRoot, g, zoom){
      const chart = document.getElementById("chart");
      const bounds = g.node().getBBox();
      const fullWidth = chart.clientWidth;
      const fullHeight = chart.clientHeight;

      const widthScale  = fullWidth  / (bounds.width + 160);
      const heightScale = fullHeight / (bounds.height + 160);
      const scale = Math.min(2, Math.max(0.4, Math.min(widthScale, heightScale)));

      const tx = -(bounds.x)*scale + 40;
      const ty = -(bounds.y)*scale + 40;

      svgRoot.transition().duration(600).call(
        zoom.transform,
        d3.zoomIdentity.translate(tx,ty).scale(scale)
      );
    }

    // --------------- TOOLTIP ----------------

    function handleMouseOver(event, d){
      const data = d.data;
      let html = `<strong>${data.name}</strong><br/>`;

      if (data.nodeType === "window"){
        html += `Window`;
      }
      else if (data.nodeType === "pon"){
        html += `PON: ${data.rawPon}<br/>Total users: ${data.total || 0}`;
      }
      else if (data.nodeType === "splitter" || data.nodeType === "untagged"){
        html += `Window: ${data.window}<br/>PON: ${data.pon}<br/>Users: <strong>${data.total || (data.users ? data.users.length : 0)}</strong>`;
        if (data.tag){
          html += `<br/>Tag: ${data.tag}`;
        }
      }

      tooltip.innerHTML = html;
      tooltip.style.left = (event.pageX + 14) + "px";
      tooltip.style.top  = (event.pageY + 8) + "px";
      tooltip.style.opacity = 1;
    }

    // --------------- POPUP ----------------

    function handleNodeClick(event, d){
      const data = d.data;

      if (!(data.nodeType === "splitter" || data.nodeType === "untagged")) return;

      const total = data.total || (data.users ? data.users.length : 0);

      popupTitleEl.textContent =
        data.nodeType === "untagged"
        ? `‚¨ú Untagged users (${total})`
        : `${data.rawSplitter} ‚Äî Users`;

      popupPathEl.textContent = `${data.window} ‚Üí ${data.pon} ‚Üí ${data.rawSplitter}`;

      popupMetaEl.innerHTML = `
        <div><span class="font-semibold">Total users:</span> ${total}</div>
        <div><span class="font-semibold">Tag:</span> ${data.tag || "-"}</div>
      `;

      let linksHtml = "";
      if (data.location){
        linksHtml += `<span class="link-btn" onclick="openLink('${data.location}')">üìç Location</span>`;
      }
      if (data.jcPic){
        linksHtml += `<span class="link-btn" onclick="openLink('${data.jcPic}')">üì∏ JC Pic</span>`;
      }
      if (data.polePic){
        linksHtml += `<span class="link-btn" onclick="openLink('${data.polePic}')">ü™µ Pole Pic</span>`;
      }
      popupLinksEl.innerHTML = linksHtml || "";

      buildUserTable(data);
      popupModal.style.display = "flex";
    }

    function buildUserTable(data){
      const users = data.users || [];
      const statusMap = statusMaps[data.window] || {};

      currentPopupRows = [];

      popupUsersTbl.innerHTML = `
        <thead>
          <tr>
            <th style="width:32px;">Sr</th>
            <th>User ID</th>
            <th>Name</th>
            <th>Number</th>
            <th>Location</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody></tbody>
      `;

      const tbody = popupUsersTbl.querySelector("tbody");

      users.forEach((u, idx) => {
        const rawId = (u.id ?? "").toString();
        const normId = normalizeId(rawId);
        const dbRow = statusMap[normId];

        const tr = document.createElement("tr");
        tr.className = "user-row";

        tr.innerHTML = `
          <td>${idx+1}</td>
          <td>${rawId}</td>
          <td>${dbRow?.name ?? ""}</td>
          <td>${dbRow?.number ?? ""}</td>
          <td>${dbRow?.location ?? ""}</td>
          <td>${dbRow?.status ?? ""}</td>
        `;

        tbody.appendChild(tr);

        currentPopupRows.push({
          sr: idx+1,
          id: rawId,
          name: dbRow?.name ?? "",
          number: dbRow?.number ?? "",
          location: dbRow?.location ?? "",
          status: dbRow?.status ?? ""
        });
      });
    }


        function openLink(url){
      if (url) window.open(url, "_blank");
    }

    // --------------- DOWNLOADS ----------------

    function downloadScreenshot(){
      const modalContent = document.querySelector("#popupModal .modal-content");
      if (!modalContent) return;
      html2canvas(modalContent).then(canvas => {
        const link = document.createElement("a");
        const today = new Date().toISOString().slice(0,10);
        link.download = `merotra-users-${today}.png`;
        link.href = canvas.toDataURL("image/png");
        link.click();
      });
    }

    function downloadCSV(){
      if (!currentPopupRows.length) return;

      const header = ["Sr","User ID","Name","Number","Location","Status"];
      const lines = [header.join(",")];

      currentPopupRows.forEach(r => {
        const row = [
          r.sr,
          `"${r.id}"`,
          `"${(r.name||"").replace(/"/g,'""')}"`,
          `"${(r.number||"").replace(/"/g,'""')}"`,
          `"${(r.location||"").replace(/"/g,'""')}"`,
          `"${(r.status||"").replace(/"/g,'""')}"`,
        ];
        lines.push(row.join(","));
      });

      const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      const today = new Date().toISOString().slice(0,10);
      link.href = url;
      link.download = `merotra-users-${today}.csv`;
      link.click();
      URL.revokeObjectURL(url);
    }

    // expose needed functions
    window.openLink   = openLink;
    window.selectAll  = selectAll;
    window.deselectAll= deselectAll;
  </script>

</body>
</html>
