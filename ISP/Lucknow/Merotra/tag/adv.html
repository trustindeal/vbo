<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üåê Merotra ‚Äî PON / Splitter Tree</title>

  <!-- Libraries -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">

  <!-- External CSS -->
  <link rel="stylesheet" href="adv.css">
</head>
<body>

  <!-- HEADER -->
  <div class="header">
    <div>
      <div class="header-title">
        <span>üåê Merotra Network Tree</span>
      </div>
      <div class="header-sub">
        Window ‚Üí PON ‚Üí Splitters ‚Üí Users (+ Untagged branch)
      </div>
    </div>
    <div class="header-actions">
      <button id="controlsBtn" class="btn btn-secondary">Filters</button>
      <button id="reloadBtn" class="btn">Reload</button>
    </div>
  </div>

  <!-- CHART AREA -->
  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <!-- POPUP: Splitter / Untagged -->
  <div id="popupModal" class="modal-backdrop">
    <div id="popupContent" class="modal-content">
      <div class="popup-header">
        <div>
          <h2 id="popupTitle" class="popup-title"></h2>
          <div id="popupPath" class="popup-path"></div>
        </div>
        <button id="popupClose" class="btn btn-secondary btn-xs">Close</button>
      </div>

      <div id="popupMeta" class="popup-meta"></div>

      <div id="popupLinks" class="popup-links"></div>

      <div class="popup-users-header">
        <h3 class="popup-users-title">Users</h3>
        <div class="popup-users-actions">
          <button id="popupScreenshotBtn" class="btn btn-xs">üì∏ Screenshot</button>
          <button id="popupCsvBtn" class="btn btn-secondary btn-xs">üìä CSV</button>
        </div>
      </div>

      <div id="popupUsers" class="popup-users"></div>
    </div>
  </div>

  <!-- CONTROLS MODAL -->
  <div id="controlsModal" class="modal-backdrop">
    <div class="controls-modal">
      <h2 class="controls-title">Filters &amp; View</h2>

      <div class="controls-section">
        <div class="filter-title">Windows</div>
        <div id="windowFilters" class="checkbox-grid"></div>
        <div class="select-row">
          <span class="select-all" onclick="selectAll('window')">Select All</span> |
          <span class="select-all" onclick="deselectAll('window')">Deselect All</span>
        </div>
      </div>

      <div class="controls-section">
        <div class="filter-title">PONs</div>
        <div id="ponFilters" class="checkbox-grid checkbox-scroll"></div>
        <div class="select-row">
          <span class="select-all" onclick="selectAll('pon')">Select All</span> |
          <span class="select-all" onclick="deselectAll('pon')">Deselect All</span>
        </div>
      </div>

      <button id="applyFiltersBtn" class="btn controls-btn">Apply Filters</button>
      <button id="controlsClose" class="btn btn-secondary controls-btn">Close</button>
    </div>
  </div>

  <!-- SCRIPT -->
  <script>
    // -------------------- CONFIG --------------------

    // Same BOARD API_BASE (board/data)
    const API_BASE = "https://script.googleusercontent.com/macros/echo?user_content_key=AehSKLgWoNwxGB6cZdAHMQqMmh9R-uY6NTk56cJT4JE1BQNi4u_VU4-hjmrbr1SjmTu7SY_lFxNiNETKTS5sRHKD8Hrr4Uh1GYAGlmrDRjyfoTGetW786IOjsnIqah5_cVjZEPkbGsnQjKY7GGHpErfeZpXItjvb71iz-b-cH5L7ISw_DqTfJBdn8ieDC99pCWOyZv9mzZkpzmxeJVOfxWLnwvj9QMktqCF3PG6871DG6eAotb-vcbTj5XnAw-YLofKgoccAohOSpCB_gn-XWlI1EwQDtLoohgONwIdSu50jkShz1nQ9Cx4&lib=MM9jfESS3VUQ4bogWcHsjBa_bifldmWHw";
    const BOARD_URL = API_BASE + "&mode=board";

    // TheMaster DB URLs (token = abcd1234)
    const MASTER_API_MEROTRA = "https://script.google.com/macros/s/AKfycbwEjBWnBLw5S45MdR0yq4Kvuuy5uFC_8a8u0syGpW9Kyq2deGY-MdquN69uF6V51qj3Pw/exec?token=abcd1234";
    const MASTER_API_SUNNY   = "https://script.google.com/macros/s/AKfycbymVJ8_kU4T0WEK5eSQftItoh_sHtmmutjTeuVQDhnMpPdk3dUBxDu5XiuA6tqZ64ZY/exec?token=abcd1234";

    // TheMaster headers (must match header text in row 1)
    const USER_ID_FIELD       = "Users";       // N
    const USER_NAME_FIELD     = "Name";        // O
    const USER_NUMBER_FIELD   = "Number";      // P
    const USER_LOCATION_FIELD = "Location";    // Q
    const USER_STATUS_FIELD   = "User status"; // AF

    // -------------------- GLOBAL STATE --------------------

    const tooltip      = document.getElementById("tooltip");
    const popupModal   = document.getElementById("popupModal");
    const controlsModal= document.getElementById("controlsModal");

    let rawBoard = {};
    let svgRoot, g, treeLayout, root;
    let currentTreeData = null;

    let filters = { windows: [], pons: [] };

    // windowName -> { userId -> {status,name,number,location} }
    const statusMaps = {
      Merotra: {},
      Sunny: {}
    };

    // current clicked node data
    let currentClickNode = null;

    // -------------------- INIT --------------------

    document.getElementById("reloadBtn").addEventListener("click", () => loadAll(true));
    document.getElementById("controlsBtn").addEventListener("click", () => { controlsModal.style.display = "flex"; });
    document.getElementById("controlsClose").addEventListener("click", () => { controlsModal.style.display = "none"; });
    document.getElementById("popupClose").addEventListener("click", () => { popupModal.style.display = "none"; });
    document.getElementById("applyFiltersBtn").addEventListener("click", applyFiltersFromUI);

    document.getElementById("popupScreenshotBtn").addEventListener("click", downloadPopupScreenshot);
    document.getElementById("popupCsvBtn").addEventListener("click", downloadPopupCSV);

    window.addEventListener("resize", () => {
      if (currentTreeData) drawTree(currentTreeData);
    });

    // Expose some helpers for inline onclick
    window.selectAll   = selectAll;
    window.deselectAll = deselectAll;

    // First load
    loadAll(false);

    // -------------------- LOADING --------------------

    async function loadAll() {
      try {
        setLoading(true);

        // 1) Board JSON
        const bRes = await fetch(BOARD_URL);
        rawBoard = await bRes.json();

        // 2) TheMaster DBs
        await Promise.all([
          loadStatusesForWindow("Merotra", MASTER_API_MEROTRA),
          loadStatusesForWindow("Sunny", MASTER_API_SUNNY)
        ]);

        // 3) Filters
        setupFiltersFromBoard();

        // 4) Build + Draw
        const filtered = filterBoard(rawBoard, filters);
        const treeData = buildHierarchy(filtered);
        currentTreeData = treeData;
        drawTree(treeData);
      } catch (e) {
        console.error(e);
        alert("Error loading data: " + e);
      } finally {
        setLoading(false);
      }
    }

    function setLoading(flag) {
      const btn = document.getElementById("reloadBtn");
      btn.textContent = flag ? "Loading..." : "Reload";
      btn.disabled = flag;
    }

    // -------------------- STATUS MAPS (TheMaster) --------------------

    async function loadStatusesForWindow(windowName, apiUrl) {
      if (!apiUrl) return;
      try {
        const res = await fetch(apiUrl);
        const json = await res.json();
        if (!json || !Array.isArray(json.rows)) return;

        const map = {};
        json.rows.forEach(row => {
function cleanID(v) {
  if (!v) return "";
  return String(v)
    .trim()
    .replace(/\s+/g, "")       // remove spaces
    .replace(/^0+/, "")        // remove leading zeros
    .toLowerCase();            // normalize
}

json.rows.forEach(row => {
  const idRaw = row[USER_ID_FIELD];
  const id = cleanID(idRaw);
  if (!id) return;

  map[id] = {
    status:   (row[USER_STATUS_FIELD]   ?? "").toString().trim(),
    name:     (row[USER_NAME_FIELD]     ?? "").toString().trim(),
    number:   (row[USER_NUMBER_FIELD]   ?? "").toString().trim(),
    location: (row[USER_LOCATION_FIELD] ?? "").toString().trim()
  };
});

        });
        statusMaps[windowName] = map;
      } catch (e) {
        console.error("Status load failed for", windowName, e);
      }
    }

    // -------------------- FILTERS --------------------

    function setupFiltersFromBoard() {
      const windowSet = new Set();
      const ponSet    = new Set();

      Object.entries(rawBoard).forEach(([pon, winObj]) => {
        ponSet.add(pon);
        Object.keys(winObj || {}).forEach(w => windowSet.add(w));
      });

      filters.windows = Array.from(windowSet);
      filters.pons    = Array.from(ponSet);

      const winDiv = document.getElementById("windowFilters");
      const ponDiv = document.getElementById("ponFilters");
      winDiv.innerHTML = "";
      ponDiv.innerHTML = "";

      Array.from(windowSet).sort().forEach(w => {
        const el = document.createElement("div");
        el.className = "checkbox-item";
        el.innerHTML = `
          <label>
            <input type="checkbox" value="${w}" checked>
            <span>${w}</span>
          </label>`;
        winDiv.appendChild(el);
      });

      Array.from(ponSet).sort().forEach(p => {
        const el = document.createElement("div");
        el.className = "checkbox-item";
        el.innerHTML = `
          <label>
            <input type="checkbox" value="${p}" checked>
            <span>${p}</span>
          </label>`;
        ponDiv.appendChild(el);
      });
    }

    function selectAll(type) {
      document
        .querySelectorAll(`#${type}Filters input[type="checkbox"]`)
        .forEach(ch => ch.checked = true);
    }

    function deselectAll(type) {
      document
        .querySelectorAll(`#${type}Filters input[type="checkbox"]`)
        .forEach(ch => ch.checked = false);
    }

    function applyFiltersFromUI() {
      filters.windows = Array.from(
        document.querySelectorAll("#windowFilters input:checked")
      ).map(i => i.value);

      filters.pons = Array.from(
        document.querySelectorAll("#ponFilters input:checked")
      ).map(i => i.value);

      controlsModal.style.display = "none";

      const filtered = filterBoard(rawBoard, filters);
      const treeData = buildHierarchy(filtered);
      currentTreeData = treeData;
      drawTree(treeData);
    }

    function filterBoard(board, filters) {
      const out = {};
      Object.entries(board).forEach(([pon, winObj]) => {
        if (!filters.pons.includes(pon)) return;
        const newWin = {};
        Object.entries(winObj || {}).forEach(([win, splits]) => {
          if (!filters.windows.includes(win)) return;
          newWin[win] = splits;
        });
        if (Object.keys(newWin).length) out[pon] = newWin;
      });
      return out;
    }

    // -------------------- HIERARCHY BUILDING --------------------

    function buildHierarchy(board) {
      const root = {
        nodeType: "root",
        name: "üåê Merotra Network",
        children: []
      };

      const windowMap = {};

      Object.entries(board).forEach(([pon, winObj]) => {
        Object.entries(winObj || {}).forEach(([winName, splitterObj]) => {

          if (!windowMap[winName]) {
            const winNode = {
              nodeType: "window",
              name: "ü™ü " + winName,
              rawWindow: winName,
              children: []
            };
            windowMap[winName] = winNode;
            root.children.push(winNode);
          }

          const winNode = windowMap[winName];

          const ponNode = {
            nodeType: "pon",
            name: "üîå " + pon,
            rawPon: pon,
            window: winName,
            children: [],
            total: 0,
            online: 0,
            offline: 0
          };

          const entries = [];
          Object.entries(splitterObj || {}).forEach(([splitName, info]) => {
            const users    = Array.isArray(info.users) ? info.users : [];
            const userIds  = users.map(u => String(u.id));
            const userSet  = new Set(userIds);
            entries.push({
              splitterName: splitName,
              info,
              users,
              userIds,
              userSet
            });

            ponNode.total   += info.total   || users.length || 0;
            ponNode.online  += info.online  || 0;
            ponNode.offline += info.offline || 0;
          });

          if (entries.length === 0) {
            winNode.children.push(ponNode);
            return;
          }

          // sort by user count desc = primary first
          entries.sort((a, b) => b.userIds.length - a.userIds.length);

          const nodeEntries = entries.map(e => ({
            entry: e,
            node: makeSplitterNode(e, pon, winName)
          }));

          const primaryNode = nodeEntries[0].node;
          ponNode.children.push(primaryNode);

          // link chain with subset logic
          for (let i = 1; i < nodeEntries.length; i++) {
            const child = nodeEntries[i];
            const childSet = child.entry.userSet;
            let parentNode = null;

            for (let j = i - 1; j >= 0; j--) {
              const parentEntry = nodeEntries[j];
              if (isSubset(childSet, parentEntry.entry.userSet)) {
                parentNode = parentEntry.node;
                break;
              }
            }

            if (!parentNode) parentNode = primaryNode;
            parentNode.children.push(child.node);
          }

          // untagged branch on non-leaf nodes
          const allNodes = nodeEntries.map(n => n.node);
          allNodes.forEach(node => {
            if (!node.children || node.children.length === 0) return;

            const parentSet = new Set(node.userIds);
            const childUnion = new Set();
            node.children.forEach(ch => {
              (ch.userIds || []).forEach(id => childUnion.add(id));
            });

            const leftover = [];
            parentSet.forEach(id => {
              if (!childUnion.has(id)) leftover.push(id);
            });

            if (leftover.length > 0) {
              const users = leftover.map(id => ({ id, offline: false }));
              const otherNode = {
                nodeType: "untagged",
                name: "‚¨ú Other (" + leftover.length + ")",
                rawSplitter: "Other",
                pon: pon,
                window: winName,
                users,
                userIds: leftover,
                total: leftover.length,
                online: leftover.length,
                offline: 0,
                tag: "",
                location: node.location,
                jcPic: node.jcPic,
                polePic: node.polePic,
                children: []
              };
              node.children.push(otherNode);
            }
          });

          winNode.children.push(ponNode);
        });
      });

      return root;
    }

    function makeSplitterNode(entry, pon, windowName) {
      const info    = entry.info  || {};
      const users   = entry.users || [];
      const userIds = entry.userIds || [];
      const total   = info.total   ?? users.length ?? 0;
      const online  = info.online  ?? users.filter(u => !u.offline).length;
      const offline = info.offline ?? users.filter(u =>  u.offline).length;

      const emoji = emojiForSplitter(entry.splitterName);
      const label = `${emoji} ${entry.splitterName} (${total})`;

      return {
        nodeType: "splitter",
        name: label,
        rawSplitter: entry.splitterName,
        pon,
        window: windowName,
        users,
        userIds,
        total,
        online,
        offline,
        tag: info.tag || "",
        location: info.location || "",
        jcPic: info.jcPic || "",
        polePic: info.polePic || "",
        children: []
      };
    }

    function emojiForSplitter(splitName) {
      const s = (splitName || "").toLowerCase();
      if (s.includes("link"))    return "üîó";
      if (s.includes("pending")) return "‚è≥";
      if (s.includes("16"))      return "üî∫";
      if (s.includes("8"))       return "üîµ";
      if (s.includes("4"))       return "üü•";
      if (s.includes("2"))       return "üü©";
      return "‚¨ú";
    }

    function isSubset(aSet, bSet) {
      for (let v of aSet) if (!bSet.has(v)) return false;
      return true;
    }

    // -------------------- DRAW TREE --------------------

    function drawTree(data) {
      d3.select("#chart").select("svg").remove();

      const width  = document.getElementById("chart").clientWidth;
      const height = document.getElementById("chart").clientHeight;

      const dx = 80;
      const dy = width > 900 ? 260 : 200;

      treeLayout = d3.tree().nodeSize([dx, dy]);
      root = d3.hierarchy(data, d => d.children || []);
      treeLayout(root);

      svgRoot = d3.select("#chart").append("svg")
        .attr("width", width)
        .attr("height", height);

      const zoom = d3.zoom().scaleExtent([0.4, 3])
        .on("zoom", event => g.attr("transform", event.transform));

      svgRoot.call(zoom);

      g = svgRoot.append("g").attr("transform", "translate(80,60)");

      const links = root.links();
      const nodes = root.descendants();

      // links
      g.selectAll(".link")
        .data(links)
        .enter()
        .append("path")
        .attr("class", "link")
        .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x))
        .attr("fill", "none")
        .attr("stroke", "#94a3b8")
        .attr("stroke-width", 2);

      const node = g.selectAll(".node")
        .data(nodes)
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.y},${d.x})`);

      // root
      node.filter(d => d.data.nodeType === "root")
        .append("circle")
        .attr("r", 24)
        .attr("fill", "#1e3a8a")
        .attr("stroke", "#fff")
        .attr("stroke-width", 3);

      // window
      node.filter(d => d.data.nodeType === "window")
        .append("circle")
        .attr("r", 20)
        .attr("fill", "#1d4ed8")
        .attr("stroke", "#fff")
        .attr("stroke-width", 3);

      // pon
      node.filter(d => d.data.nodeType === "pon")
        .append("circle")
        .attr("r", 18)
        .attr("fill", "#0f766e")
        .attr("stroke", "#fff")
        .attr("stroke-width", 3);

      // splitter / untagged
      node.filter(d => d.data.nodeType === "splitter" || d.data.nodeType === "untagged")
        .append("circle")
        .attr("r", d => d.data.nodeType === "splitter" ? 14 : 10)
        .attr("fill", d =>
          d.data.nodeType === "untagged" ? "#6b7280" : colorForSplitter(d.data)
        )
        .attr("stroke", "#fff")
        .attr("stroke-width", 2)
        .on("mousemove", handleMouseOver)
        .on("mouseout", () => tooltip.style.opacity = 0)
        .on("click", handleNodeClick);

      // blink if Tag = üî¥‚ùå
      node.filter(d =>
        d.data.nodeType === "splitter" &&
        typeof d.data.tag === "string" &&
        d.data.tag.includes("üî¥‚ùå")
      )
      .select("circle")
      .classed("blink-red", true);

      // labels
      node.append("text")
        .attr("dy", "0.32em")
        .attr("x", d => d.children && d.depth > 0 ? -20 : 20)
        .attr("text-anchor", d => d.children && d.depth > 0 ? "end" : "start")
        .style("font-size", d => {
          if (d.data.nodeType === "root")   return "14px";
          if (d.data.nodeType === "window") return "13px";
          if (d.data.nodeType === "pon")    return "12px";
          return "11px";
        })
        .style("font-weight", d =>
          d.data.nodeType === "root" || d.data.nodeType === "window" ? 700 : 500
        )
        .text(d => d.data.name);

      // tooltip only for window + pon (no popup)
      node.filter(d => d.data.nodeType === "window" || d.data.nodeType === "pon")
        .on("mousemove", handleMouseOver)
        .on("mouseout", () => tooltip.style.opacity = 0)
        .on("click", () => {}); // disable popup

      // auto fit
      fitToView(svgRoot, g, zoom);
    }

    function colorForSplitter(data) {
      const total   = data.total   || 0;
      const offline = data.offline || 0;
      if (total === 0) return "#6b7280";
      const r = offline / total;
      if (r >= 1)   return "#ef4444";
      if (r >= 0.5) return "#f59e0b";
      return "#10b981";
    }

    function fitToView(svgRoot, g, zoom) {
      const chart = document.getElementById("chart");
      const bounds = g.node().getBBox();
      const fullWidth  = chart.clientWidth;
      const fullHeight = chart.clientHeight;
      const widthScale  = fullWidth  / (bounds.width  + 160);
      const heightScale = fullHeight / (bounds.height + 160);
      const scale = Math.min(2, Math.max(0.4, Math.min(widthScale, heightScale)));
      const tx = -(bounds.x) * scale + 40;
      const ty = -(bounds.y) * scale + 40;

      svgRoot.transition()
        .duration(600)
        .call(zoom.transform,
          d3.zoomIdentity.translate(tx, ty).scale(scale)
        );
    }

    // -------------------- TOOLTIP --------------------

    function handleMouseOver(event, d) {
      const data = d.data;
      let html = `<strong>${data.name}</strong><br/>`;

      if (data.nodeType === "window") {
        html += `Window`;
      } else if (data.nodeType === "pon") {
        html += `PON: ${data.rawPon}<br/>Total: ${data.total || 0}`;
      } else if (data.nodeType === "splitter" || data.nodeType === "untagged") {
        html += `Window: ${data.window}<br/>PON: ${data.pon}<br/>`;
        const total = data.total || (data.users ? data.users.length : 0);
        html += `Users: <strong>${total}</strong>`;
        if (data.tag) {
          html += `<br/>Tag: ${data.tag}`;
        }
      }

      tooltip.innerHTML = html;
      tooltip.style.left = (event.pageX + 14) + "px";
      tooltip.style.top  = (event.pageY + 8) + "px";
      tooltip.style.opacity = 1;
    }

    // -------------------- POPUP --------------------

    function handleNodeClick(event, d) {
      const data = d.data;
      if (!(data.nodeType === "splitter" || data.nodeType === "untagged")) return;

      currentClickNode = data;

      const titleEl = document.getElementById("popupTitle");
      const pathEl  = document.getElementById("popupPath");
      const metaEl  = document.getElementById("popupMeta");
      const linksEl = document.getElementById("popupLinks");
      const listEl  = document.getElementById("popupUsers");

      // Title = Splitter name only (Option A)
      titleEl.textContent = data.nodeType === "untagged"
        ? `‚¨ú Untagged users`
        : `${data.rawSplitter} ‚Äî Users`;

      pathEl.textContent = `${data.window} ‚Üí ${data.pon} ‚Üí ${data.rawSplitter}`;

      const total = data.total || (data.users ? data.users.length : 0);

      // No online/offline counts here
      metaEl.innerHTML = `
        <div><span class="meta-label">Window:</span> ${data.window}</div>
        <div><span class="meta-label">PON:</span> ${data.pon}</div>
        <div><span class="meta-label">Splitter:</span> ${data.rawSplitter || "-"}</div>
        <div><span class="meta-label">Total users:</span> ${total}</div>
        <div><span class="meta-label">Tag:</span> ${data.tag || "-"}</div>
      `;

      // Links
      let linksHtml = "";
      if (data.location) {
        linksHtml += `<button class="link-btn" onclick="openLink('${data.location}')">üìç Location</button>`;
      }
      if (data.jcPic) {
        linksHtml += `<button class="link-btn" onclick="openLink('${data.jcPic}')">üì∏ JC Pic</button>`;
      }
      if (data.polePic) {
        linksHtml += `<button class="link-btn" onclick="openLink('${data.polePic}')">ü™µ Pole Pic</button>`;
      }
      linksEl.innerHTML = linksHtml;

      // User list
      listEl.innerHTML = "";
      const users = data.users || [];
      const statusMap = statusMaps[data.window] || {};

      users.forEach((u, idx) => {
const id = cleanID(u.id);
const info = statusMap[id] || {};

        const row = document.createElement("div");
        row.className = "user-row";

        const extraParts = [];
        if (info.name)     extraParts.push(info.name);
        if (info.number)   extraParts.push("üìû " + info.number);
        if (info.location) extraParts.push("üìç " + info.location);

        row.innerHTML = `
          <div class="user-main">
            <span class="user-index">${idx + 1}.</span>
            <span class="user-id">${id}</span>
          </div>
          <div class="user-details">
            <div class="user-status">${info.status || ""}</div>
            ${extraParts.length ? `<div class="user-extra">${extraParts.join(" ¬∑ ")}</div>` : ""}
          </div>
        `;
        listEl.appendChild(row);
      });

      popupModal.style.display = "flex";
    }

    function openLink(url) {
      if (url) window.open(url, "_blank");
    }
    window.openLink = openLink;

    // Screenshot of popup
    function downloadPopupScreenshot() {
      const modalContent = document.getElementById("popupContent");
      if (!modalContent) return;
      html2canvas(modalContent, {
        backgroundColor: "#ffffff",
        scale: 2
      }).then(canvas => {
        const link = document.createElement("a");
        const date = new Date().toISOString().slice(0, 10);
        link.download = `merotra-popup-${date}.png`;
        link.href = canvas.toDataURL("image/png");
        link.click();
      });
    }

    // CSV of popup users
    function downloadPopupCSV() {
      if (!currentClickNode) return;
      const users = currentClickNode.users || [];
      const statusMap = statusMaps[currentClickNode.window] || {};

      const rows = [["Sr", "User ID", "Status", "Name", "Number", "Location"]];
      users.forEach((u, idx) => {
const id = cleanID(u.id);
const info = statusMap[id] || {};

        rows.push([
          String(idx + 1),
          id,
          info.status   || "",
          info.name     || "",
          info.number   || "",
          info.location || ""
        ]);
      });

      const csv = rows
        .map(r => r.map(v => `"${String(v).replace(/"/g, '""')}"`).join(","))
        .join("\n");

      const blob = new Blob([csv], { type: "text/csv" });
      const a = document.createElement("a");
      const date = new Date().toISOString().slice(0, 10);
      a.href = URL.createObjectURL(blob);
      a.download = `merotra-users-${date}.csv`;
      a.click();
    }
  </script>

</body>
</html>
