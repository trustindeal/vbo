<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merotra ‚Äî PON / Splitter Tree (Levels)</title>

  <!-- D3 & Tailwind -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Screenshot lib -->
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{font-family:Inter,system-ui,Arial}
    body{margin:0;padding:12px;background:#f8fafc;color:#0f172a}
    .header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
    .header-title{font-weight:700;font-size:18px}
    .header-sub{font-size:12px;color:#475569}
    .btn{background:#0f172a;color:white;padding:6px 10px;border-radius:6px;border:none;cursor:pointer}
    .btn-secondary{background:#94a3b8}
    #chart{width:100%;height:78vh;border-radius:8px;background:#fff;padding:8px;box-shadow:0 6px 20px rgba(2,6,23,0.06);overflow:auto}
    .tooltip{position:absolute;pointer-events:none;background:#111827;color:#fff;padding:6px 8px;border-radius:6px;font-size:12px;opacity:0;transition:opacity .12s}
    /* popup */
    .popup-backdrop{display:none;position:fixed;inset:0;background:rgba(2,6,23,0.5);align-items:center;justify-content:center;padding:18px}
    .modal-content{background:#fff;padding:14px;border-radius:8px;max-width:760px;width:100%;box-shadow:0 8px 30px rgba(2,6,23,0.12)}
    .user-table{width:100%;border-collapse:collapse;font-size:13px}
    .user-table th,.user-table td{border-bottom:1px solid #e6edf3;padding:6px;text-align:left}
    .controls-backdrop{display:none;position:fixed;inset:0;background:rgba(2,6,23,0.35);align-items:center;justify-content:center;padding:18px}
    .controls-modal{background:#fff;padding:12px;border-radius:8px;width:360px;box-shadow:0 8px 30px rgba(2,6,23,0.12)}
    .checkbox-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:6px;max-height:220px;overflow:auto;padding:6px}
    .checkbox-item{font-size:13px}
    .link-btn{margin-right:8px;display:inline-block;padding:6px;border-radius:6px;background:#eef2ff;color:#1e3a8a;cursor:pointer;font-size:12px}
    /* node label */
    .node-label { font-family: Inter, system-ui, Arial; font-size:11px; fill: #0f172a; font-weight:600; }
    .subtitle { font-size:10px; fill:#475569; font-weight:400; }
  </style>
</head>
<body>

  <div class="header">
    <div>
      <div class="header-title">üåê Merotra Network Tree</div>
      <div class="header-sub">Window ‚Üí PON ‚Üí Level 1 ‚Üí Level 2 ‚Üí ... (sheet-order preserved)</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <button id="controlsBtn" class="btn btn-secondary">Filters</button>
      <button id="reloadBtn" class="btn">Reload</button>
    </div>
  </div>

  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <!-- POPUP -->
  <div id="popupModal" class="popup-backdrop">
    <div class="modal-content">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px">
        <div>
          <h2 id="popupTitle" style="margin:0;font-size:16px"></h2>
          <div id="popupPath" style="font-size:12px;color:#475569"></div>
        </div>
        <button id="popupClose" class="btn btn-secondary" style="height:30px">Close</button>
      </div>

      <div id="popupMeta" style="font-size:13px;color:#334155;margin-bottom:8px"></div>
      <div id="popupLinks" style="margin-bottom:8px"></div>

      <h3 style="margin:8px 0 6px;font-size:14px">Users</h3>
      <div style="max-height:300px;overflow:auto">
        <table id="popupUsersTable" class="user-table"></table>
      </div>

      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="btnShot" class="btn">üì∏ Screenshot</button>
        <button id="btnCsv" class="btn btn-secondary">üìä CSV</button>
      </div>
    </div>
  </div>

  <!-- CONTROLS -->
  <div id="controlsModal" class="controls-backdrop">
    <div class="controls-modal">
      <h3 style="margin:0 0 8px">Filters</h3>

      <div style="margin-bottom:10px">
        <div style="font-weight:600;font-size:13px">Windows</div>
        <div id="windowFilters" class="checkbox-grid"></div>
        <div style="text-align:center;margin-top:6px;font-size:12px;color:#64748b">
          <a href="#" onclick="selectAll('window');return false">Select All</a> |
          <a href="#" onclick="deselectAll('window');return false">Deselect All</a>
        </div>
      </div>

      <div style="margin-bottom:10px">
        <div style="font-weight:600;font-size:13px">PONs</div>
        <div id="ponFilters" class="checkbox-grid"></div>
        <div style="text-align:center;margin-top:6px;font-size:12px;color:#64748b">
          <a href="#" onclick="selectAll('pon');return false">Select All</a> |
          <a href="#" onclick="deselectAll('pon');return false">Deselect All</a>
        </div>
      </div>

      <div style="display:flex;gap:8px">
        <button id="applyFiltersBtn" class="btn" style="flex:1">Apply</button>
        <button id="controlsClose" class="btn btn-secondary" style="flex:1">Close</button>
      </div>
    </div>
  </div>

<script>
  // -------------- CONFIG --------------
  const BOARD_URL = "https://script.google.com/macros/s/AKfycbzItUueYIqcUuCn2cDaTTrWIF0LiilUxOXhhL-4b4D9aUlEo8Ov9pasR44d6JSM3h1t/exec?mode=board";

  // -------------- STATE --------------
  const tooltip = document.getElementById("tooltip");
  const popupModal = document.getElementById("popupModal");
  const controlsModal = document.getElementById("controlsModal");
  const popupTitleEl = document.getElementById("popupTitle");
  const popupPathEl  = document.getElementById("popupPath");
  const popupMetaEl  = document.getElementById("popupMeta");
  const popupLinksEl = document.getElementById("popupLinks");
  const popupUsersTbl = document.getElementById("popupUsersTable");

  let rawBoard = {};    // shaped by transformServerToBoard
  let serverSummary = null;
  let currentTreeData = null;

  let filters = { windows: [], pons: [] };
  let currentPopupRows = [];

  // -------------- HELPERS --------------
  function normalizeId(v){ return (v ?? "").toString().trim().replace(/\s+/g,'').toLowerCase(); }

  // Transform server JSON (new shape with windows -> pons -> levels -> splitters)
  // into board: { pon: { window: winName, levels: [ { level:1, splitters: [...] }, ... ] } }
  function transformServerToBoard(serverJson) {
    const board = {};
    if (!serverJson || !Array.isArray(serverJson.windows)) return board;

    serverJson.windows.forEach(win => {
      const winName = win.window || "UNKNOWN";
      (win.pons || []).forEach(pon => {
        const ponName = pon.pon || "NOPON";
        if (!board[ponName]) board[ponName] = {};
        // keep multiple windows per pon possible; store under window name
        if (!board[ponName][winName]) board[ponName][winName] = { levels: [] };

        // levels expected as array in correct sheet order already
        const levels = Array.isArray(pon.levels) ? pon.levels : [];

        // convert splitters inside each level to normalized objects
        const cleanLevels = levels.map(l => {
          const lvlNum = (typeof l.level === 'number') ? l.level : (l.level ? Number(l.level) : null);
          const splitters = Array.isArray(l.splitters) ? l.splitters.map(s => {
            // s expected: { recordId, type, users:[], total }
            return {
              recordId: s.recordId ?? (s.timestamp ?? ""),
              type: s.type ?? s.splitType ?? "",
              users: Array.isArray(s.users) ? s.users.map(u => (typeof u === 'object' && u !== null) ? (u.id ?? String(u)) : String(u)) : [],
              total: typeof s.total === 'number' ? s.total : (Array.isArray(s.users) ? s.users.length : (s.total ? Number(s.total) : 0))
            };
          }) : [];
          // filter-out empty splitters if user wanted, but you asked to remove empty levels later; keep empties for now
          return { level: lvlNum, splitters };
        });

        // assign
        board[ponName][winName].levels = cleanLevels;
      });
    });

    return board;
  }

  // -------------- INIT / UI bindings --------------
  document.getElementById("reloadBtn").addEventListener("click", ()=> loadAll(true));
  document.getElementById("controlsBtn").addEventListener("click", ()=> { controlsModal.style.display='flex'; });
  document.getElementById("controlsClose").addEventListener("click", ()=> { controlsModal.style.display='none'; });
  document.getElementById("popupClose").addEventListener("click", ()=> { popupModal.style.display='none'; });
  document.getElementById("applyFiltersBtn").addEventListener("click", applyFiltersFromUI);
  document.getElementById("btnShot").addEventListener("click", downloadScreenshot);
  document.getElementById("btnCsv").addEventListener("click", downloadCSV);

  window.addEventListener("resize", ()=> { if (currentTreeData) drawTree(currentTreeData); });

  // page load
  loadAll(false);

  async function loadAll(showToast) {
    try {
      setLoading(true);
      const res = await fetch(BOARD_URL);
      if (!res.ok) throw new Error("Board API fetch failed: "+res.status);
      const serverJson = await res.json();
      serverSummary = serverJson.summary || null;

      rawBoard = transformServerToBoard(serverJson);

      setupFiltersFromBoard();
      const filtered = filterBoard(rawBoard, filters);
      const treeData = buildHierarchy(filtered);
      currentTreeData = treeData;
      drawTree(treeData);

      if (serverSummary && showToast) {
        console.info("Processed:", serverSummary.processedRows, "Skipped:", serverSummary.skippedRows);
      }
    } catch (err) {
      console.error(err);
      alert("Error loading board: " + (err.message || err));
    } finally {
      setLoading(false);
    }
  }

  function setLoading(flag){
    const btn = document.getElementById("reloadBtn");
    btn.textContent = flag ? "Loading..." : "Reload";
    btn.disabled = flag;
  }

  // -------------- FILTERS --------------
  function setupFiltersFromBoard(){
    const windowSet = new Set();
    const ponSet = new Set();

    Object.entries(rawBoard).forEach(([pon, winObj]) => {
      ponSet.add(pon);
      Object.keys(winObj || {}).forEach(w => windowSet.add(w));
    });

    filters.windows = Array.from(windowSet);
    filters.pons = Array.from(ponSet);

    const winDiv = document.getElementById("windowFilters");
    const ponDiv = document.getElementById("ponFilters");
    winDiv.innerHTML = ""; ponDiv.innerHTML = "";

    Array.from(windowSet).sort().forEach(w => {
      const el = document.createElement("div"); el.className="checkbox-item";
      el.innerHTML = `<label><input type="checkbox" value="${w}" checked> <span>${w}</span></label>`;
      winDiv.appendChild(el);
    });

    Array.from(ponSet).sort().forEach(p => {
      const el = document.createElement("div"); el.className="checkbox-item";
      el.innerHTML = `<label><input type="checkbox" value="${p}" checked> <span>${p}</span></label>`;
      ponDiv.appendChild(el);
    });
  }

  function selectAll(type){
    document.querySelectorAll(`#${type}Filters input[type="checkbox"]`).forEach(ch=>ch.checked=true);
  }
  function deselectAll(type){
    document.querySelectorAll(`#${type}Filters input[type="checkbox"]`).forEach(ch=>ch.checked=false);
  }

  function applyFiltersFromUI(){
    filters.windows = Array.from(document.querySelectorAll("#windowFilters input:checked")).map(i => i.value);
    filters.pons = Array.from(document.querySelectorAll("#ponFilters input:checked")).map(i => i.value);
    controlsModal.style.display='none';
    const filtered = filterBoard(rawBoard, filters);
    const treeData = buildHierarchy(filtered);
    currentTreeData = treeData;
    drawTree(treeData);
  }

  function filterBoard(board, filters){
    const out = {};
    Object.entries(board).forEach(([pon, winObj]) => {
      if (!filters.pons.includes(pon)) return;
      const newWin = {};
      Object.entries(winObj || {}).forEach(([win, obj]) => {
        if (!filters.windows.includes(win)) return;
        // remove empty levels (no splitters)
        const levels = (obj.levels || []).filter(l => Array.isArray(l.splitters) && l.splitters.length > 0);
        if (levels.length) newWin[win] = { levels };
      });
      if (Object.keys(newWin).length) out[pon] = newWin;
    });
    return out;
  }

  // -------------- parsePon (sorting) --------------
  function parsePon(pon) {
    const m = (pon || "").match(/O(\d+)I(\d+)P(\d+)/i);
    if (!m) return { olt:9999, ip:9999, port:9999 };
    return { olt:+m[1], ip:+m[2], port:+m[3] };
  }

  // -------------- BUILD HIERARCHY (for D3) --------------
  // We create: root -> windows -> pon -> level nodes (level1, level2, ...) -> splitter nodes
  function buildHierarchy(board) {
    const root = { nodeType: "root", name: "üåê Merotra Network", children: [] };
    const windowMap = {};

    // get sorted PON list (keeps earlier sorting behavior by OLT/IP/Port)
    const sortedPons = Object.entries(board).sort(([a],[b])=>{
      const A = parsePon(a), B = parsePon(b);
      if (A.olt !== B.olt) return A.olt - B.olt;
      if (A.ip !== B.ip) return A.ip - B.ip;
      return A.port - B.port;
    });

    sortedPons.forEach(([pon, winObj])=>{
      Object.entries(winObj || {}).forEach(([winName, obj])=>{
        if (!windowMap[winName]) {
          windowMap[winName] = { nodeType:"window", name: "ü™ü " + winName, rawWindow: winName, children: [] };
          root.children.push(windowMap[winName]);
        }
        const winNode = windowMap[winName];

        const ponNode = { nodeType:"pon", name:"üîå " + pon, rawPon: pon, window: winName, children: [], total:0 };

        // levels array preserved in sheet order
        const levels = (obj.levels || []).slice(); // copy
        // remove empty levels already done in filter but safe-guard
        const nonEmptyLevels = levels.filter(l => Array.isArray(l.splitters) && l.splitters.length > 0);

        // construct level nodes in same order (level number used if provided)
        nonEmptyLevels.forEach((lvlObj, idx) => {
          const lvlNum = (typeof lvlObj.level === 'number' && !isNaN(lvlObj.level)) ? lvlObj.level : (idx+1);
          const levelNode = {
            nodeType: "level",
            name: `Level ${lvlNum}`,
            level: lvlNum,
            children: []
          };

          // each splitter node preserved in same order as in JSON (which you requested = sheet order)
          (lvlObj.splitters || []).forEach(sp => {
            const usersArr = Array.isArray(sp.users) ? sp.users.map(u => (typeof u === 'object' && u !== null) ? (u.id ?? String(u)) : String(u)).filter(Boolean) : [];
            const spNode = {
              nodeType: "splitter",
              name: `${sp.type || "splitter"} ${sp.recordId ? "‚Ä¢ " + sp.recordId : ""}`,
              recordId: sp.recordId || "",
              type: sp.type || "",
              users: usersArr,
              total: (typeof sp.total === 'number' ? sp.total : usersArr.length),
              children: []
            };
            levelNode.children.push(spNode);
          });

          // only add level if it has splitters
          if (levelNode.children.length > 0) {
            ponNode.children.push(levelNode);
          }
        });

        // compute pon total = unique union of all splitters users
        const union = new Set();
        ponNode.children.forEach(levelN => {
          levelN.children.forEach(s => (s.users || []).forEach(u => union.add(u)));
        });
        ponNode.total = union.size;
        winNode.children.push(ponNode);
      });
    });

    return root;
  }

  // -------------- DRAW TREE (D3) --------------
  function drawTree(data) {
    // remove old
    d3.select("#chart").selectAll("*").remove();

    const chartEl = document.getElementById("chart");
    const width = chartEl.clientWidth || Math.max(window.innerWidth-40,1200);
    const height = Math.max(window.innerHeight - 220, 420);

    // We'll layout the tree left-to-right by depth (columns). Compute max depth dynamically.
    const flatten = [];
    const nodesByDepth = [];
    function walk(n, depth) {
      if (!nodesByDepth[depth]) nodesByDepth[depth] = [];
      nodesByDepth[depth].push(n);
      (n.children || []).forEach(ch => walk(ch, depth+1));
    }
    walk(data, 0);
    const depthCount = nodesByDepth.length;
    const colWidth = Math.max(180, Math.min(300, Math.floor((width - 160) / Math.max(1, depthCount-1))));

    // create svg
    const svg = d3.select("#chart").append("svg").attr("width", width).attr("height", height);
    const g = svg.append("g").attr("transform", "translate(20,20)");

    // compute positions for nodes: for each depth (column), spread nodes vertically
    const positions = new Map();
    for (let d = 0; d < nodesByDepth.length; d++) {
      const col = nodesByDepth[d];
      const gap = Math.max(40, Math.floor((height - 120) / (col.length + 1)));
      const x = d * colWidth;
      for (let i = 0; i < col.length; i++) {
        const y = (i+1) * gap;
        positions.set(col[i], { x: x, y: y });
      }
    }

    // collect link lines between parent-child (straight horizontal-ish lines - dotted)
    const links = [];
    // walk again to produce pairs
    function collectLinks(n) {
      const ppos = positions.get(n);
      (n.children || []).forEach(ch => {
        const cpos = positions.get(ch);
        if (ppos && cpos) links.push({ source: ppos, target: cpos });
        collectLinks(ch);
      });
    }
    collectLinks(data);

    // draw links (dotted)
    g.selectAll(".link")
      .data(links)
      .enter()
      .append("path")
      .attr("class","link")
      .attr("d", d => {
        // curved horizontal path: start at source.x+circleOffset to target.x-circleOffset
        const sx = d.source.x + 80;
        const sy = d.source.y;
        const tx = d.target.x;
        const ty = d.target.y;
        // horizontal cubic bezier
        const mx = (sx + tx) / 2;
        return `M${sx},${sy} C ${mx},${sy} ${mx},${ty} ${tx},${ty}`;
      })
      .attr("fill","none")
      .attr("stroke","#94a3b8")
      .attr("stroke-width",1.5)
      .attr("stroke-dasharray","4 6")
      .attr("opacity",0.9);

    // render nodes as groups
    const allNodes = [];
    function collectNodes(n) {
      allNodes.push(n);
      (n.children || []).forEach(ch => collectNodes(ch));
    }
    collectNodes(data);

    const nodeG = g.selectAll(".node")
      .data(allNodes)
      .enter()
      .append("g")
      .attr("class","node")
      .attr("transform", d => {
        const p = positions.get(d);
        if (!p) return "translate(0,0)";
        return `translate(${p.x + 80},${p.y})`; // 80px offset for nicer spacing
      })
      .style("cursor","pointer");

    // circles (only for root/window/pon/level header and splitters we want circles: user asked circles like before)
    nodeG.append("circle")
      .attr("r", d => {
        if (d.nodeType === "root") return 26;
        if (d.nodeType === "window") return 20;
        if (d.nodeType === "pon") return 18;
        if (d.nodeType === "level") return 12;
        if (d.nodeType === "splitter") return 14;
        return 10;
      })
      .attr("fill", d => {
        if (d.nodeType === "root") return "#1e3a8a";
        if (d.nodeType === "window") return "#1d4ed8";
        if (d.nodeType === "pon") return "#0f766e";
        if (d.nodeType === "level") return "#f1f5f9";
        if (d.nodeType === "splitter") return (d.total && d.total>0) ? "#10b981" : "#6b7280";
        return "#94a3b8";
      })
      .attr("stroke","#fff")
      .attr("stroke-width", d => (d.nodeType==="splitter"||d.nodeType==="level") ? 2 : 3);

    // labels
    nodeG.append("text")
      .attr("class","node-label")
      .attr("dy", d => {
        if (d.nodeType === "root") return "0.32em";
        if (d.nodeType === "window") return "0.32em";
        if (d.nodeType === "pon") return "0.32em";
        return "0.35em";
      })
      .attr("x", d => 22)
      .attr("text-anchor", "start")
      .text(d => {
        if (d.nodeType === "root") return d.name;
        if (d.nodeType === "window") return d.name;
        if (d.nodeType === "pon") return `${d.name} (${d.total || 0})`;
        if (d.nodeType === "level") return d.name;
        if (d.nodeType === "splitter") return `${d.name} (${d.total || (d.users ? d.users.length : 0)})`;
        return d.name;
      })
      .style("font-size", d => d.nodeType==="root" ? "14px" : (d.nodeType==="window" ? "13px" : (d.nodeType==="pon" ? "12px" : "11px")));

    // level subtitle (smaller)
    nodeG.filter(d => d.nodeType === "splitter")
      .append("text")
      .attr("class","subtitle")
      .attr("x", 22)
      .attr("dy", "1.4em")
      .text(d => d.type ? d.type : "");

    // interactions
    nodeG.on("mousemove", (event, d) => {
        handleMouseOver(event, { data: d });
      })
      .on("mouseout", ()=> tooltip.style.opacity = 0)
      .on("click", (event, d) => handleNodeClick(event, { data: d }));

    // fit to view (center & scale to fit)
    fitToView(svg, g);
  }

  function fitToView(svgRoot, g) {
    try {
      const chart = document.getElementById("chart");
      const bounds = g.node().getBBox();
      const fullWidth = chart.clientWidth;
      const fullHeight = chart.clientHeight;
      const widthScale = fullWidth / (bounds.width + 160);
      const heightScale = fullHeight / (bounds.height + 160);
      const scale = Math.min(1.6, Math.max(0.5, Math.min(widthScale, heightScale)));
      const tx = -(bounds.x)*scale + 40;
      const ty = -(bounds.y)*scale + 40;
      svgRoot.transition().duration(600).call(
        d3.zoom().transform,
        d3.zoomIdentity.translate(tx,ty).scale(scale)
      );
    } catch(e) {
      // ignore
    }
  }

  // -------------- TOOLTIP & POPUP --------------
  function handleMouseOver(event, d) {
    const data = d.data;
    let html = `<strong>${data.name}</strong><br/>`;
    if (data.nodeType === "window") html += `Window`;
    else if (data.nodeType === "pon") html += `PON: ${data.rawPon || ""}<br/>Total users: ${data.total || 0}`;
    else if (data.nodeType === "level") html += `Level ${data.level}`;
    else if (data.nodeType === "splitter") {
      html += `Record: ${data.recordId || "-"}<br/>Type: ${data.type || "-"}<br/>Users: <strong>${data.total || (data.users ? data.users.length : 0)}</strong>`;
    }
    tooltip.innerHTML = html;
    tooltip.style.left = (event.pageX + 12) + "px";
    tooltip.style.top  = (event.pageY + 8) + "px";
    tooltip.style.opacity = 1;
  }

  function handleNodeClick(event, d) {
    const data = d.data;
    if (data.nodeType !== "splitter") return;

    const total = data.total || (data.users ? data.users.length : 0);
    popupTitleEl.textContent = `${data.name} ‚Äî Users`;
    popupPathEl.textContent = `${data.window || ""} ‚Üí ${data.pon || data.rawPon || ""} ‚Üí ${data.name}`;
    popupMetaEl.innerHTML = `<div><strong>Total users:</strong> ${total}</div><div><strong>Record ID:</strong> ${data.recordId || "-"}</div><div><strong>Type:</strong> ${data.type || "-"}</div>`;

    let linksHtml = "";
    popupLinksEl.innerHTML = linksHtml || "";

    buildUserTable(data);
    popupModal.style.display = 'flex';
  }

  function buildUserTable(data) {
    const rawUsers = data.users || [];
    const users = rawUsers.map(u => (typeof u === 'object' && u !== null) ? (u.id ?? "") : String(u));
    popupUsersTbl.innerHTML = `
      <thead>
        <tr><th style="width:36px">Sr</th><th>User ID</th></tr>
      </thead>
      <tbody></tbody>
    `;
    const tbody = popupUsersTbl.querySelector("tbody");
    currentPopupRows = [];

    users.forEach((rawId, idx) => {
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${idx+1}</td><td>${rawId}</td>`;
      tbody.appendChild(tr);
      currentPopupRows.push({ sr: idx+1, id: rawId });
    });
  }

  // -------------- DOWNLOADS --------------
  function downloadScreenshot(){
    const chartEl = document.getElementById("chart");
    html2canvas(chartEl).then(canvas=>{
      const link = document.createElement("a");
      const today = new Date().toISOString().slice(0,10);
      link.download = `merotra-tree-${today}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    });
  }

  function downloadCSV(){
    if (!currentPopupRows.length) return;
    const header = ["Sr","User ID"];
    const lines = [header.join(",")];
    currentPopupRows.forEach(r=>{
      const row = [ r.sr, `"${(r.id||"").replace(/"/g,'""')}"` ];
      lines.push(row.join(","));
    });
    const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    const today = new Date().toISOString().slice(0,10);
    link.href = url; link.download = `merotra-users-${today}.csv`; link.click();
    URL.revokeObjectURL(url);
  }

</script>
</body>
</html>
