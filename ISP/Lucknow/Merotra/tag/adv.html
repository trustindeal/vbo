<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merotra ‚Äî PON / Splitter Tree (column layout)</title>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- external styling (you provided adv.css) -->
  <link rel="stylesheet" href="adv.css">

  <!-- Screenshot lib -->
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

  <style>
    /* small local tweaks to integrate with adv.css */
    body { padding: 10px; background: transparent; }
    /* Keep tooltip style if adv.css not present for some reason */
    .tooltip { position: absolute; pointer-events: none; background: rgba(15,23,42,0.9); color: #fff; padding: 6px 8px; border-radius: 6px; font-size: 12px; opacity: 0; transition: opacity .12s; z-index: 9999; }
    /* node text tweak */
    .node-text { font-family: Inter, system-ui, Arial; font-weight: 600; font-size: 11px; fill: #0f172a; }
    .small-text { font-weight: 500; font-size: 10px; fill: #475569; }
    /* dotted vertical separators between columns */
    .col-sep { stroke: #e6edf3; stroke-dasharray: 3 6; stroke-width: 1; }
    /* make links gently translucent to reduce visual clutter */
    .link { fill: none; stroke-width: 2.2; opacity: 0.92; }
    .link.light { opacity: 0.6; stroke-width: 1.6; }
    /* splitters circle */
    .split-circle { stroke: #fff; stroke-width: 2; }
    .pon-circle { stroke: #fff; stroke-width: 2; }
    .window-circle { stroke: #fff; stroke-width: 2; }
  </style>
</head>
<body>

  <div class="header">
    <div>
      <div class="header-title">üåê Merotra Network Tree</div>
      <div class="header-sub">Window ‚Üí PON ‚Üí Level columns ‚Üí Splitters (vertical)</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <button id="controlsBtn" class="btn btn-secondary">Filters</button>
      <button id="reloadBtn" class="btn">Reload</button>
    </div>
  </div>

  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <!-- POPUP (unchanged) -->
  <div id="popupModal" class="popup-backdrop">
    <div class="modal-content">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px">
        <div>
          <h2 id="popupTitle" style="margin:0;font-size:16px"></h2>
          <div id="popupPath" style="font-size:12px;color:#475569"></div>
        </div>
        <button id="popupClose" class="btn btn-secondary" style="height:30px">Close</button>
      </div>

      <div id="popupMeta" style="font-size:13px;color:#334155;margin-bottom:8px"></div>
      <div id="popupLinks" style="margin-bottom:8px"></div>

      <h3 style="margin:8px 0 6px;font-size:14px">Users</h3>
      <div style="max-height:300px;overflow:auto">
        <table id="popupUsersTable" class="user-table"></table>
      </div>

      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="btnShot" class="btn">üì∏ Screenshot</button>
        <button id="btnCsv" class="btn btn-secondary">üìä CSV</button>
      </div>
    </div>
  </div>

  <!-- CONTROLS (unchanged) -->
  <div id="controlsModal" class="controls-backdrop">
    <div class="controls-modal">
      <h3 style="margin:0 0 8px">Filters</h3>

      <div style="margin-bottom:10px">
        <div style="font-weight:600;font-size:13px">Windows</div>
        <div id="windowFilters" class="checkbox-grid"></div>
        <div style="text-align:center;margin-top:6px;font-size:12px;color:#64748b">
          <a href="#" onclick="selectAll('window');return false">Select All</a> |
          <a href="#" onclick="deselectAll('window');return false">Deselect All</a>
        </div>
      </div>

      <div style="margin-bottom:10px">
        <div style="font-weight:600;font-size:13px">PONs</div>
        <div id="ponFilters" class="checkbox-grid pon-grid"></div>
        <div style="text-align:center;margin-top:6px;font-size:12px;color:#64748b">
          <a href="#" onclick="selectAll('pon');return false">Select All</a> |
          <a href="#" onclick="deselectAll('pon');return false">Deselect All</a>
        </div>
      </div>

      <div style="display:flex;gap:8px">
        <button id="applyFiltersBtn" class="btn" style="flex:1">Apply</button>
        <button id="controlsClose" class="btn btn-secondary" style="flex:1">Close</button>
      </div>
    </div>
  </div>

<script>
  // -------------- CONFIG --------------
  const BOARD_URL = "https://script.google.com/macros/s/AKfycbzItUueYIqcUuCn2cDaTTrWIF0LiilUxOXhhL-4b4D9aUlEo8Ov9pasR44d6JSM3h1t/exec?mode=board";

  // Palette for branch colors (level-1 splitters). Add more if needed.
  const PALETTE = ["#2563eb","#059669","#d97706","#db2777","#7c3aed","#0ea5e9","#b91c1c","#065f46","#4b5563","#af7207","#be185d","#e11d48"];

  // -------------- STATE --------------
  const tooltip = document.getElementById("tooltip");
  const popupModal = document.getElementById("popupModal");
  const controlsModal = document.getElementById("controlsModal");
  const popupTitleEl = document.getElementById("popupTitle");
  const popupPathEl  = document.getElementById("popupPath");
  const popupMetaEl  = document.getElementById("popupMeta");
  const popupLinksEl = document.getElementById("popupLinks");
  const popupUsersTbl = document.getElementById("popupUsersTable");

  let rawBoard = null;
  let serverSummary = null;
  let currentTreeData = null;
  let filters = { windows: [], pons: [] };
  let currentPopupRows = [];
  const statusMaps = {}; // leave as before

  // -------------- HELPERS --------------
  function normalizeId(v){ return (v ?? "").toString().trim().replace(/\s+/g,'').toLowerCase(); }

  // NEW: Transform server JSON (new format) into board: { ponName: { windowName: { levels: [ {level:1, splitters: [...]}, ... ] } } }
  function transformServerToBoard(serverJson) {
    const out = {};
    if (!serverJson || !Array.isArray(serverJson.windows)) return out;
    serverJson.windows.forEach(win => {
      const winName = win.window || "Unknown";
      (win.pons || []).forEach(pon => {
        const ponName = pon.pon || "NOPON";
        if (!out[ponName]) out[ponName] = {};
        if (!out[ponName][winName]) out[ponName][winName] = { levels: [] };
        // keep levels in the same order as provided, but ignore empty rows
        const levels = (pon.levels || []).filter(l => l && Array.isArray(l.splitters) && l.splitters.length > 0)
                       .map(l => ({ level: +l.level, splitters: l.splitters.map(s => ({
                         recordId: s.recordId || "",
                         type: s.type || "",
                         users: Array.isArray(s.users) ? s.users.slice() : [],
                         total: +s.total || (Array.isArray(s.users) ? s.users.length : 0)
                       })))}));
        out[ponName][winName].levels = levels;
      });
    });
    return out;
  }

  // -------------- INIT / UI bindings --------------
  document.getElementById("reloadBtn").addEventListener("click", ()=> loadAll(true));
  document.getElementById("controlsBtn").addEventListener("click", ()=> { controlsModal.style.display='flex'; });
  document.getElementById("controlsClose").addEventListener("click", ()=> { controlsModal.style.display='none'; });
  document.getElementById("popupClose").addEventListener("click", ()=> { popupModal.style.display='none'; });
  document.getElementById("applyFiltersBtn").addEventListener("click", applyFiltersFromUI);
  document.getElementById("btnShot").addEventListener("click", downloadScreenshot);
  document.getElementById("btnCsv").addEventListener("click", downloadCSV);
  window.addEventListener("resize", ()=> { if (currentTreeData) drawTree(currentTreeData); });

  // page load
  loadAll(false);

  async function loadAll(showToast) {
    try {
      setLoading(true);
      const res = await fetch(BOARD_URL);
      if (!res.ok) throw new Error("Board API fetch failed: "+res.status);
      const serverJson = await res.json();
      serverSummary = serverJson.summary || null;
      rawBoard = transformServerToBoard(serverJson);
      setupFiltersFromBoard();
      const filtered = filterBoard(rawBoard, filters);
      const treeData = buildHierarchy(filtered);
      currentTreeData = treeData;
      drawTree(treeData);
      if (serverSummary && showToast) {
        console.info("Processed:", serverSummary.processedRows, "Skipped:", serverSummary.skippedRows);
      }
    } catch (err) {
      console.error(err);
      alert("Error loading board: " + (err.message || err));
    } finally {
      setLoading(false);
    }
  }

  function setLoading(flag){
    const btn = document.getElementById("reloadBtn");
    btn.textContent = flag ? "Loading..." : "Reload";
    btn.disabled = flag;
  }

  // -------------- FILTERS --------------
  function setupFiltersFromBoard(){
    const windowSet = new Set();
    const ponSet = new Set();
    Object.entries(rawBoard || {}).forEach(([pon, winObj]) => {
      ponSet.add(pon);
      Object.keys(winObj || {}).forEach(w => windowSet.add(w));
    });
    filters.windows = Array.from(windowSet);
    filters.pons = Array.from(ponSet);
    const winDiv = document.getElementById("windowFilters");
    const ponDiv = document.getElementById("ponFilters");
    winDiv.innerHTML = ""; ponDiv.innerHTML = "";
    Array.from(windowSet).sort().forEach(w => {
      const el = document.createElement("div"); el.className="checkbox-item";
      el.innerHTML = `<label><input type="checkbox" value="${w}" checked> <span>${w}</span></label>`;
      winDiv.appendChild(el);
    });
    Array.from(ponSet).sort().forEach(p => {
      const el = document.createElement("div"); el.className="checkbox-item";
      el.innerHTML = `<label><input type="checkbox" value="${p}" checked> <span>${p}</span></label>`;
      ponDiv.appendChild(el);
    });
  }

  function selectAll(type){ document.querySelectorAll(`#${type}Filters input[type="checkbox"]`).forEach(ch=>ch.checked=true); }
  function deselectAll(type){ document.querySelectorAll(`#${type}Filters input[type="checkbox"]`).forEach(ch=>ch.checked=false); }

  function applyFiltersFromUI(){
    filters.windows = Array.from(document.querySelectorAll("#windowFilters input:checked")).map(i => i.value);
    filters.pons = Array.from(document.querySelectorAll("#ponFilters input:checked")).map(i => i.value);
    controlsModal.style.display='none';
    const filtered = filterBoard(rawBoard, filters);
    const treeData = buildHierarchy(filtered);
    currentTreeData = treeData;
    drawTree(treeData);
  }

  function filterBoard(board, filters){
    const out = {};
    Object.entries(board).forEach(([pon, winObj]) => {
      if (!filters.pons.includes(pon)) return;
      const newWin = {};
      Object.entries(winObj || {}).forEach(([win, info]) => {
        if (!filters.windows.includes(win)) return;
        // drop empty levels
        const levels = (info.levels || []).filter(l => Array.isArray(l.splitters) && l.splitters.length>0);
        if (levels.length) newWin[win] = { levels };
      });
      if (Object.keys(newWin).length) out[pon] = newWin;
    });
    return out;
  }

  // -------------- parsePon (sorting) --------------
  function parsePon(pon) {
    const m = (pon || "").match(/O(\d+)I(\d+)P(\d+)/i);
    if (!m) return { olt:9999, ip:9999, port:9999 };
    return { olt:+m[1], ip:+m[2], port:+m[3] };
  }

  // -------------- BUILD HIERARCHY for columns --------------
  // We'll produce: root -> window -> pon -> levelNodes[] -> splitters
  function buildHierarchy(board) {
    const root = { nodeType: "root", name: "üåê Merotra Network", children: [] };
    const windowMap = {};

    // Helper to preserve window order: gather all windows across PONs, but we'll rely on parsePon for PON order
    // Build window nodes by scanning PONs sorted by parsePon
    const sortedPons = Object.entries(board).sort(([a],[b])=>{
      const A = parsePon(a), B = parsePon(b);
      if (A.olt !== B.olt) return A.olt - B.olt;
      if (A.ip !== B.ip) return A.ip - B.ip;
      return A.port - B.port;
    });

    // Build windows => ensures each window node created once
    sortedPons.forEach(([pon, winObj])=>{
      Object.keys(winObj || {}).forEach(winName=>{
        if (!windowMap[winName]) {
          const wNode = { nodeType:"window", name: "ü™ü " + winName, rawWindow: winName, children: [] };
          windowMap[winName] = wNode;
          root.children.push(wNode);
        }
      });
    });

    // For each PON (sorted), attach PON nodes under appropriate window node
    sortedPons.forEach(([pon, winObj])=>{
      Object.entries(winObj || {}).forEach(([winName, info])=>{
        const winNode = windowMap[winName];
        const ponNode = { nodeType:"pon", name:"üîå " + pon, rawPon: pon, window: winName, children: [], meta:{levelsCount:0} };

        // levels array - keep sheet order; skip empty
        const levels = (info.levels || []).filter(l => l && Array.isArray(l.splitters) && l.splitters.length>0);
        if (levels.length === 0) {
          winNode.children.push(ponNode);
          return;
        }

        // Build a placeholder level node for each level to keep columns aligned
        // levelNode = { nodeType: 'level', level: N, children: [splitterNodes...] }
        const levelNodes = [];
        levels.forEach((lvlObj, idx) => {
          const lvlNum = +lvlObj.level || (idx+1);
          const levelNode = { nodeType: "level", level: lvlNum, children: [] };
          // splitters preserved in provided order (sheet order)
          lvlObj.splitters.forEach((s, sIdx) => {
            const splitterNode = {
              nodeType: "splitter",
              name: `${s.type}${s.recordId ? " ‚Äî " + s.recordId : ""}`,
              recordId: s.recordId || "",
              type: s.type || "",
              users: Array.isArray(s.users) ? s.users.slice() : [],
              total: +s.total || (Array.isArray(s.users) ? s.users.length : 0),
              level: lvlNum,
              levelIndex: idx,   // 0-based level index
              orderIndex: sIdx,  // position within level (sheet order)
              children: []
            };
            levelNode.children.push(splitterNode);
          });
          levelNodes.push(levelNode);
        });

        // attach levelNodes under pon (so visual columns: pon -> level1 -> splitters, level2 -> splitters...)
        ponNode.children = levelNodes;
        ponNode.meta.levelsCount = levelNodes.length;

        // push pon under win node
        winNode.children.push(ponNode);
      });
    });

    return root;
  }

  // -------------- DRAW (columns + colored branches + selective links) --------------
  function drawTree(data) {
    d3.select("#chart").select("svg").remove();
    const chartEl = document.getElementById("chart");
    const width = chartEl.clientWidth || Math.max(window.innerWidth - 40, 1000);
    const height = Math.max(window.innerHeight - 120, 560);

    const svg = d3.select("#chart").append("svg").attr("width", width).attr("height", height);

    // margins & layout settings
    const margin = {left: 40, top: 40, right: 40, bottom: 40};
    const usableW = width - margin.left - margin.right;
    const usableH = height - margin.top - margin.bottom;

    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    // Build flattened layout: compute positions column wise
    // columns: 0=root, 1=window, 2=pon, 3=level1 splitters, 4=level2 splitters, ...
    // We need to find maximum levels across all PONs to know number of columns
    const windows = data.children || [];
    // gather pon-levels info
    let maxLevels = 0;
    windows.forEach(w => {
      (w.children || []).forEach(p => {
        const L = p.meta && p.meta.levelsCount ? p.meta.levelsCount : (p.children ? p.children.length : 0);
        if (L > maxLevels) maxLevels = L;
      });
    });

    // compute columns count: window(0) + pon(1) + maxLevels columns for splitters
    const columnsCount = 2 + maxLevels; // 0-window column,1-pon, 2.. = levels
    const colW = Math.max(170, Math.floor(usableW / columnsCount)); // column width
    const totalColsWidth = colW * columnsCount;
    // center horizontally
    const xOffset = (usableW - totalColsWidth) / 2;

    // vertical spacing: we'll compute per column based on items
    // We'll map each node to an object with computed x,y and references for links
    const nodePositions = [];
    const windowNodes = []; // window-level positions
    const ponNodes = [];    // pon-level positions
    const splitterNodes = []; // all splitter nodes

    // Helper for parsing OLT to decide windows->pon mapping color or separate later (not needed because window already assigned)
    // Build windows column positions
    const winX = xOffset + 0*colW + colW/2;
    const ponX  = xOffset + 1*colW + colW/2;

    // compute Y positions for windows down the column (distribute)
    const winSpacing = Math.max(80, Math.floor(usableH / Math.max(1, windows.length)));
    windows.forEach((w, wi) => {
      const wy = wi * winSpacing + winSpacing/2;
      const wnode = { data: w, x: winX, y: wy, children: [] };
      windowNodes.push(wnode);

      // PONs under this window: layout vertically under window
      const pons = w.children || [];
      const ponsCount = pons.length;
      // compute vertical slice for these pons
      const ponsStartY = wy - Math.min( (pnsBlockHeight(ponsCount, usableH)/2), (winSpacing * 0.9) );
      // simple distribution for pons
      const ponBlockHeight = pnsBlockHeight(ponsCount, usableH);
      for (let i=0;i<ponsCount;i++){
        const py = ponsStartY + (i+0.5) * (ponBlockHeight / Math.max(1, ponsCount));
        const pnode = { data: pons[i], x: ponX, y: py, parentWindow: wnode, children: [] };
        ponNodes.push(pnode);
        wnode.children.push(pnode);

        // For each level (columns 2..), compute splitter positions vertically inside a block aligned to the pon's py and spread.
        const levels = pons[i].children || [];
        levels.forEach((lvlNode, lvlIndex) => {
          const colIndex = 2 + lvlIndex;
          const colX = xOffset + colIndex*colW + colW/2;
          const splitters = lvlNode.children || [];
          const n = splitters.length;
          const verticalSpan = Math.max(120, Math.min(ponBlockHeight*0.95, 80 + n*28));
          const top = py - verticalSpan/2;
          splitters.forEach((s, si) => {
            const sy = top + (si+0.5) * (verticalSpan / Math.max(1, n));
            const snode = {
              data: s,
              x: colX,
              y: sy,
              pon: pnode,
              levelIndex: lvlIndex,
              levelNumber: lvlNode.level,
              orderIndex: si
            };
            splitterNodes.push(snode);
            pnode.children.push(snode);
          });
        });
      }
    });

    // helper functions
    function pnsBlockHeight(count, usableH) {
      // return block height assigned to pons under a window
      // simple heuristic: if many pons, spread across whole usableH
      if (count <= 2) return Math.min(usableH*0.5, 360);
      if (count <= 6) return Math.min(usableH*0.7, 560);
      return usableH * 0.9;
    }

    // Build quick lookup for splitters by pon+level to find L1 roots and assign branch colors
    // Level index 0 is level1 splitters
    const ponToLevel1 = new Map();
    const splitterIdToNode = new Map();
    // assign an internal id for every splitter to help
    splitterNodes.forEach((sn, idx) => {
      const key = `${sn.pon.data.rawPon}::L${sn.levelIndex}::I${sn.orderIndex}`;
      splitterIdToNode.set(key, sn);
      if (sn.levelIndex === 0) {
        if (!ponToLevel1.has(sn.pon.data.rawPon)) ponToLevel1.set(sn.pon.data.rawPon, []);
        ponToLevel1.get(sn.pon.data.rawPon).push(sn);
      }
    });

    // Assign branch colors: each level1 splitter (in sheet order) gets a color in PALETTE.
    const branchColorMap = new Map(); // splitter unique key -> color
    ponToLevel1.forEach((arr, ponKey) => {
      // arr is in sheet order because we preserved order building nodes
      arr.forEach((snode, idx) => {
        const color = PALETTE[(idx) % PALETTE.length];
        const key = `${snode.pon.data.rawPon}::L${snode.levelIndex}::I${snode.orderIndex}`;
        branchColorMap.set(key, color);
      });
    });

    // For deeper levels, choose parent (level-1 parent search algorithm):
    // For each splitter at level > 0, find candidate parents in previous level (same pon) and pick the one with MAX overlap in users.
    // If overlap==0 ‚Üí no link color (grey) and we won't draw parent->child link.
    function usersSet(arr){ return new Set((arr||[]).map(String)); }
    // create mapping for quick search: group splitters by pon and levelIndex
    const mapByPonLevel = {};
    splitterNodes.forEach(s => {
      const key = `${s.pon.data.rawPon}::L${s.levelIndex}`;
      if (!mapByPonLevel[key]) mapByPonLevel[key] = [];
      mapByPonLevel[key].push(s);
    });

    // now, for each level>0 splitter, find parent in level-1 (same pon)
    const links = []; // {source:node, target:node, color, overlap}
    splitterNodes.forEach(s => {
      if (s.levelIndex === 0) return; // L1 has no parent-level here
      const prevKey = `${s.pon.data.rawPon}::L${s.levelIndex-1}`;
      const parents = mapByPonLevel[prevKey] || [];
      if (!parents.length) return;
      // compute overlap with each parent
      const sSet = usersSet(s.data.users);
      let best = null; let bestOv = 0;
      parents.forEach(pn => {
        const pSet = usersSet(pn.data.users);
        let ov = 0;
        for (const u of sSet) if (pSet.has(u)) ov++;
        if (ov > bestOv) { bestOv = ov; best = pn; }
      });
      if (best && bestOv > 0) {
        // color inherited from parent's branch color if parent is L1 or parent has branchColor
        const parentKey = `${best.pon.data.rawPon}::L${best.levelIndex}::I${best.orderIndex}`;
        const color = branchColorMap.get(parentKey) || "#94a3b8";
        links.push({ source: best, target: s, color, overlap: bestOv });
      } else {
        // no overlapping parent -> no link (we still display node but no arrow)
      }
    });

    // Additionally, draw Window -> PON links (one per pon). Color can be derived from first level1 splitter if present, else neutral.
    const windowPonLinks = [];
    ponNodes.forEach(pn => {
      // find first level1 splitter under this pon to pick color
      const l1Key = `${pn.data.rawPon}::L0`;
      const l1 = mapByPonLevel[l1Key] || [];
      const color = (l1.length ? branchColorMap.get(`${pn.data.rawPon}::L0::I0`) : "#6b7280") || "#6b7280";
      windowPonLinks.push({ source: pn.parentWindow, target: pn, color });
    });

    // Draw column separators (dotted vertical lines) for clarity
    for (let col=0; col<columnsCount; col++){
      const cx = xOffset + col*colW;
      g.append("line")
        .attr("class","col-sep")
        .attr("x1", cx + colW*0.98 )
        .attr("x2", cx + colW*0.98 )
        .attr("y1", -20)
        .attr("y2", usableH + 40);
    }

    // Draw window nodes
    const winG = g.append("g").attr("class","windows");
    winG.selectAll("g.win")
      .data(windowNodes)
      .enter().append("g")
      .attr("transform", d => `translate(${d.x},${d.y})`)
      .each(function(d){
        d3.select(this).append("circle")
          .attr("r", 20)
          .attr("fill", "#1d4ed8")
          .attr("class","window-circle");
        d3.select(this).append("text")
          .attr("class","node-text")
          .attr("dy","0.36em")
          .attr("x", 28)
          .text(d.data.rawWindow);
      });

    // Draw PON nodes
    const ponG = g.append("g").attr("class","pons");
    ponG.selectAll("g.pon")
      .data(ponNodes)
      .enter().append("g")
      .attr("transform", d => `translate(${d.x},${d.y})`)
      .each(function(d){
        d3.select(this).append("circle")
          .attr("r", 16)
          .attr("fill", "#0f766e")
          .attr("class","pon-circle");
        d3.select(this).append("text")
          .attr("class","node-text")
          .attr("dy","0.36em")
          .attr("x", 22)
          .text(d.data.rawPon + (d.data.meta && d.data.meta.levelsCount ? ` (${d.data.meta.levelsCount})` : ""));
      });

    // Draw splitters (vertical stacks) as circles and labels
    const splitsG = g.append("g").attr("class","splitters");
    const splitSel = splitsG.selectAll("g.split")
      .data(splitterNodes)
      .enter().append("g")
      .attr("transform", d => `translate(${d.x},${d.y})`)
      .attr("cursor","pointer")
      .each(function(d){
        const primaryColorKey = `${d.pon.data.rawPon}::L${d.levelIndex}::I${d.orderIndex}`;
        // default fill grey; visible color for node body is white, stroke color shows branch color
        const strokeColor = (branchColorMap.get(primaryColorKey) || "#6b7280");
        d3.select(this).append("circle")
          .attr("r", 12)
          .attr("fill", "#ffffff")
          .attr("class","split-circle")
          .attr("stroke", strokeColor)
          .attr("stroke-width", 2.4);
        d3.select(this).append("text")
          .attr("class","node-text")
          .attr("dy","0.36em")
          .attr("x", 18)
          .text(`${d.data.type}${d.data.recordId ? " ‚Äî " + d.data.recordId : ""}`);
        d3.select(this).append("text")
          .attr("class","small-text")
          .attr("dy","1.8em")
          .attr("x", 18)
          .text(`Users: ${d.data.total || 0}`);
      })
      .on("mousemove", (event,d)=> {
        let html = `<strong>${d.data.type}${d.data.recordId ? " ‚Äî " + d.data.recordId : ""}</strong><br/>PON: ${d.pon.data.rawPon}<br/>Users: <strong>${d.data.total||0}</strong>`;
        tooltip.innerHTML = html;
        tooltip.style.left = (event.pageX + 12) + "px";
        tooltip.style.top  = (event.pageY + 8) + "px";
        tooltip.style.opacity = 1;
      })
      .on("mouseout", ()=> tooltip.style.opacity = 0)
      .on("click", (event, d) => {
        // Build popup
        const data = d.data;
        const total = data.total || (data.users ? data.users.length : 0);
        popupTitleEl.textContent = `${data.type}${data.recordId ? " ‚Äî " + data.recordId : ""} ‚Äî Users`;
        popupPathEl.textContent = `${d.pon.data.rawPon} ‚Üí level ${d.levelNumber}`;
        popupMetaEl.innerHTML = `<div><strong>Total users:</strong> ${total}</div>`;
        popupLinksEl.innerHTML = "";
        buildUserTable(data);
        popupModal.style.display = 'flex';
      });

    // DRAW Window->PON links first (behind splitters)
    const linkG = g.append("g").attr("class","links");
    linkG.selectAll("path.winpon")
      .data(windowPonLinks)
      .enter().append("path")
      .attr("class","link winpon")
      .attr("d", d => {
        // simple cubic bezier from window to pon; small horizontal offset so they don't overlap
        const sx = d.source.x, sy = d.source.y;
        const tx = d.target.x, ty = d.target.y;
        const mx = (sx + tx) / 2;
        // compute small vertical offset based on index of PON under same window to avoid overlap
        const siblings = d.source.children || [];
        const idx = (siblings.indexOf(d.target) >= 0) ? siblings.indexOf(d.target) : 0;
        const offset = (idx - (siblings.length-1)/2) * 6;
        return `M${sx},${sy} C ${mx},${sy+offset} ${mx},${ty+offset} ${tx},${ty}`;
      })
      .attr("stroke", d => d.color)
      .attr("fill", "none")
      .attr("opacity", 0.95);

    // DRAW splitter->splitter links (between adjacent levels) behind splitter nodes
    // To reduce crossing, compute small vertical offset per link based on target.orderIndex - source.orderIndex
    linkG.selectAll("path.slink")
      .data(links)
      .enter().append("path")
      .attr("class","link slink")
      .attr("d", d => {
        const sx = d.source.x, sy = d.source.y;
        const tx = d.target.x, ty = d.target.y;
        // determine horizontal mid points
        const mx = (sx + tx) / 2;
        // offset slightly by difference in order to spread curves
        const dy = (d.target.orderIndex - d.source.orderIndex) * 8;
        return `M${sx},${sy} C ${mx},${sy+dy} ${mx},${ty+dy} ${tx},${ty}`;
      })
      .attr("stroke", d => d.color)
      .attr("fill","none")
      .attr("opacity", 0.95);

    // finished - bring splitters on top (already appended later)
    // fit view: attempt to center and scale if overflow
    fitToView(svg, g, margin, width, height);
  }

  // fit to view simple function
  function fitToView(svg, g, margin, totalW, totalH) {
    try {
      const bounds = g.node().getBBox();
      const fullW = totalW - margin.left - margin.right;
      const fullH = totalH - margin.top - margin.bottom;
      const widthScale = fullW / (bounds.width + 60);
      const heightScale = fullH / (bounds.height + 60);
      const scale = Math.min(1.2, Math.max(0.5, Math.min(widthScale, heightScale)));
      const tx = -bounds.x * scale + margin.left + 20;
      const ty = -bounds.y * scale + margin.top + 20;
      svg.transition().duration(600).call(d3.zoom().transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
    } catch(e) {
      // ignore
    }
  }

  // -------------- TOOLTIP & POPUP helpers (unchanged) --------------
  function buildUserTable(data) {
    const rawUsers = data.users || [];
    const users = rawUsers.map(u => (typeof u === 'object' && u !== null) ? (u.id ?? "") : String(u));
    popupUsersTbl.innerHTML = `
      <thead>
        <tr><th style="width:36px">Sr</th><th>User ID</th><th>Name</th><th>Number</th><th>Location</th><th>Status</th></tr>
      </thead>
      <tbody></tbody>
    `;
    const tbody = popupUsersTbl.querySelector("tbody");
    currentPopupRows = [];
    users.forEach((rawId, idx) => {
      const normId = normalizeId(rawId);
      const dbRow = statusMaps[normId] || {};
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${idx+1}</td><td>${rawId}</td><td>${dbRow.name||""}</td><td>${dbRow.number||""}</td><td>${dbRow.location||""}</td><td>${dbRow.status||""}</td>`;
      tbody.appendChild(tr);
      currentPopupRows.push({ sr: idx+1, id: rawId, name: dbRow.name||"", number: dbRow.number||"", location: dbRow.location||"", status: dbRow.status||"" });
    });
  }

  function downloadScreenshot(){
    const modalContent = document.querySelector("#popupModal .modal-content");
    if (!modalContent) return;
    html2canvas(modalContent).then(canvas=>{
      const link = document.createElement("a");
      const today = new Date().toISOString().slice(0,10);
      link.download = `merotra-users-${today}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    });
  }

  function downloadCSV(){
    if (!currentPopupRows.length) return;
    const header = ["Sr","User ID","Name","Number","Location","Status"];
    const lines = [header.join(",")];
    currentPopupRows.forEach(r=>{
      const row = [
        r.sr,
        `"${r.id}"`,
        `"${(r.name||"").replace(/"/g,'""')}"`,
        `"${(r.number||"").replace(/"/g,'""')}"`,
        `"${(r.location||"").replace(/"/g,'""')}"`,
        `"${(r.status||"").replace(/"/g,'""')}"`
      ];
      lines.push(row.join(","));
    });
    const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    const today = new Date().toISOString().slice(0,10);
    link.href = url; link.download = `merotra-users-${today}.csv`; link.click();
    URL.revokeObjectURL(url);
  }

  // small isSubset helper still used elsewhere if needed
  function isSubset(aSet, bSet){
    for (const x of aSet) {
      if (!bSet.has(x)) return false;
    }
    return true;
  }

</script>
</body>
</html>
