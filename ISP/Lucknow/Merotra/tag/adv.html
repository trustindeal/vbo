<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merotra ‚Äî Hierarchical PON Tree</title>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- external adv.css (user provided) -->
  <link rel="stylesheet" href="adv.css">

  <!-- small fallback / tweaks -->
  <style>
    :root{font-family:Inter,system-ui,Arial}
    body{margin:0;padding:0;background:linear-gradient(135deg,#f0f9ff,#e0f2fe);color:#111827}
    /* Ensure chart fills remaining space */
    #chart { width:100%; height: calc(100vh - 64px); overflow:hidden; }
    .toolbar { display:flex; gap:8px; align-items:center }
    .search-folded { cursor:pointer; background:transparent; border:none; color:#2563eb; font-weight:700 }
    .search-input { width:220px; padding:6px 10px; border-radius:8px; border:1px solid #e5e7eb; display:none }
    @media (max-width:760px){
      .search-input{ width:140px }
    }
  </style>
</head>
<body>

  <div class="header">
    <div>
      <div class="header-title">üåê Merotra Network ‚Äî Hierarchical Tree</div>
      <div class="header-sub">Network ‚Üí Window ‚Üí OLT ‚Üí PON ‚Üí Level ‚Üí Splitter</div>
    </div>

    <div class="toolbar">
      <select id="windowFilter" style="padding:6px;border-radius:8px;border:1px solid #e5e7eb"></select>
      <select id="oltFilter" style="padding:6px;border-radius:8px;border:1px solid #e5e7eb"></select>
      <select id="ponFilter" style="padding:6px;border-radius:8px;border:1px solid #e5e7eb"></select>
      <button id="clearFilters" class="btn btn-secondary">Clear</button>

      <button id="searchFold" class="search-folded">üîç Search</button>
      <input id="searchInput" class="search-input" placeholder="Search user id or part..." />

      <button id="reloadBtn" class="btn">üîÑ Refresh</button>
    </div>
  </div>

  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <!-- Popup -->
  <div id="popupModal" class="popup-backdrop" style="display:none">
    <div class="modal-content">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px">
        <div>
          <h2 id="popupTitle" style="margin:0;font-size:16px"></h2>
          <div id="popupPath" style="font-size:12px;color:#475569"></div>
        </div>
        <button id="popupClose" class="btn btn-secondary" style="height:30px">Close</button>
      </div>
      <div id="popupMeta" style="font-size:13px;color:#334155;margin-bottom:8px"></div>
      <div style="max-height:60vh;overflow:auto">
        <table id="popupUsersTable" class="user-table"></table>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="btnShot" class="btn">üì∏ Screenshot</button>
        <button id="btnCsv" class="btn btn-secondary">üìä CSV</button>
      </div>
    </div>
  </div>

<script>
/* ================== CONFIG ================== */
const BOARD_URL = "https://script.google.com/macros/s/AKfycbzItUueYIqcUuCn2cDaTTrWIF0LiilUxOXhhL-4b4D9aUlEo8Ov9pasR44d6JSM3h1t/exec?mode=board";

/* ================== STATE ================== */
let rawJson = null;
let colorByOlt = new Map();
const tooltip = document.getElementById('tooltip');

/* UI refs */
const reloadBtn = document.getElementById('reloadBtn');
const popupModal = document.getElementById('popupModal');
const popupClose = document.getElementById('popupClose');
const popupTitle = document.getElementById('popupTitle');
const popupPath  = document.getElementById('popupPath');
const popupMeta  = document.getElementById('popupMeta');
const popupUsers = document.getElementById('popupUsersTable');

const windowFilter = document.getElementById('windowFilter');
const oltFilter = document.getElementById('oltFilter');
const ponFilter = document.getElementById('ponFilter');
const clearFilters = document.getElementById('clearFilters');

const searchFold = document.getElementById('searchFold');
const searchInput = document.getElementById('searchInput');

document.getElementById('btnShot').addEventListener('click', downloadScreenshot);
document.getElementById('btnCsv').addEventListener('click', downloadCSV);
reloadBtn.addEventListener('click', ()=> loadAndRender(true));
popupClose.addEventListener('click', ()=> { popupModal.style.display='none'; });

windowFilter.addEventListener('change', applyFiltersAndRender);
oltFilter.addEventListener('change', applyFiltersAndRender);
ponFilter.addEventListener('change', applyFiltersAndRender);
clearFilters.addEventListener('click', ()=> { windowFilter.value=''; oltFilter.value=''; ponFilter.value=''; applyFiltersAndRender(); });

searchFold.addEventListener('click', ()=>{
  if (searchInput.style.display === 'none' || searchInput.style.display === '') {
    searchInput.style.display = 'inline-block';
    searchInput.focus();
  } else {
    searchInput.style.display = 'none';
    searchInput.value = '';
    applyFiltersAndRender();
  }
});
searchInput.addEventListener('input', ()=> { applyFiltersAndRender(); });

/* ================== HELPERS ================== */

function normalizeId(v){ return (v ?? "").toString().trim(); }

function parsePonKey(pon){
  // expect O<olt>I<ip>P<port>
  const m = (pon || "").match(/O(\d+)I(\d+)P(\d+)/i);
  if (!m) return { olt:9999, ip:9999, port:9999 };
  return { olt: +m[1], ip: +m[2], port: +m[3] };
}

function getOltNumberFromPon(pon){
  const m = (pon || "").match(/O(\d+)/i);
  return m ? m[1] : "0";
}

function ensureColorForOlt(olt){
  if (!colorByOlt.has(olt)) {
    // create consistent palette with HSL spaced by map size
    const idx = colorByOlt.size;
    const h = (idx * 47) % 360; // spacing
    const color = `hsl(${h} 65% 45%)`;
    colorByOlt.set(olt, color);
  }
  return colorByOlt.get(olt);
}

/* ================== LOAD + TRANSFORM ================== */

async function loadAndRender(showToast=false){
  try {
    setLoading(true);
    const res = await fetch(BOARD_URL);
    if (!res.ok) throw new Error('Board API fetch failed: ' + res.status);
    const j = await res.json();
    rawJson = j;
    colorByOlt = new Map();
    buildFiltersFromJson(j);
    const filtered = applyClientFilters(j);
    const root = transformToHierarchy(filtered);
    renderTree(root);
    if (showToast) console.info('Loaded:', j.summary || {});
  } catch (err) {
    console.error(err);
    alert('Load failed: ' + (err.message || err));
  } finally {
    setLoading(false);
  }
}

function setLoading(flag){
  reloadBtn.textContent = flag ? 'Loading...' : 'üîÑ Refresh';
  reloadBtn.disabled = flag;
}

/* Build filter dropdowns */
function buildFiltersFromJson(j){
  // windows, olts, pons
  const winSet = new Set();
  const oltSet = new Set();
  const ponSet = new Set();

  (j.windows || []).forEach(win=>{
    winSet.add(win.window || '');
    (win.pons || []).forEach(p=>{
      ponSet.add(p.pon || '');
      oltSet.add(getOltNumberFromPon(p.pon || ''));
    });
  });

  // populate selects (add default blank option)
  function populate(sel, setVals){
    const prev = sel.value || '';
    sel.innerHTML = '';
    const opt = document.createElement('option'); opt.value=''; opt.textContent='(all)'; sel.appendChild(opt);
    Array.from(setVals).sort().forEach(v=>{
      const o = document.createElement('option'); o.value = v; o.textContent = v; sel.appendChild(o);
    });
    if (prev) sel.value = prev;
  }
  populate(windowFilter, winSet);
  populate(oltFilter, Array.from(oltSet).sort((a,b)=>+a-+b));
  populate(ponFilter, ponSet);
}

/* Apply client side filters + search */
function applyClientFilters(j){
  if (!j || !Array.isArray(j.windows)) return { windows: [] };
  const wsel = windowFilter.value;
  const oltsel = oltFilter.value;
  const ponsel = ponFilter.value;
  const search = (searchInput.value || '').trim().toLowerCase();

  const out = { windows: [] };

  j.windows.forEach(win=>{
    if (wsel && win.window !== wsel) return;
    const newWin = { window: win.window, pons: [] };
    (win.pons || []).forEach(p=>{
      if (ponsel && p.pon !== ponsel) return;
      if (oltsel && getOltNumberFromPon(p.pon || '') !== oltsel) return;

      // filter levels: only include levels with splitters array length>0
      const newLevels = (p.levels || []).filter(l => Array.isArray(l.splitters) && l.splitters.length > 0)
                                        .map(l => ({ level: l.level, splitters: l.splitters }));

      if (newLevels.length === 0 && search) {
        // still keep if search matches any user under this PON (deep scan)
        const matches = deepSearchMatch(p, search);
        if (!matches) return;
      } else if (newLevels.length === 0) {
        // If no levels AND no search, still show PON (user wanted PON static)
        // but we will keep PON with empty levels only if user hasn't filtered it out (we kept earlier)
      }

      newWin.pons.push(Object.assign({}, p, { levels: newLevels }));
    });

    if (newWin.pons.length > 0 || !wsel) {
      out.windows.push(newWin);
    }
  });
  return out;
}

/* deep scan for search term in users */
function deepSearchMatch(pObj, term){
  if (!term) return false;
  for (const lvl of (pObj.levels || [])){
    for (const sp of (lvl.splitters || [])){
      for (const u of (sp.users || [])){
        if (String(u).toLowerCase().includes(term)) return true;
      }
    }
  }
  return false;
}

/* Transform JSON to true tree hierarchy:
   Network -> Window -> OLT (single per olt per window) -> PON -> level -> splitter
*/
function transformToHierarchy(j){
  const root = { name: "Merotra Network", type: "network", children: [] };

  (j.windows || []).forEach(win=>{
    const winNode = { name: win.window || 'Window', type: 'window', children: [] };

    // group PONs under their OLT numbers for this window
    const oltMap = {}; // oltNum -> { name: 'OLT-{n}', children: [ponNodes] }
    (win.pons || []).forEach(p=>{
      const ponKey = p.pon || 'NOPON';
      const { olt, ip, port } = parsePonKey(ponKey);

      // create pon node (levels - omit empty levels)
      const levels = (p.levels || []).filter(l => Array.isArray(l.splitters) && l.splitters.length > 0)
                                     .map(l => {
                                       return {
                                         name: 'Level ' + l.level,
                                         levelNumber: l.level,
                                         type: 'level',
                                         children: l.splitters.map(sp => {
                                           return {
                                             name: sp.type ? sp.type : (sp.recordId || 'Splitter'),
                                             type: 'splitter',
                                             recordId: sp.recordId || '',
                                             users: (sp.users || []).map(u => String(u)),
                                             total: sp.total || (Array.isArray(sp.users) ? sp.users.length : 0)
                                           };
                                         })
                                       };
                                     });

      const ponNode = {
        name: ponKey,
        type: 'pon',
        meta: { olt, ip, port },
        children: levels // may be empty array
      };

      const oltNum = String(olt);
      if (!oltMap[oltNum]) oltMap[oltNum] = { name: 'OLT-' + oltNum, type: 'olt', children: [], meta:{olt:oltNum} };
      oltMap[oltNum].children.push(ponNode);
    });

    // sort PONs within each OLT by OLT/IP/Port (we already have pon meta)
    Object.values(oltMap).forEach(oltNode=>{
      oltNode.children.sort((a,b)=> {
        const A = a.meta || {}, B = b.meta || {};
        if (A.olt !== B.olt) return A.olt - B.olt;
        if (A.ip !== B.ip) return A.ip - B.ip;
        return A.port - B.port;
      });
    });

    // push sorted OLTs into window node (sorted by olt number)
    Object.values(oltMap).sort((a,b)=> (+a.meta.olt) - (+b.meta.olt)).forEach(oltNode=>{
      winNode.children.push(oltNode);
    });

    root.children.push(winNode);
  });

  return root;
}

/* ================== RENDER (D3 Tree, vertical top->down) ================== */

function renderTree(rootData){
  // clear chart
  const chart = d3.select('#chart');
  chart.selectAll('*').remove();

  // compute sizes and dynamic spacing to avoid overlaps:
  // compute approximate max breadth at any depth to set nodeGap and levelGap
  function computeBreadth(node, depth=0, map={}){
    map[depth] = (map[depth] || 0) + (node.type === 'splitter' ? 1 : 1);
    (node.children || []).forEach(ch => computeBreadth(ch, depth+1, map));
    return map;
  }
  const breadthMap = computeBreadth(rootData, 0, {});
  const maxAcross = Math.max(...Object.values(breadthMap), 1);

  // layout params (scale with content)
  const width = chart.node().clientWidth || window.innerWidth;
  const height = chart.node().clientHeight || (window.innerHeight - 60);
  const levelGap = Math.max(160, Math.min(260, Math.floor(width / 6))); // vertical gap between depths
  const nodeGap = Math.max(36, Math.min(80, Math.floor(height / (maxAcross + 2)))); // vertical spacing between nodes at same depth

  const svg = chart.append('svg').attr('width','100%').attr('height','100%').attr('viewBox',`0 0 ${Math.max(1200, width)} ${Math.max(800, height)}`);
  const g = svg.append('g').attr('transform','translate(40,40)');

  // create d3.hierarchy from our rootData but treat splitter children as leaf nodes (they may have no children)
  const d3root = d3.hierarchy(rootData, d => d.children && d.children.length ? d.children : null);

  // custom nodeSize by depth: vertical distance bigger to avoid overlaps
  const treeLayout = d3.tree().nodeSize([nodeGap, levelGap]); // [y, x]?? but for d3.tree default is x,y -> we'll map accordingly
  treeLayout(d3root);

  // The d3.tree has placed nodes with x (vertical coord) and y (horizontal). We want top->down, so use x values for y and y for x.
  // compute bounds to center
  const nodes = d3root.descendants();
  const links = d3root.links();

  // normalize coordinates to place root at top center
  // compute min/max
  const minX = d3.min(nodes, d => d.x);
  const maxX = d3.max(nodes, d => d.x);
  const minY = d3.min(nodes, d => d.y);
  const maxY = d3.max(nodes, d => d.y);

  // scale/translate to fit container
  const availableW = Math.max(1000, width - 120);
  const availableH = Math.max(700, height - 120);
  const scaleX = availableW / Math.max(1, maxY - minY + levelGap);
  const scaleY = availableH / Math.max(1, maxX - minX + nodeGap);
  const scale = Math.min(scaleX, scaleY, 1.6);

  const tx = -minY * scale + 40;
  const ty = -minX * scale + 20;

  g.attr('transform', `translate(${tx},${ty}) scale(${scale})`);

  // draw links (curved) with color per OLT branch.
  // We'll color link by nearest ancestor of link source that is an 'olt' node; fallback to gray.
  function colorForLink(d){
    // d: link object with source and target (d.source.data)
    // find ancestor that is olt (source->root)
    let node = d.source;
    while (node && node.data && node.data.type !== 'olt') node = node.parent;
    const oltNum = node && node.data && node.data.meta ? node.data.meta.olt : (node && node.data && node.data.name && node.data.name.replace('OLT-','')) || '0';
    return ensureColorForOlt(oltNum);
  }

  // helper to produce smooth path top->down
  function diagonal(d){
    // source (sx, sy), target (tx, ty)
    const sx = d.source.y;
    const sy = d.source.x;
    const txp = d.target.y;
    const typ = d.target.x;
    const midY = (sy + typ) / 2;
    // smooth curve using cubic bezier from (sx,sy) to (tx,ty)
    return `M ${sx} ${sy} C ${sx} ${midY} ${txp} ${midY} ${txp} ${typ}`;
  }

  // minimize crossing by drawing links grouped by color/branch: draw per OLT first
  // but simple approach: draw all links with opacity and slight stroke-width
  g.selectAll('.link')
    .data(links)
    .enter()
    .append('path')
      .attr('class','link')
      .attr('d', diagonal)
      .attr('fill','none')
      .attr('stroke', d => colorForLink(d))
      .attr('stroke-width', 2)
      .attr('stroke-opacity', 0.9);

  // nodes
  const node = g.selectAll('.node')
    .data(nodes)
    .enter()
    .append('g')
      .attr('class','node')
      .attr('transform', d => `translate(${d.y},${d.x})`)
      .style('cursor','pointer')
      .on('mousemove', (event, d) => showTooltip(event, d.data))
      .on('mouseout', hideTooltip)
      .on('click', (event, d) => handleNodeClick(d.data, d));

  // circle styling by type
  node.append('circle')
    .attr('r', d => {
      if (d.data.type === 'network') return 22;
      if (d.data.type === 'window') return 18;
      if (d.data.type === 'olt') return 16;
      if (d.data.type === 'pon') return 14;
      if (d.data.type === 'level') return 0; // levels are not shown as nodes (we don't want level nodes per user request)
      if (d.data.type === 'splitter') return 12;
      return 10;
    })
    .attr('fill', d => {
      if (d.data.type === 'network') return '#1e3a8a';
      if (d.data.type === 'window') return '#1d4ed8';
      if (d.data.type === 'olt') return ensureColorForOlt(d.data.meta ? d.data.meta.olt : (getOltNumberFromPon(d.data.name)||'0'));
      if (d.data.type === 'pon') return '#0f766e';
      if (d.data.type === 'splitter') return (d.data.total && d.data.total>0) ? '#10b981' : '#6b7280';
      return '#94a3b8';
    })
    .attr('stroke','#fff')
    .attr('stroke-width', 2)
    .style('pointer-events', d=> d.data.type === 'level' ? 'none' : 'auto');

  // labels
  node.append('text')
    .attr('dy', d => {
      if (d.data.type === 'network') return '0.35em';
      return '0.31em';
    })
    .attr('x', d => {
      // position text to the right for most, but for network put centered
      if (d.data.type === 'network') return 0;
      return d.children ? (d.data.type === 'splitter' ? 18 : 18) : 18;
    })
    .attr('text-anchor', d => (d.data.type === 'network' ? 'middle' : 'start'))
    .style('font-size', d => {
      if (d.data.type === 'network') return '14px';
      if (d.data.type === 'window') return '13px';
      if (d.data.type === 'olt') return '12px';
      if (d.data.type === 'pon') return '12px';
      if (d.data.type === 'splitter') return '11px';
      return '11px';
    })
    .style('font-weight', d => (d.data.type === 'network' || d.data.type === 'window') ? 800 : 600)
    .text(d => {
      if (d.data.type === 'network') return d.data.name;
      if (d.data.type === 'window') return d.data.name;
      if (d.data.type === 'olt') return d.data.name; // shows OLT-{n}
      if (d.data.type === 'pon') return d.data.name;
      if (d.data.type === 'splitter') return `${d.data.name}${d.data.total? ` (${d.data.total})` : ''}`;
      return d.data.name;
    });

  // hide level-type nodes (we used their children directly as splitters) - but some nodes may be 'level' visible in hierarchy; remove circles and labels for level nodes
  // (We created level nodes earlier in transformToHierarchy; in d3.hierarchy they appear. To avoid duplicate display, we hide level nodes visually by setting opacity 0)
  node.filter(d => d.data.type === 'level').selectAll('circle,text').attr('opacity',0);

  // interactions: click on splitters or pon shows popup
  function handleNodeClick(data, d3node){
    if (!data) return;
    if (data.type === 'splitter') openPopup(data, findPonAncestor(d3node), findWindowAncestor(d3node));
    else if (data.type === 'pon') openPopupForPon(data, findPonAncestor(d3node), findWindowAncestor(d3node));
  }

  function findPonAncestor(d){
    let node = d;
    while (node && node.data && node.data.type !== 'pon') node = node.parent;
    return node ? node.data.name : '';
  }
  function findWindowAncestor(d){
    let node = d;
    while (node && node.data && node.data.type !== 'window') node = node.parent;
    return node ? node.data.name : '';
  }

  // fit to view by resetting transform with d3.zoom
  // Attach zoom behavior for user to pan/zoom after initial fit
  const zoom = d3.zoom().scaleExtent([0.2, 3]).on('zoom', (evt) => g.attr('transform', evt.transform));
  svg.call(zoom);

  // initial auto-fit: compute bbox and set transform to center vertically (top->down)
  try {
    const bbox = g.node().getBBox();
    const svgW = svg.node().clientWidth || width;
    const svgH = svg.node().clientHeight || height;
    const sx = svgW / (bbox.width + 160);
    const sy = svgH / (bbox.height + 160);
    const s0 = Math.min(sx, sy, 1.2);
    const tx0 = -bbox.x * s0 + 40;
    const ty0 = -bbox.y * s0 + 20;
    svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(tx0,ty0).scale(s0));
  } catch(e){ /* ignore */ }

  // After render, apply search highlight if active
  applySearchHighlight();
}

/* ================== Tooltip & Popup ================== */

function showTooltip(event, data){
  const t = tooltip;
  if (!data) { t.style.opacity = 0; return; }
  let html = `<strong>${data.name || ''}</strong><br/>Type: ${data.type || ''}`;
  if (data.type === 'splitter') {
    html += `<br/>Record: ${data.recordId || '-'}<br/>Users: <strong>${data.total || (data.users?data.users.length:0)}</strong>`;
  }
  if (data.type === 'pon') {
    html += `<br/>PON: ${data.name}`;
  }
  t.innerHTML = html;
  t.style.left = (event.pageX + 12) + 'px';
  t.style.top = (event.pageY + 8) + 'px';
  t.style.opacity = 1;
}
function hideTooltip(){ tooltip.style.opacity = 0; }

function openPopup(splitterObj, ponName, winName){
  popupModal.style.display = 'flex';
  popupTitle.textContent = `${splitterObj.type || 'Splitter'} ‚Äî Users`;
  popupPath.textContent = `${winName || ''} ‚Üí ${ponName || ''} ‚Üí ${splitterObj.recordId || ''}`;
  popupMeta.innerHTML = `<div><strong>Total users:</strong> ${splitterObj.total || (splitterObj.users ? splitterObj.users.length : 0)}</div>`;
  const users = Array.isArray(splitterObj.users) ? splitterObj.users : [];
  popupUsers.innerHTML = `<thead><tr><th>Sr</th><th>User ID</th></tr></thead><tbody>${users.map((u,i)=>`<tr><td>${i+1}</td><td>${u}</td></tr>`).join('')}</tbody>`;
}

function openPopupForPon(ponObj, ponName, winName){
  popupModal.style.display = 'flex';
  popupTitle.textContent = `PON ‚Äî ${ponObj.name}`;
  popupPath.textContent = `${winName || ''} ‚Üí ${ponName || ''}`;
  // collect all users under this PON
  const users = [];
  (ponObj.children || []).forEach(lvl => {
    (lvl.children || []).forEach(sp => {
      (sp.users || []).forEach(u => users.push(u));
    });
  });
  popupMeta.innerHTML = `<div><strong>Total users (unique):</strong> ${new Set(users).size}</div>`;
  popupUsers.innerHTML = `<thead><tr><th>Sr</th><th>User ID</th></tr></thead><tbody>${Array.from(new Set(users)).map((u,i)=>`<tr><td>${i+1}</td><td>${u}</td></tr>`).join('')}</tbody>`;
}

/* ================== Search Highlight + Filters ================== */

function applyFiltersAndRender(){
  if (!rawJson) return;
  const filtered = applyClientFilters(rawJson);
  const root = transformToHierarchy(filtered);
  renderTree(root);
}

function applySearchHighlight(){
  const term = (searchInput.value || '').trim().toLowerCase();
  if (!term) {
    // remove highlight styles
    d3.selectAll('.node circle').attr('stroke-width', 2).attr('stroke', '#fff').attr('opacity', 1);
    d3.selectAll('.node text').style('font-weight', d=> (d && d.data && (d.data.type === 'network' || d.data.type === 'window')) ? 800 : 600);
    return;
  }
  // highlight any node (splitter) that contains user matching term - flexible: substring match
  d3.selectAll('.node').each(function(d){
    const n = d3.select(this);
    const data = d.data;
    let match = false;
    if (data && data.type === 'splitter'){
      const users = data.users || [];
      for (const u of users){ if (String(u).toLowerCase().includes(term)) { match = true; break; } }
    } else if (data && data.type === 'pon'){
      // check all splitters under pon
      const allUsers = [];
      (data.children||[]).forEach(l=> (l.children||[]).forEach(s=> (s.users||[]).forEach(u=> allUsers.push(u))));
      for (const u of allUsers){ if (String(u).toLowerCase().includes(term)) { match = true; break; } }
    }
    if (match){
      n.select('circle').attr('stroke-width', 4).attr('stroke','#ffb020').attr('opacity',1);
      n.select('text').style('font-weight', 900);
    } else {
      n.select('circle').attr('stroke-width', 2).attr('stroke','#fff').attr('opacity', 0.35);
      n.select('text').style('font-weight', d=> (d && d.data && (d.data.type === 'network' || d.data.type === 'window')) ? 800 : 500);
    }
  });
}

/* ================== Downloads ================== */

function downloadCSV(){
  const modalVisible = popupModal.style.display === 'flex';
  if (!modalVisible) { alert('Open a splitter / PON popup to export its users'); return; }
  const rows = Array.from(popupUsers.querySelectorAll('tr'));
  if (!rows.length) return;
  let csv = '';
  rows.forEach((r, idx) => {
    const cols = Array.from(r.querySelectorAll('th,td')).map(c => `"${(c.textContent||'').replace(/"/g,'""')}"`);
    csv += cols.join(',') + '\n';
  });
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'users.csv'; a.click();
  URL.revokeObjectURL(url);
}

function downloadScreenshot(){
  // serialize current SVG
  const svg = document.querySelector('#chart svg');
  if (!svg) return alert('No chart to export');
  const serializer = new XMLSerializer();
  const txt = serializer.serializeToString(svg);
  const blob = new Blob([txt], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'merotra-tree.svg'; a.click();
  URL.revokeObjectURL(url);
}

/* ================== INIT ================== */
loadAndRender(false);
window.addEventListener('resize', ()=> { if (rawJson) applyFiltersAndRender(); });

</script>
</body>
</html>
