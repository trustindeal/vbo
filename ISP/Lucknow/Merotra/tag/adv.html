<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merotra ‚Äî Column Level Tree</title>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- adv.css (provided by you) -->
  <link rel="stylesheet" href="adv.css">

  <style>
    /* Small overrides to work smoothly with adv.css */
    :root{font-family:Inter,system-ui,Arial}
    body{margin:0;padding:0;background:linear-gradient(135deg,#f0f9ff,#e0f2fe);color:#111827;height:100vh;overflow:hidden}
    .header { position: sticky; top: 0; z-index: 40; }
    #chart{width:100%;height:calc(100vh - 64px); overflow:hidden}
    .controls-inline { display:flex; gap:8px; align-items:center; }
    .search-fold { display:flex; gap:8px; align-items:center; }
    .search-box { width:0; transition:width .22s; overflow:hidden; }
    .search-box.open { width:220px; }
    .small-tag { font-size:12px; color:#475569; }
    .filter-panel { display:flex; gap:8px; align-items:center; }
    /* highlight style for nodes */
    .highlight { stroke:#ffd54f !important; stroke-width:4px !important; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.12)); }
    /* subtle drop shadow for svg groups */
    .node-label { font-size:11px; fill:#0f172a; }
    /* prevent popup/backdrop default styles from adv interfering */
    .popup-backdrop { z-index:90; }
    /* responsive tweaks */
    @media (max-width: 760px){
      .search-box.open { width:140px; }
      .controls-inline { flex-wrap:wrap; }
    }
  </style>
</head>
<body>

  <div class="header">
    <div style="display:flex;flex-direction:column;gap:4px;padding:10px 16px;background:rgba(255,255,255,0.95);box-shadow:0 4px 20px rgba(0,0,0,0.06)">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="header-title">üåê Merotra Network</div>
          <div class="header-sub">Network ‚Üí Window ‚Üí OLT ‚Üí PON ‚Üí Level Columns (left ‚Üí right)</div>
        </div>

        <div style="display:flex;gap:8px;align-items:center">
          <div class="controls-inline">
            <button id="reloadBtn" class="btn">üîÑ Refresh</button>

            <!-- search folded -->
            <div class="search-fold">
              <button id="toggleSearch" class="btn btn-secondary">üîç Search</button>
              <input id="searchInput" placeholder="Enter user id (partial ok)" class="search-box" />
              <button id="searchBtn" class="btn btn-secondary" title="Find">Find</button>
              <button id="clearSearch" class="btn btn-secondary" title="Clear">Clear</button>
            </div>

            <!-- filters -->
            <button id="openFilters" class="btn btn-secondary">‚öô Filters</button>
          </div>
        </div>
      </div>

      <div style="display:flex;gap:12px;align-items:center">
        <div class="small-tag" id="summaryTag">Loading...</div>
        <div style="flex:1"></div>
      </div>
    </div>
  </div>

  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <!-- Filter modal (simple) -->
  <div id="filterModal" class="controls-backdrop" style="display:none">
    <div class="controls-modal">
      <h3 style="margin:0 0 8px">Filters</h3>
      <div style="display:flex;gap:12px">
        <div style="flex:1">
          <div class="filter-title">Windows</div>
          <div id="windowFilterList" class="checkbox-grid"></div>
        </div>
        <div style="flex:1">
          <div class="filter-title">OLTs</div>
          <div id="oltFilterList" class="checkbox-grid"></div>
        </div>
        <div style="flex:1">
          <div class="filter-title">PONs</div>
          <div id="ponFilterList" class="checkbox-grid pon-grid"></div>
        </div>
      </div>

      <div style="display:flex;gap:10px;margin-top:12px;justify-content:flex-end">
        <button id="applyFilters" class="btn">Apply</button>
        <button id="closeFilters" class="btn btn-secondary">Close</button>
      </div>
    </div>
  </div>

  <!-- Popup for splitter users -->
  <div id="popupModal" class="popup-backdrop" style="display:none">
    <div class="modal-content">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px">
        <div>
          <h2 id="popupTitle" style="margin:0;font-size:16px"></h2>
          <div id="popupPath" style="font-size:12px;color:#475569"></div>
        </div>
        <button id="popupClose" class="btn btn-secondary" style="height:30px">Close</button>
      </div>

      <div id="popupMeta" style="font-size:13px;color:#334155;margin-bottom:8px"></div>
      <div style="max-height:400px;overflow:auto">
        <table id="popupUsersTable" class="user-table"></table>
      </div>
    </div>
  </div>

<script>
/* ================= CONFIG ================= */
const BOARD_URL = "https://script.google.com/macros/s/AKfycbzItUueYIqcUuCn2cDaTTrWIF0LiilUxOXhhL-4b4D9aUlEo8Ov9pasR44d6JSM3h1t/exec?mode=board";

/* ================= STATE ================== */
let rawJson = null;
let filteredJson = null;
const tooltip = document.getElementById('tooltip');
const summaryTag = document.getElementById('summaryTag');

/* UI elements */
const reloadBtn = document.getElementById('reloadBtn');
const toggleSearch = document.getElementById('toggleSearch');
const searchInput = document.getElementById('searchInput');
const searchBtn = document.getElementById('searchBtn');
const clearSearch = document.getElementById('clearSearch');
const openFilters = document.getElementById('openFilters');
const filterModal = document.getElementById('filterModal');
const closeFilters = document.getElementById('closeFilters');
const applyFilters = document.getElementById('applyFilters');

reloadBtn.addEventListener('click', ()=> loadAndRender(true));
toggleSearch.addEventListener('click', ()=> { searchInput.classList.toggle('open'); if(searchInput.classList.contains('open')) searchInput.focus(); });
searchBtn.addEventListener('click', ()=> runSearch());
clearSearch.addEventListener('click', ()=> { searchInput.value=''; runSearch(true); });
openFilters.addEventListener('click', ()=> { filterModal.style.display='flex'; });
closeFilters.addEventListener('click', ()=> { filterModal.style.display='none'; });
applyFilters.addEventListener('click', ()=> { applyAndCloseFilters(); });

document.getElementById('popupClose').addEventListener('click', ()=> document.getElementById('popupModal').style.display='none');

/* ================= Helpers ================= */
function normalizeId(v){ return (v ?? "").toString().trim(); }
function parsePon(pon) {
  // return olt, ip, port numbers for sorting
  const m = (pon || "").match(/O(\d+)I(\d+)P(\d+)/i);
  if (!m) return { olt:9999, ip:9999, port:9999 };
  return { olt:+m[1], ip:+m[2], port:+m[3] };
}
function oltFromPon(pon) {
  const m = (pon || "").match(/O(\d+)/i);
  return m ? String(m[1]) : "unknown";
}
function uidInListFlexible(list, query) {
  // case-insensitive substring match; used for flexible search
  if(!query) return false;
  const q = query.toString().trim();
  if(!q) return false;
  for (const u of list) {
    if (String(u).includes(q)) return true;
  }
  return false;
}
function makeColorForOlt(olt) {
  // deterministic pastel color based on olt string
  const n = olt ? parseInt(olt.replace(/\D/g,''),10) || 0 : 0;
  const h = (n * 47) % 360;
  return `hsl(${h} 65% 48%)`;
}

/* small random color fallback (not used for OLTs) */
function randColor() { const h=Math.floor(Math.random()*360); return `hsl(${h} 65% 48%)`; }

/* ================== LOAD & ENTRY ================== */
async function loadAndRender(showToast=false) {
  try {
    setLoading(true);
    const res = await fetch(BOARD_URL);
    if (!res.ok) throw new Error('Board API fetch failed: ' + res.status);
    const j = await res.json();
    rawJson = j;
    // default: no filters applied -> filteredJson = rawJson
    filteredJson = structuredClone(rawJson);
    setupFilterUI(rawJson);
    summaryTag.textContent = `Processed: ${j.summary?.processedRows ?? '-'}  |  Windows: ${ (j.windows||[]).length }`;
    renderFromJson(filteredJson);
    if (showToast) console.info('Loaded board');
  } catch (err) {
    console.error(err);
    alert('Load failed: ' + (err.message || err));
  } finally {
    setLoading(false);
  }
}

function setLoading(flag){
  reloadBtn.textContent = flag ? 'Loading...' : 'üîÑ Refresh';
  reloadBtn.disabled = flag;
}

/* ================== FILTER UI ================== */
function setupFilterUI(serverJson){
  const windows = (serverJson.windows || []).map(w => w.window);
  const oltSet = new Set();
  const ponSet = new Set();
  (serverJson.windows || []).forEach(w => {
    (w.pons||[]).forEach(p => {
      const pon = p.pon;
      ponSet.add(pon);
      oltSet.add(oltFromPon(pon));
    });
  });

  const winDiv = document.getElementById('windowFilterList');
  const oltDiv = document.getElementById('oltFilterList');
  const ponDiv = document.getElementById('ponFilterList');
  winDiv.innerHTML = ''; oltDiv.innerHTML = ''; ponDiv.innerHTML = '';

  windows.sort((a,b)=> a.localeCompare(b, undefined, {sensitivity:'base'})).forEach(w => {
    const el = document.createElement('div'); el.className='checkbox-item';
    el.innerHTML = `<label><input type="checkbox" value="${w}" checked> <span>${w}</span></label>`;
    winDiv.appendChild(el);
  });

  Array.from(oltSet).sort((a,b)=> (+a)-(+b)).forEach(o => {
    const el = document.createElement('div'); el.className='checkbox-item';
    el.innerHTML = `<label><input type="checkbox" value="${o}" checked> <span>OLT-${o}</span></label>`;
    oltDiv.appendChild(el);
  });

  Array.from(ponSet).sort().forEach(p => {
    const el = document.createElement('div'); el.className='checkbox-item';
    el.innerHTML = `<label><input type="checkbox" value="${p}" checked> <span>${p}</span></label>`;
    ponDiv.appendChild(el);
  });
}

function applyAndCloseFilters() {
  // gather selected filters
  const winChecked = Array.from(document.querySelectorAll('#windowFilterList input:checked')).map(i=>i.value);
  const oltChecked = Array.from(document.querySelectorAll('#oltFilterList input:checked')).map(i=>i.value);
  const ponChecked = Array.from(document.querySelectorAll('#ponFilterList input:checked')).map(i=>i.value);

  // filter rawJson into filteredJson
  const out = { summary: rawJson.summary || {}, windows: [] };
  (rawJson.windows || []).forEach(win=>{
    if (!winChecked.includes(win.window)) return;
    const wObj = { window: win.window, pons: [] };
    (win.pons || []).forEach(p=>{
      const olt = oltFromPon(p.pon);
      if (!oltChecked.includes(olt)) return;
      if (!ponChecked.includes(p.pon)) return;
      wObj.pons.push(p);
    });
    if (wObj.pons.length) out.windows.push(wObj);
  });
  filteredJson = out;
  filterModal.style.display = 'none';
  renderFromJson(filteredJson);
}

/* ================= RENDER (COLUMN LAYOUT) ================= */
function renderFromJson(serverJson) {
  const chart = document.getElementById('chart');
  chart.innerHTML = ''; // clear

  if (!serverJson || !Array.isArray(serverJson.windows) || serverJson.windows.length === 0) {
    chart.innerHTML = '<div style="padding:20px;color:#64748b">No data</div>';
    return;
  }

  // svg + pan/zoom
  const svg = d3.select('#chart').append('svg').attr('width','100%').attr('height','100%').style('background','transparent');
  const g = svg.append('g');

  // initial zoom transform oriented vertically (fit to height)
  const zoom = d3.zoom().scaleExtent([0.25, 3]).on('zoom', (evt)=> g.attr('transform', evt.transform));
  svg.call(zoom);

  // Layout params, adapt to avoid overlap:
  const baseColWidth = 240;     // default horizontal gap per level
  const ponColWidth = 160;      // width for PON column
  const nodeRadius = 12;        // circle radius
  const minVgap = 48;           // min vertical gap between nodes
  const topPad = 20;
  const leftPad = 20;
  const windowGap = 36;
  const windowSectionGap = 36;

  let currentY = topPad;

  // We will compute OLT colors map
  const oltColorMap = {};

  // Pre-generate OLTs from data
  const allOlts = new Set();
  (serverJson.windows || []).forEach(win => (win.pons||[]).forEach(p => allOlts.add(oltFromPon(p.pon))));
  Array.from(allOlts).forEach(o => oltColorMap[o] = makeColorForOlt(o));

  // For each window:
  serverJson.windows.forEach(win => {
    const winName = win.window || 'Window';
    const pons = Array.isArray(win.pons) ? win.pons : [];

    // window header
    g.append('text')
      .attr('x', leftPad)
      .attr('y', currentY + 12)
      .text(winName)
      .attr('font-weight','700')
      .attr('font-size',14)
      .attr('fill','#0f172a');

    currentY += 28;

    // For each PON under this window, draw a stacked block
    pons.forEach((ponObj, ponIndex) => {
      const ponName = ponObj.pon || 'PON';
      const levels = Array.isArray(ponObj.levels) ? ponObj.levels.slice() : [];

      // remove empty levels (option2: minimal spacing) - don't render empty levels
      const presentLevels = levels.filter(l => Array.isArray(l.splitters) && l.splitters.length > 0);
      // sort levels by level number ascending
      presentLevels.sort((a,b)=> (a.level||0) - (b.level||0));

      // compute max nodes vertically among columns to prevent overlap
      const counts = presentLevels.map(l => l.splitters.length);
      const maxNodes = Math.max(1, ...counts);

      // dynamic vertical gap: grow if many nodes to avoid overlap
      const nodeVgap = Math.max(minVgap, Math.ceil((maxNodes * 1.0) / Math.max(1, maxNodes)) * minVgap);

      // block height computed from maxNodes
      const blockHeight = Math.max((maxNodes - 1) * nodeVgap + 80, 120);

      // columns: Network + Window + OLT + PON + each level
      const colsBeforeLevels = 4;
      const totalCols = colsBeforeLevels + presentLevels.length;
      const colWidth = baseColWidth; // consistent column gap

      const baseX = leftPad;
      const netColX = baseX;
      const winColX = netColX + colWidth;
      const oltColX = winColX + colWidth;
      const ponColX = oltColX + ponColWidth;
      const levelStartX = ponColX + ponColWidth;

      const blockY = currentY;
      const centerY = blockY + blockHeight/2;

      // Draw Network (only for first PON of first window to avoid repetition)
      if (ponIndex === 0) {
        // If first PON of first window, draw the big "Merotra Network" left-most at netColX
        const drawNet = (win === serverJson.windows[0] && pons[0] === ponObj);
        if (drawNet) {
          g.append('text')
            .attr('x', netColX)
            .attr('y', centerY)
            .text('Merotra Network')
            .attr('font-weight','800')
            .attr('font-size',13)
            .attr('fill','#0f172a');
        } else {
          // small placeholder text for alignment
          g.append('text')
            .attr('x', netColX)
            .attr('y', centerY)
            .text('')
            .attr('font-size',10);
        }
      }

      // Window - only once per window (draw left of first PON)
      if (ponIndex === 0) {
        g.append('text')
          .attr('x', winColX)
          .attr('y', centerY)
          .text(winName)
          .attr('font-size',12)
          .attr('fill','#0f172a');
      }

      // OLT node (single node per OLT in this window block)
      const olt = oltFromPon(ponName);
      const oltName = `OLT-${olt}`;
      // We'll show OLT text in oltColX
      g.append('text')
        .attr('x', oltColX)
        .attr('y', centerY)
        .text(oltName)
        .attr('font-size',12)
        .attr('fill', oltColorMap[olt] || '#1d4ed8');

      // PON node (circle + label)
      const ponX = ponColX;
      const ponY = centerY;
      g.append('circle')
        .attr('cx', ponX)
        .attr('cy', ponY)
        .attr('r', nodeRadius+4)
        .attr('fill','#0f766e')
        .attr('stroke','#fff')
        .attr('stroke-width',2);

      g.append('text')
        .attr('x', ponX + nodeRadius + 8)
        .attr('y', ponY + 4)
        .text(ponName + (ponObj.totalUsers ? ` (${ponObj.totalUsers})` : ''))
        .attr('font-size',12)
        .attr('fill','#0f172a');

      // For each present level, compute positions for splitters (sheet order must be preserved)
      const levelNodesPositions = [];
      presentLevels.forEach((lvl, li) => {
        const splitters = Array.isArray(lvl.splitters) ? lvl.splitters : [];
        const colX = levelStartX + li * colWidth;
        const count = Math.max(1, splitters.length);
        const totalHeight = (count - 1) * nodeVgap;
        let startY = centerY - (totalHeight / 2);

        const positions = [];
        for (let si=0; si<splitters.length; si++){
          const s = splitters[si];
          const x = colX;
          const y = startY + si * nodeVgap;
          positions.push({ s, x, y });
        }
        levelNodesPositions.push(positions);
      });

      // DRAW splitters
      levelNodesPositions.forEach((posArr, li) => {
        posArr.forEach(p => {
          const s = p.s;
          // circle
          const circle = g.append('circle')
            .attr('cx', p.x)
            .attr('cy', p.y)
            .attr('r', nodeRadius)
            .attr('fill', '#10b981')
            .attr('stroke','#fff')
            .attr('stroke-width',2)
            .style('cursor','pointer');

          // attach events
          circle.on('mousemove', (event)=> showTooltip(event, s))
                .on('mouseout', hideTooltip)
                .on('click', ()=> openPopup(s, ponName, winName));

          // label
          const label = (s.type ? `${s.type}` : '') + (s.total ? ` (${s.total})` : '');
          g.append('text')
            .attr('x', p.x + nodeRadius + 8)
            .attr('y', p.y + 4)
            .text(label)
            .attr('font-size',11)
            .attr('fill','#0f172a');

          // recordId small below
          if (s.recordId) {
            g.append('text')
              .attr('x', p.x)
              .attr('y', p.y + nodeRadius + 14)
              .text(s.recordId)
              .attr('font-size',10)
              .attr('fill','#64748b')
              .attr('text-anchor','middle');
          }
        });
      });

      // LINKS:
      // 1) Network -> Window -> OLT -> PON chain for visual connection:
      // For cleaner layout, draw a single chain from (netColX, centerY) -> (winColX, centerY) -> (oltColX, centerY) -> (ponX, centerY)
      const netXcenter = netColX + 6; // slight offset
      const pathNetToWin = linkPath({x: netXcenter, y: centerY}, {x: winColX, y: centerY});
      g.append('path').attr('d', pathNetToWin).attr('fill','none').attr('stroke','#94a3b8').attr('stroke-width',1.2).attr('class','link');

      const pathWinToOlt = linkPath({x: winColX, y: centerY}, {x: oltColX - 6, y: centerY});
      g.append('path').attr('d', pathWinToOlt).attr('fill','none').attr('stroke','#94a3b8').attr('stroke-width',1.2).attr('class','link');

      const pathOltToPon = linkPath({x: oltColX + 18, y: centerY}, {x: ponX - 10, y: centerY});
      g.append('path').attr('d', pathOltToPon).attr('fill','none').attr('stroke', oltColorMap[olt] || '#0f766e').attr('stroke-width',1.6).attr('class','link');

      // 2) PON -> Level1: always connect PON to all level1 splitters
      if (levelNodesPositions.length >= 1) {
        const lvl1 = levelNodesPositions[0];
        lvl1.forEach(child => {
          const path = linkPath({x: ponX, y: ponY}, {x: child.x, y: child.y});
          g.append('path').attr('d', path).attr('fill','none').attr('stroke', oltColorMap[olt] || '#10b981').attr('stroke-width',2).attr('stroke-opacity',0.95).attr('class','link');
        });
      }

      // 3) levelN -> levelN+1: connect a child to the FIRST parent in previous level that shares users
      for (let li = 0; li < levelNodesPositions.length - 1; li++) {
        const parents = levelNodesPositions[li];
        const children = levelNodesPositions[li+1];
        const parentSets = parents.map(p => new Set((p.s.users||[]).map(normalizeId)));

        children.forEach(child => {
          const childSet = new Set((child.s.users||[]).map(normalizeId));
          let linked = false;
          for (let pi = 0; pi < parents.length; pi++) {
            const parentSet = parentSets[pi];
            // intersection check (first parent with any common user)
            let common = false;
            for (const u of childSet) { if (parentSet.has(u)) { common = true; break; } }
            if (common) {
              const pnode = parents[pi];
              const path = linkPath({x:pnode.x, y:pnode.y}, {x:child.x, y:child.y});
              g.append('path').attr('d', path).attr('fill','none').attr('stroke', oltColorMap[olt] || '#10b981').attr('stroke-width',2).attr('stroke-opacity',0.95).attr('class','link');
              linked = true;
              break; // only first matching parent
            }
          }
          // if no parent matched: do NOT draw link (per your rule)
        });
      }

      // move Y down for next PON block
      currentY += blockHeight + windowSectionGap;
    }); // end pons loop

    // a bit of space after window
    currentY += windowGap;
  }); // end windows loop

  // Fit to view: vertical full-screen first (as requested)
  fitToViewVertical(svg.node(), g.node());
}

/* ================== PATH HELPERS ================== */
function linkPath(src, dst) {
  // smooth horizontal-ish cubic; bias to not cross too much
  const midX = src.x + (dst.x - src.x) * 0.5;
  return `M ${src.x} ${src.y} C ${midX} ${src.y} ${midX} ${dst.y} ${dst.x} ${dst.y}`;
}

/* Fit initial view vertically (show full height) */
function fitToViewVertical(svgNode, gNode) {
  try {
    const bbox = gNode.getBBox();
    const svgW = svgNode.clientWidth || window.innerWidth;
    const svgH = svgNode.clientHeight || (window.innerHeight - 64);
    if (!isFinite(bbox.height) || bbox.height === 0) return;
    // scale to fit height (prefer filling vertically)
    const scale = Math.min(1.0, Math.min(svgW / (bbox.width + 120), svgH / (bbox.height + 60)));
    const tx = -bbox.x * scale + 20;
    const ty = -bbox.y * scale + 20;
    d3.select(svgNode).transition().duration(500).call(
      d3.zoom().transform,
      d3.zoomIdentity.translate(tx, ty).scale(scale)
    );
  } catch(e){ console.warn(e); }
}

/* ================= TOOLTIP & POPUP ================= */
function showTooltip(event, splitterObj) {
  const t = tooltip;
  t.style.left = (event.pageX + 12) + 'px';
  t.style.top = (event.pageY + 8) + 'px';
  const users = Array.isArray(splitterObj.users) ? splitterObj.users.length : 0;
  t.innerHTML = `<strong>${splitterObj.type || splitterObj.recordId || 'Splitter'}</strong><br/>Record: ${splitterObj.recordId||'-'}<br/>Users: <strong>${users}</strong>`;
  t.style.opacity = 1;
}
function hideTooltip(){ tooltip.style.opacity = 0; }

function openPopup(splitterObj, ponName, winName) {
  const modal = document.getElementById('popupModal');
  document.getElementById('popupTitle').textContent = `${splitterObj.type || 'Splitter'} ‚Äî Users`;
  document.getElementById('popupPath').textContent = `${winName} ‚Üí ${ponName} ‚Üí ${splitterObj.recordId || ''}`;
  document.getElementById('popupMeta').innerHTML = `<div><strong>Total users:</strong> ${splitterObj.total || (splitterObj.users ? splitterObj.users.length : 0)}</div>`;
  const tbl = document.getElementById('popupUsersTable');
  const users = Array.isArray(splitterObj.users) ? splitterObj.users : [];
  tbl.innerHTML = `<thead><tr><th>Sr</th><th>User ID</th></tr></thead><tbody>${users.map((u,i)=>`<tr><td>${i+1}</td><td>${u}</td></tr>`).join('')}</tbody>`;
  modal.style.display = 'flex';
}

/* ================= SEARCH ================= */
function runSearch(clear=false) {
  const q = searchInput.value.trim();
  if (clear || !q) {
    // remove highlights
    d3.selectAll('circle').classed('highlight', false);
    summaryTag.textContent = `Processed: ${rawJson.summary?.processedRows ?? '-'}  |  Windows: ${ (rawJson.windows||[]).length }`;
    return;
  }

  // find nodes that include user id (flexible match)
  // we will iterate through svg text/structures by checking rawJson and then finding matching coordinates visually
  const matches = [];

  // go through filteredJson to find splitters containing the user
  (filteredJson.windows || []).forEach(win => {
    (win.pons || []).forEach(pon => {
      (pon.levels || []).forEach(lv => {
        (lv.splitters || []).forEach(sp => {
          const users = sp.users || [];
          for (const u of users) {
            if (String(u).includes(q)) {
              matches.push({ win: win.window, pon: pon.pon, splitter: sp, user: u });
              break;
            }
          }
        });
      });
    });
  });

  if (!matches.length) {
    alert('No matches found for: ' + q);
    return;
  }

  // highlight all matching splitters by recordId (match recordIds in svg labels)
  // approach: remove old highlights then find circles with nearby recordId text matching
  d3.selectAll('circle').classed('highlight', false);

  // because there's not a strict mapping from DOM nodes to data here, we highlight circles by searching popup recordId text or label text:
  // simpler: find all text nodes with recordId text and highlight the circle at same x/y - using positional proximity
  const svg = d3.select('#chart svg');
  const texts = svg.selectAll('text').nodes();

  matches.forEach(m => {
    const rid = (m.splitter.recordId || '').toString();
    if (!rid) return;
    // find text node with exact recordId
    const candidate = texts.find(t => t.textContent === rid);
    if (candidate) {
      // find nearest circle to that text (same x)
      const tx = parseFloat(candidate.getAttribute('x') || 0);
      const ty = parseFloat(candidate.getAttribute('y') || 0);
      const circles = svg.selectAll('circle').nodes();
      let best = null; let bestDist = Infinity;
      circles.forEach(c => {
        const cx = parseFloat(c.getAttribute('cx') || 0);
        const cy = parseFloat(c.getAttribute('cy') || 0);
        const d2 = Math.hypot(cx - tx, cy - ty);
        if (d2 < bestDist) { bestDist = d2; best = c; }
      });
      if (best && bestDist < 80) { d3.select(best).classed('highlight', true); }
    } else {
      // fallback: try to match label text like "type (count)" - find by user count or type
      // (we skip fallback complexity for speed)
    }
  });

  summaryTag.textContent = `Found ${matches.length} matching splitter(s) for "${q}". Highlighted.`;
}

/* ================= UTILITIES ================= */
function applyAndCloseFilters(){ applyFilters.click(); } // wrapper in case needed

/* ================ INIT ================ */
loadAndRender(false);
window.addEventListener('resize', ()=> { if (filteredJson) renderFromJson(filteredJson); });

</script>
</body>
</html>
