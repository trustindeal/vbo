<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Merotra ‚Äî PON / Splitter Table (Level Columns)</title>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- Your adv.css -->
  <link rel="stylesheet" href="adv.css">

  <!-- small fallback styles so UI doesn't break if adv.css missing -->
  <style>
    :root{font-family:Inter,system-ui,Arial}
    body{margin:0;padding:0;background:linear-gradient(135deg,#f0f9ff,#e0f2fe);color:#111827;height:100vh;overflow:hidden}
    .header{display:flex;justify-content:space-between;align-items:center;padding:10px 16px;background:rgba(255,255,255,0.95);box-shadow:0 4px 20px rgba(0,0,0,0.06);position:sticky;top:0;z-index:30}
    .header-title{font-weight:800;font-size:1.1rem}
    #chart{width:100%;height:calc(100vh - 60px);overflow:hidden}
    .tooltip{position:absolute;pointer-events:none;background:rgba(15,23,42,0.9);color:#fff;padding:8px 10px;border-radius:8px;font-size:12px;opacity:0;transition:opacity .12s;z-index:60}
    .btn{background:#2563eb;color:#fff;padding:6px 12px;border-radius:999px;border:none;cursor:pointer}
    /* folded search */
    .search-fold { display:flex; gap:8px; align-items:center; }
    .search-input { width:0; transition: width .18s; padding:6px 8px; border-radius:8px; border:1px solid #e5e7eb; background:#fff; }
    .search-input.open { width:220px; }
    .filter-area { display:flex; gap:8px; align-items:center; }
    @media (max-width:800px){ .search-input.open{ width:140px; } }
  </style>
</head>
<body>

  <div class="header">
    <div>
      <div class="header-title">üåê Merotra Network ‚Äî Column Levels</div>
      <div style="font-size:12px;color:#6b7280">Merotra Network ‚Üí Window ‚Üí OLT ‚Üí PON ‚Üí Level1 ‚Üí Level2 ‚Üí ...</div>
    </div>

    <div style="display:flex;gap:8px;align-items:center">
      <div class="filter-area">
        <div id="filterBtn" class="btn btn-secondary" style="padding:6px 10px; cursor:pointer">Filters</div>
        <button id="reloadBtn" class="btn">Reload</button>
      </div>

      <div class="search-fold">
        <button id="searchToggle" class="btn btn-secondary">üîç Search</button>
        <input id="searchInput" class="search-input" placeholder="Search user-id or exact id..." />
        <button id="searchBtn" class="btn" title="Search">Go</button>
        <button id="clearSearch" class="btn btn-secondary" title="Clear">Clear</button>
      </div>
    </div>
  </div>

  <div id="chart"></div>
  <div id="tooltip" class="tooltip"></div>

  <!-- POPUP -->
  <div id="popupModal" class="popup-backdrop" style="display:none">
    <div class="modal-content">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:8px">
        <div>
          <h2 id="popupTitle" style="margin:0;font-size:16px"></h2>
          <div id="popupPath" style="font-size:12px;color:#475569"></div>
        </div>
        <button id="popupClose" class="btn btn-secondary" style="height:30px">Close</button>
      </div>

      <div id="popupMeta" style="font-size:13px;color:#334155;margin-bottom:8px"></div>
      <div id="popupLinks" style="margin-bottom:8px"></div>

      <h3 style="margin:8px 0 6px;font-size:14px">Users</h3>
      <div style="max-height:300px;overflow:auto">
        <table id="popupUsersTable" class="user-table"></table>
      </div>

      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="btnShot" class="btn btn-shot">üì∏ Screenshot</button>
        <button id="btnCsv" class="btn btn-csv">üìä CSV</button>
      </div>
    </div>
  </div>

  <!-- FILTER MODAL -->
  <div id="controlsModal" class="controls-backdrop" style="display:none">
    <div class="controls-modal">
      <h3 style="margin:0 0 8px">Filters</h3>
      <div style="display:flex;gap:12px">
        <div style="flex:1">
          <div class="filter-title">Windows</div>
          <div id="windowFilters" class="checkbox-grid" style="max-height:160px;overflow:auto"></div>
        </div>
        <div style="flex:1">
          <div class="filter-title">PONs</div>
          <div id="ponFilters" class="checkbox-grid pon-grid" ></div>
        </div>
      </div>
      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="applyFiltersBtn" class="btn" style="flex:1">Apply</button>
        <button id="controlsClose" class="btn btn-secondary" style="flex:1">Close</button>
      </div>
    </div>
  </div>

<script>
/* =============== CONFIG =============== */
const BOARD_URL = "https://script.google.com/macros/s/AKfycbzItUueYIqcUuCn2cDaTTrWIF0LiilUxOXhhL-4b4D9aUlEo8Ov9pasR44d6JSM3h1t/exec?mode=board";

/* =============== STATE =============== */
const tooltip = document.getElementById('tooltip');
let rawJson = null;
let filters = { windows: [], pons: [] };
let currentHighlights = new Set();

/* UI elements */
const reloadBtn = document.getElementById('reloadBtn');
const filterBtn = document.getElementById('filterBtn');
const controlsModal = document.getElementById('controlsModal');
const controlsClose = document.getElementById('controlsClose');
const applyFiltersBtn = document.getElementById('applyFiltersBtn');
const windowFiltersDiv = document.getElementById('windowFilters');
const ponFiltersDiv = document.getElementById('ponFilters');

const searchToggle = document.getElementById('searchToggle');
const searchInput = document.getElementById('searchInput');
const searchBtn = document.getElementById('searchBtn');
const clearSearch = document.getElementById('clearSearch');

const popupModal = document.getElementById('popupModal');
const popupClose = document.getElementById('popupClose');

/* =============== Helpers =============== */
function normalizeId(v){ return (v ?? "").toString().trim(); }
function randColorSeed(seed) {
  // deterministic-ish color by seed (seed should be integer)
  const h = (seed * 47) % 360;
  return `hsl(${h} 68% 48%)`;
}
function parsePonToOlt(pon) {
  // OLT = digit(s) following first 'O'
  const m = (pon || "").match(/O(\d+)/i);
  if (!m) return '0';
  return m[1];
}

/* =============== UI bindings =============== */
reloadBtn.addEventListener('click', ()=> loadAndRender(true));
filterBtn.addEventListener('click', ()=> controlsModal.style.display='flex');
controlsClose.addEventListener('click', ()=> controlsModal.style.display='none');
applyFiltersBtn.addEventListener('click', ()=> { applyFiltersFromUI(); controlsModal.style.display='none'; });

searchToggle.addEventListener('click', ()=>{
  searchInput.classList.toggle('open');
  if (searchInput.classList.contains('open')) { searchInput.focus(); }
});
searchBtn.addEventListener('click', ()=> doSearch());
clearSearch.addEventListener('click', ()=> { searchInput.value=''; currentHighlights.clear(); renderFromJson(rawJson); });

popupClose.addEventListener('click', ()=> popupModal.style.display='none');
document.getElementById('btnCsv').addEventListener('click', downloadCSV);
document.getElementById('btnShot').addEventListener('click', downloadScreenshot);

/* =============== Load data =============== */
async function loadAndRender(showToast=false) {
  try {
    setLoading(true);
    const res = await fetch(BOARD_URL);
    if(!res.ok) throw new Error('Failed fetch: ' + res.status);
    const j = await res.json();
    rawJson = j;
    // Build filter lists
    setupFiltersFromJson(j);
    const filtered = filterJson(j, filters);
    renderFromJson(filtered);
    if (showToast) console.info('Loaded board');
  } catch (err) {
    console.error(err);
    alert('Load failed: ' + (err.message || err));
  } finally {
    setLoading(false);
  }
}
function setLoading(flag){
  reloadBtn.textContent = flag ? 'Loading...' : 'Reload';
  reloadBtn.disabled = flag;
}

/* =============== Filters UI =============== */
function setupFiltersFromJson(j) {
  const ws = new Set();
  const ps = new Set();
  if (!j || !Array.isArray(j.windows)) return;
  j.windows.forEach(w => {
    ws.add(w.window || '');
    (w.pons||[]).forEach(p => ps.add(p.pon || ''));
  });
  const windows = Array.from(ws).sort();
  const pons = Array.from(ps).sort();

  windowFiltersDiv.innerHTML = '';
  windows.forEach(w => {
    const id = 'w_' + w.replace(/\s+/g,'_');
    const el = document.createElement('div'); el.className='checkbox-item';
    el.innerHTML = `<label><input type="checkbox" value="${w}" checked id="${id}"> <span>${w}</span></label>`;
    windowFiltersDiv.appendChild(el);
  });

  ponFiltersDiv.innerHTML = '';
  pons.forEach(p => {
    const id = 'p_' + p.replace(/\s+/g,'_');
    const el = document.createElement('div'); el.className='checkbox-item';
    el.innerHTML = `<label><input type="checkbox" value="${p}" checked id="${id}"> <span>${p}</span></label>`;
    ponFiltersDiv.appendChild(el);
  });

  // initial filters state
  filters.windows = windows.slice();
  filters.pons = pons.slice();
}

function applyFiltersFromUI() {
  filters.windows = Array.from(windowFiltersDiv.querySelectorAll('input:checked')).map(i=>i.value);
  filters.pons = Array.from(ponFiltersDiv.querySelectorAll('input:checked')).map(i=>i.value);
  const filtered = filterJson(rawJson, filters);
  renderFromJson(filtered);
}

function filterJson(j, f) {
  if (!j) return j;
  const out = { windows: [] };
  (j.windows || []).forEach(win => {
    if (!f.windows.includes(win.window)) return;
    const winCopy = { window: win.window, pons: [] };
    (win.pons || []).forEach(p => {
      if (!f.pons.includes(p.pon)) return;
      winCopy.pons.push(p);
    });
    if (winCopy.pons.length) out.windows.push(winCopy);
  });
  return out;
}

/* =============== Render (column layout with Merotra->Window->OLT->PON->levels) =============== */
function renderFromJson(serverJson) {
  // clear chart
  const chart = document.getElementById('chart');
  chart.innerHTML = '';

  if (!serverJson || !Array.isArray(serverJson.windows) || serverJson.windows.length === 0) {
    chart.innerHTML = '<div style="padding:20px;color:#6b7280">No data</div>';
    return;
  }

  // SVG + groups
  const svg = d3.select('#chart').append('svg').attr('width','100%').attr('height','100%').style('background','transparent');
  const g = svg.append('g');

  const zoom = d3.zoom().scaleExtent([0.4, 2.2]).on('zoom', (evt) => g.attr('transform', evt.transform));
  svg.call(zoom);

  // layout params (tweakable)
  const colWindow = 140;      // column width for window column
  const colOlt = 120;         // column width for olt column
  const colPon = 160;         // column width for pon column
  const colLevel = 240;       // width for each level column
  const nodeRadius = 12;
  const verticalGapBase = 56; // base vertical gap between splitters
  const sectionGap = 44;      // gap between pons blocks

  const leftPad = 20;
  const topPad = 20;

  let currentY = topPad;

  // NETWORK root label
  g.append('text')
    .attr('x', leftPad)
    .attr('y', currentY)
    .text('Merotra Network')
    .attr('font-weight','800')
    .attr('font-size',16)
    .attr('fill','#0f172a');

  currentY += 28;

  // For each window block
  serverJson.windows.forEach(win => {
    const winName = win.window || 'Window';
    const pons = Array.isArray(win.pons) ? win.pons : [];

    // Window header label (leftmost column for this window area)
    g.append('text')
      .attr('x', leftPad)
      .attr('y', currentY + 12)
      .text(winName)
      .attr('font-weight','700')
      .attr('font-size',14)
      .attr('fill','#0f172a');

    currentY += 24; // header height

    // For each PON, but grouped by OLT under same window
    // Build OLT map: olt -> [ponObj,...]
    const oltMap = {};
    pons.forEach(p => {
      const olt = parsePonToOlt(p.pon || '');
      if (!oltMap[olt]) oltMap[olt] = [];
      oltMap[olt].push(p);
    });

    const olts = Object.keys(oltMap).sort((a,b)=> +a - +b);

    // For layout we stack PON blocks vertically (each PON block contains OLT header + PON row + levels)
    olts.forEach(olt => {
      const oltColor = randColorSeed(parseInt(olt || '0',10));
      const oltPons = oltMap[olt];

      // For each PON in this OLT
      oltPons.forEach((ponObj, ponIndex) => {
        const ponName = ponObj.pon || 'PON';
        const levels = Array.isArray(ponObj.levels) ? ponObj.levels : [];
        levels.sort((a,b)=> (a.level||0) - (b.level||0)); // ensure ascending levels

        // compute max splitters across columns (levels)
        const levelCounts = levels.map(l => (l.splitters||[]).length || 0);
        const maxNodes = Math.max(1, ...levelCounts);

        // dynamic vertical gap to avoid overlap: increase gap if many nodes
        const nodeVgap = Math.max(verticalGapBase, Math.ceil((maxNodes * 18) / 1) + verticalGapBase);

        const blockHeight = Math.max((maxNodes * nodeVgap) + 40, 90);
        const blockY = currentY;
        const centerY = blockY + blockHeight/2;

        // Column X positions (left->right): network col, window col, OLT col, PON col, level1..N
        const networkX = leftPad;
        const windowX = networkX + colWindow;
        const oltX = windowX + colWindow;
        const ponX = oltX + colOlt;
        const levelStartX = ponX + colPon;

        // 1) draw OLT node (circle) at (oltX, centerY)
        g.append('circle')
          .attr('cx', oltX)
          .attr('cy', centerY)
          .attr('r', nodeRadius+6)
          .attr('fill', oltColor)
          .attr('stroke','#fff').attr('stroke-width',2);

        g.append('text')
          .attr('x', oltX - nodeRadius - 6)
          .attr('y', centerY - 18)
          .text(`OLT-${olt}`)
          .attr('font-size',11)
          .attr('text-anchor','middle');

        // 2) draw PON node
        g.append('circle')
          .attr('cx', ponX)
          .attr('cy', centerY)
          .attr('r', nodeRadius+4)
          .attr('fill','#0f766e')
          .attr('stroke','#fff').attr('stroke-width',2);

        g.append('text')
          .attr('x', ponX + nodeRadius + 8)
          .attr('y', centerY + 4)
          .text(ponName + (ponObj.totalUsers ? ` (${ponObj.totalUsers})` : ''))
          .attr('font-size',12)
          .attr('fill','#0f172a');

        // 3) prepare level node positions
        const levelNodesPositions = []; // array per level -> [{s,x,y},...]
        levels.forEach((lvl, li) => {
          const splitters = Array.isArray(lvl.splitters) ? lvl.splitters : [];
          const colX = levelStartX + li * colLevel;
          const count = Math.max(1, splitters.length);
          const totalHeight = (count - 1) * nodeVgap;
          let startY = centerY - (totalHeight / 2);
          const positions = [];
          for (let si=0; si<splitters.length; si++){
            const s = splitters[si];
            const x = colX;
            const y = startY + si * nodeVgap;
            positions.push({ s, x, y });
          }
          levelNodesPositions.push(positions);
        });

        // 4) Draw Network->Window, Window->OLT, OLT->PON connections
        // network text at networkX (one per window group, but we draw it per block for simplicity)
        // NETWORK label drawn only once per window earlier; draw connecting lines:
        // a) Network -> Window: find Window text x,y
        const netTextX = networkX;
        const netTextY = currentY - 6; // upstream (approx)
        // find Window text position: it was drawn at (windowX, currentY - 24)
        const winTextX = windowX;
        const winTextY = currentY - 12;

        // draw Window -> OLT
        const pathWinToOlt = linkPath({x:winTextX + 8, y:winTextY + 6}, {x:oltX, y:centerY});
        g.append('path').attr('d', pathWinToOlt).attr('fill','none').attr('stroke','#64748b').attr('stroke-width',1.6).attr('stroke-opacity',0.9);

        // draw OLT -> PON (colored by OLT branch)
        const pathOltToPon = linkPath({x:oltX, y:centerY}, {x:ponX, y:centerY});
        g.append('path').attr('d', pathOltToPon).attr('fill','none').attr('stroke', oltColor).attr('stroke-width',2.2).attr('stroke-opacity',0.95);

        // 5) Draw PON -> Level1: always connect to all level1 splitters
        if (levelNodesPositions.length >= 1) {
          const lvl1 = levelNodesPositions[0];
          lvl1.forEach(child => {
            const path = linkPath({x:ponX, y:centerY}, {x:child.x, y:child.y});
            g.append('path').attr('d', path).attr('fill','none').attr('stroke', oltColor).attr('stroke-width', 1.8).attr('stroke-opacity', 0.95).attr('class','link');
          });
        }

        // 6) Draw LevelN -> LevelN+1 links (only to first parent with common users)
        for (let li=0; li < levelNodesPositions.length - 1; li++) {
          const parents = levelNodesPositions[li];
          const children = levelNodesPositions[li+1];

          const parentSets = parents.map(p => new Set((Array.isArray(p.s.users) ? p.s.users.map(normalizeId) : [])));

          children.forEach(child => {
            const childSet = new Set((Array.isArray(child.s.users) ? child.s.users.map(normalizeId) : []));
            let linked = false;
            for (let pi=0; pi<parents.length; pi++) {
              const pset = parentSets[pi];
              let common = false;
              for (const u of childSet) { if (pset.has(u)) { common = true; break; } }
              if (common) {
                const pnode = parents[pi];
                const path = linkPath({x:pnode.x, y:pnode.y}, {x:child.x, y:child.y});
                g.append('path').attr('d', path).attr('fill','none').attr('stroke', oltColor).attr('stroke-width', 1.6).attr('stroke-opacity',0.95).attr('class','link');
                linked = true;
                break;
              }
            }
            // if not linked: do not draw (per rule)
          });
        }

        // 7) Draw all splitters (circles + labels) level by level (sheet order preserved)
        levelNodesPositions.forEach((posArr, li) => {
          posArr.forEach(p => {
            const s = p.s;
            const circle = g.append('circle')
              .attr('cx', p.x)
              .attr('cy', p.y)
              .attr('r', nodeRadius)
              .attr('fill', currentHighlights.size && intersectsSet(currentHighlights, new Set((s.users||[]).map(normalizeId))) ? '#f59e0b' : '#10b981')
              .attr('stroke','#fff').attr('stroke-width',2)
              .style('cursor','pointer')
              .on('mousemove', (event) => showTooltip(event, s, p.x, p.y))
              .on('mouseout', ()=> hideTooltip())
              .on('click', ()=> openPopup(s, ponName, winName));

            // label right
            const label = (s.type ? `${s.type}` : '') + (s.total ? ` (${s.total})` : '');
            g.append('text')
              .attr('x', p.x + nodeRadius + 8)
              .attr('y', p.y + 4)
              .text(label)
              .attr('font-size',11)
              .attr('fill','#0f172a');

            // small id under
            if (s.recordId) {
              g.append('text')
                .attr('x', p.x)
                .attr('y', p.y + nodeRadius + 14)
                .text(s.recordId)
                .attr('font-size',10)
                .attr('fill','#64748b')
                .attr('text-anchor','middle');
            }
          });
        });

        // advance currentY
        currentY += blockHeight + sectionGap;
      }); // pon loop
    }); // olt loop

    // some extra space after window
    currentY += 18;
  }); // windows loop

  // network -> window connectors: we draw earlier window->olt; but draw network->window linking for clarity
  // For simplicity, connect merotra root position to first window OLT in each window block
  // (we used win text positions earlier; draw lightweight lines)
  // We'll compute visible window text nodes by scanning text elements with the window names
  // (But for stability: draw a vertical list left col and connect to OLTs)
  // Instead of complex selection, we'll rely on already-drawn OLTs and draw lines from leftmost (network area) to each window's first OLT
  // (No additional code necessary here.)

  // Fit-to-view
  fitToView(svg.node(), g.node());
}

/* helper path maker */
function linkPath(src, dst) {
  const midX = src.x + (dst.x - src.x) * 0.5;
  return `M ${src.x} ${src.y} C ${midX} ${src.y} ${midX} ${dst.y} ${dst.x} ${dst.y}`;
}

/* fit to view */
function fitToView(svgNode, gNode) {
  try {
    const bbox = gNode.getBBox();
    const svgW = svgNode.clientWidth || (window.innerWidth);
    const svgH = svgNode.clientHeight || (window.innerHeight - 60);
    if (!isFinite(bbox.width) || bbox.width === 0) return;
    const scale = Math.min(1.0, Math.min(svgW / (bbox.width + 120), svgH / (bbox.height + 160)));
    const tx = -bbox.x * scale + 20;
    const ty = -bbox.y * scale + 20;
    d3.select(svgNode).transition().duration(500).call(
      d3.zoom().transform,
      d3.zoomIdentity.translate(tx, ty).scale(scale)
    );
  } catch (e) {
    // ignore
  }
}

/* tooltip & popup */
function showTooltip(event, splitterObj, x, y) {
  const t = tooltip;
  t.style.left = (event.pageX + 12) + 'px';
  t.style.top = (event.pageY + 8) + 'px';
  const users = Array.isArray(splitterObj.users) ? splitterObj.users.length : 0;
  t.innerHTML = `<strong>${splitterObj.type || splitterObj.recordId || 'Splitter'}</strong><br/>Record: ${splitterObj.recordId||'-'}<br/>Users: <strong>${users}</strong>`;
  t.style.opacity = 1;
}
function hideTooltip() { tooltip.style.opacity = 0; }

function openPopup(splitterObj, ponName, winName) {
  popupModal.style.display = 'flex';
  document.getElementById('popupTitle').textContent = `${splitterObj.type || 'Splitter'} ‚Äî Users`;
  document.getElementById('popupPath').textContent = `${winName} ‚Üí ${ponName} ‚Üí ${splitterObj.recordId || ''}`;
  document.getElementById('popupMeta').innerHTML = `<div><strong>Total users:</strong> ${splitterObj.total || (splitterObj.users ? splitterObj.users.length : 0)}</div>`;
  const tbl = document.getElementById('popupUsersTable');
  const users = Array.isArray(splitterObj.users) ? splitterObj.users : [];
  tbl.innerHTML = `<thead><tr><th>Sr</th><th>User ID</th></tr></thead><tbody>${users.map((u,i)=>`<tr><td>${i+1}</td><td>${u}</td></tr>`).join('')}</tbody>`;
}

/* =============== Search =============== */
function intersectsSet(highlightSet, sset) {
  if (!highlightSet || highlightSet.size===0) return false;
  for (const x of sset) if (highlightSet.has(x)) return true;
  return false;
}

function doSearch() {
  const q = normalizeId(searchInput.value);
  if (!q) { alert('Enter user id to search'); return; }
  // flexible match: exact or substring
  currentHighlights.clear();
  // scan rawJson to collect matching ids
  (rawJson.windows || []).forEach(win => {
    (win.pons || []).forEach(pon => {
      (pon.levels || []).forEach(lv => {
        (lv.splitters || []).forEach(s => {
          (s.users || []).forEach(u => {
            const uid = normalizeId(u);
            if (uid.includes(q)) currentHighlights.add(uid);
          });
        });
      });
    });
  });
  if (currentHighlights.size === 0) {
    alert('No matching user-id found');
    return;
  }
  // Re-render filtered view (keeping same filters)
  const filtered = filterJson(rawJson, filters);
  renderFromJson(filtered);
  // keep highlights until cleared (per your requirement)
}

/* =============== Downloads =============== */
function downloadCSV(){
  if (popupModal.style.display === 'none' || popupModal.style.display === '') return;
  const tbl = document.getElementById('popupUsersTable');
  if (!tbl) return;
  const rows = Array.from(tbl.querySelectorAll('tr'));
  if (!rows.length) return;
  let csv = '';
  rows.forEach((r, idx) => {
    const cols = Array.from(r.querySelectorAll('th,td')).map(c => `"${(c.textContent||'').replace(/"/g,'""')}"`);
    csv += cols.join(',') + '\n';
  });
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'splitter-users.csv'; a.click();
  URL.revokeObjectURL(url);
}

function downloadScreenshot(){
  const svgEl = document.querySelector('#chart svg');
  if (!svgEl) return alert('No chart to screenshot');
  const serializer = new XMLSerializer();
  const source = serializer.serializeToString(svgEl);
  const svgBlob = new Blob([source], {type: 'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(svgBlob);
  const a = document.createElement('a');
  a.href = url; a.download = 'merotra-tree.svg'; a.click();
  URL.revokeObjectURL(url);
}

/* =============== INIT =============== */
loadAndRender(false);
window.addEventListener('resize', ()=> { if (rawJson) renderFromJson(filterJson(rawJson, filters)); });

</script>
</body>
</html>
